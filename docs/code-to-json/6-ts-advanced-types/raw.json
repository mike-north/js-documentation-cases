{
  "declaration": {
    "01m4wlvblxmn": {
      "id": "01m4wlvblxmn",
      "pos": 158,
      "end": 290,
      "text": "constructor(protected numWheels: number) {}",
      "sourceFile": [
        "sourceFile",
        "01m4wlu7hcxf"
      ],
      "thing": "declaration",
      "kind": "Constructor",
      "flags": "HasImplicitReturn",
      "parent": [
        "node",
        "01m4wnmkepxu"
      ]
    },
    "01m4wlriu6r5": {
      "id": "01m4wlriu6r5",
      "pos": 194,
      "end": 233,
      "text": "new (\n  numWheels: N,\n) => VehicleLike",
      "sourceFile": [
        "sourceFile",
        "01m4wnff99qd"
      ],
      "thing": "declaration",
      "kind": "ConstructorType",
      "parent": [
        "node",
        "01m4wmmjrvpn"
      ]
    },
    "01m4wndtcqy6": {
      "id": "01m4wndtcqy6",
      "pos": 110,
      "end": 146,
      "text": "constructor() {\n    super(2);\n  }",
      "sourceFile": [
        "sourceFile",
        "01m4wmg3dxx8"
      ],
      "thing": "declaration",
      "kind": "Constructor",
      "flags": "HasImplicitReturn",
      "parent": [
        "node",
        "01m4wnhowcn6"
      ]
    },
    "01m4wne2q8pw": {
      "id": "01m4wne2q8pw",
      "pos": 283,
      "end": 319,
      "text": "constructor() {\n    super(1);\n  }",
      "sourceFile": [
        "sourceFile",
        "01m4wmg3dxx8"
      ],
      "thing": "declaration",
      "kind": "Constructor",
      "flags": "HasImplicitReturn",
      "parent": [
        "node",
        "01m4wmxuabg6"
      ]
    },
    "01m4wn3wrayb": {
      "id": "01m4wn3wrayb",
      "pos": 116,
      "end": 186,
      "text": "constructor() {\n    super(4);\n  }",
      "sourceFile": [
        "sourceFile",
        "01m4wmnl4m34"
      ],
      "thing": "declaration",
      "kind": "Constructor",
      "flags": "HasImplicitReturn",
      "parent": [
        "node",
        "01m4wmyeu4oh"
      ]
    },
    "01m4wlorf6g7": {
      "id": "01m4wlorf6g7",
      "pos": 65,
      "end": 204,
      "text": "export function add(a: number, b: number): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "declaration",
      "kind": "FunctionDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "add",
      "type": [
        "type",
        92
      ]
    },
    "01m4wna76n7c": {
      "id": "01m4wna76n7c",
      "pos": 204,
      "end": 255,
      "text": "export function add(a: string, b: string): string;",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "declaration",
      "kind": "FunctionDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "add",
      "type": [
        "type",
        92
      ]
    },
    "01m4wmalwu21": {
      "id": "01m4wmalwu21",
      "pos": 62,
      "end": 110,
      "text": "drive(): void;",
      "sourceFile": [
        "sourceFile",
        "01m4wnff99qd"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "parent": [
        "node",
        "01m4wn661fce"
      ],
      "name": "drive",
      "type": [
        "type",
        154
      ]
    },
    "01m4wmqi5ass": {
      "id": "01m4wmqi5ass",
      "pos": 290,
      "end": 427,
      "text": "public drive() {\n    return `Driving with all ${this.numWheels} wheels`;\n  }",
      "sourceFile": [
        "sourceFile",
        "01m4wlu7hcxf"
      ],
      "thing": "declaration",
      "kind": "MethodDeclaration",
      "modifiers": [
        "PublicKeyword"
      ],
      "parent": [
        "node",
        "01m4wnmkepxu"
      ],
      "name": "drive",
      "type": [
        "type",
        155
      ]
    },
    "01m4wlvv6pv0": {
      "id": "01m4wlvv6pv0",
      "pos": 983,
      "end": 1449,
      "text": "new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "ConstructSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ]
    },
    "01m4wm2gtk7p": {
      "id": "01m4wm2gtk7p",
      "pos": 1092,
      "end": 1308,
      "text": "function timeout(n: number) {\n  return new Promise<void>(resolve => setTimeout(resolve, n));\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "declaration",
      "kind": "FunctionDeclaration",
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "timeout",
      "type": [
        "type",
        101
      ]
    },
    "01m4wnjf0l7m": {
      "id": "01m4wnjf0l7m",
      "pos": 60343,
      "end": 60917,
      "text": "then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm7qb3gh"
      ],
      "name": "then",
      "type": [
        "type",
        127
      ]
    },
    "01m4wmd7r6vt": {
      "id": "01m4wmd7r6vt",
      "pos": 60917,
      "end": 61274,
      "text": "catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm7qb3gh"
      ],
      "name": "catch",
      "type": [
        "type",
        159
      ]
    },
    "01m4wluttyqs": {
      "id": "01m4wluttyqs",
      "pos": 950,
      "end": 1358,
      "text": "finally(onfinally?: (() => void) | undefined | null): Promise<T>",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmyvm22v"
      ],
      "name": "finally",
      "type": [
        "type",
        165
      ]
    },
    "01m4wmxdiclu": {
      "id": "01m4wmxdiclu",
      "pos": 1347,
      "end": 1435,
      "text": "(resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wncmfcnd"
      ]
    },
    "01m4wm3476eb": {
      "id": "01m4wm3476eb",
      "pos": 775,
      "end": 841,
      "text": "public memberFn() {\n    return '';\n  }",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "declaration",
      "kind": "MethodDeclaration",
      "modifiers": [
        "PublicKeyword"
      ],
      "parent": [
        "node",
        "01m4wno7p69a"
      ],
      "name": "memberFn",
      "type": [
        "type",
        166
      ]
    },
    "01m4wm6gkv1x": {
      "id": "01m4wm6gkv1x",
      "pos": 910,
      "end": 1011,
      "text": "export function createBike(): Bike {\n    return new Bike();\n  }",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "declaration",
      "kind": "FunctionDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wntedv7o"
      ],
      "name": "createBike",
      "type": [
        "type",
        99
      ]
    },
    "01m4wm2i8h63": {
      "id": "01m4wm2i8h63",
      "pos": 60734,
      "end": 60780,
      "text": "(value: T) => TResult1 | PromiseLike<TResult1>",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlog8ur3"
      ]
    },
    "01m4wmalwu66": {
      "id": "01m4wmalwu66",
      "pos": 60816,
      "end": 60865,
      "text": "(reason: any) => TResult2 | PromiseLike<TResult2>",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmwkk3hw"
      ]
    },
    "01m4wnnviugy": {
      "id": "01m4wnnviugy",
      "pos": 61183,
      "end": 61230,
      "text": "(reason: any) => TResult | PromiseLike<TResult>",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eplc"
      ]
    },
    "01m4wn4ej8tc": {
      "id": "01m4wn4ej8tc",
      "pos": 1315,
      "end": 1325,
      "text": "() => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmghd3d6"
      ]
    },
    "01m4wlx4i1ku": {
      "id": "01m4wlx4i1ku",
      "pos": 1357,
      "end": 1394,
      "text": "(value?: T | PromiseLike<T>) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnwcsgo8"
      ]
    },
    "01m4wn638l5i": {
      "id": "01m4wn638l5i",
      "pos": 1403,
      "end": 1426,
      "text": "(reason?: any) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlperru3"
      ]
    },
    "01m4wnb04wlk": {
      "id": "01m4wnb04wlk",
      "pos": 5473,
      "end": 5798,
      "text": "all<TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn87b04o"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wmugho26": {
      "id": "01m4wmugho26",
      "pos": 1449,
      "end": 2034,
      "text": "all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wmxdicne": {
      "id": "01m4wmxdicne",
      "pos": 2034,
      "end": 2585,
      "text": "all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wm41c6cm": {
      "id": "01m4wm41c6cm",
      "pos": 2585,
      "end": 3106,
      "text": "all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wnhax6us": {
      "id": "01m4wnhax6us",
      "pos": 3106,
      "end": 3597,
      "text": "all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wmhr3anb": {
      "id": "01m4wmhr3anb",
      "pos": 3597,
      "end": 4058,
      "text": "all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wnw3125t": {
      "id": "01m4wnw3125t",
      "pos": 4058,
      "end": 4489,
      "text": "all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wn4sicsq": {
      "id": "01m4wn4sicsq",
      "pos": 4489,
      "end": 4890,
      "text": "all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>]): Promise<[T1, T2, T3, T4]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wnctex9d": {
      "id": "01m4wnctex9d",
      "pos": 4890,
      "end": 5260,
      "text": "all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wlytlb6h": {
      "id": "01m4wlytlb6h",
      "pos": 5260,
      "end": 5600,
      "text": "all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wmqyw9d6": {
      "id": "01m4wmqyw9d6",
      "pos": 5600,
      "end": 5908,
      "text": "all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "all",
      "type": [
        "type",
        177
      ]
    },
    "01m4wn27o14c": {
      "id": "01m4wn27o14c",
      "pos": 5798,
      "end": 6073,
      "text": "race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn87b04o"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wmk7c1ex": {
      "id": "01m4wmk7c1ex",
      "pos": 5908,
      "end": 6462,
      "text": "race<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wmo4aj04": {
      "id": "01m4wmo4aj04",
      "pos": 6462,
      "end": 6981,
      "text": "race<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wnlaoh6m": {
      "id": "01m4wnlaoh6m",
      "pos": 6981,
      "end": 7469,
      "text": "race<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wlrsmlfh": {
      "id": "01m4wlrsmlfh",
      "pos": 7469,
      "end": 7926,
      "text": "race<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wmlh27mc": {
      "id": "01m4wmlh27mc",
      "pos": 7926,
      "end": 8352,
      "text": "race<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<T1 | T2 | T3 | T4 | T5 | T6>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wm542u35": {
      "id": "01m4wm542u35",
      "pos": 8352,
      "end": 8747,
      "text": "race<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<T1 | T2 | T3 | T4 | T5>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wn3eleas": {
      "id": "01m4wn3eleas",
      "pos": 8747,
      "end": 9111,
      "text": "race<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<T1 | T2 | T3 | T4>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wmxuabkn": {
      "id": "01m4wmxuabkn",
      "pos": 9111,
      "end": 9444,
      "text": "race<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<T1 | T2 | T3>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wnhgits4": {
      "id": "01m4wnhgits4",
      "pos": 9444,
      "end": 9746,
      "text": "race<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<T1 | T2>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wn2ln5o8": {
      "id": "01m4wn2ln5o8",
      "pos": 9746,
      "end": 10015,
      "text": "race<T>(values: (T | PromiseLike<T>)[]): Promise<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "race",
      "type": [
        "type",
        336
      ]
    },
    "01m4wlswr5a8": {
      "id": "01m4wlswr5a8",
      "pos": 10015,
      "end": 10242,
      "text": "reject<T = never>(reason?: any): Promise<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "reject",
      "type": [
        "type",
        414
      ]
    },
    "01m4wlvtrsc5": {
      "id": "01m4wlvtrsc5",
      "pos": 10242,
      "end": 10484,
      "text": "resolve<T>(value: T | PromiseLike<T>): Promise<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "resolve",
      "type": [
        "type",
        417
      ]
    },
    "01m4wnnrc4vi": {
      "id": "01m4wnnrc4vi",
      "pos": 10484,
      "end": 10607,
      "text": "resolve(): Promise<void>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ],
      "name": "resolve",
      "type": [
        "type",
        417
      ]
    },
    "01m4wlv4mdet": {
      "id": "01m4wlv4mdet",
      "pos": 58505,
      "end": 58543,
      "text": "new(arrayLength?: number): any[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "ConstructSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkebklh"
      ]
    },
    "01m4wnmg7yxw": {
      "id": "01m4wnmg7yxw",
      "pos": 58543,
      "end": 58582,
      "text": "new <T>(arrayLength: number): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "ConstructSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkebklh"
      ]
    },
    "01m4wnqpqosj": {
      "id": "01m4wnqpqosj",
      "pos": 58582,
      "end": 58615,
      "text": "new <T>(...items: T[]): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "ConstructSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkebklh"
      ]
    },
    "01m4wne6wy94": {
      "id": "01m4wne6wy94",
      "pos": 58615,
      "end": 58650,
      "text": "(arrayLength?: number): any[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "CallSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkebklh"
      ]
    },
    "01m4wmfy77qk": {
      "id": "01m4wmfy77qk",
      "pos": 58650,
      "end": 58685,
      "text": "<T>(arrayLength: number): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "CallSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkebklh"
      ]
    },
    "01m4wn88ow19": {
      "id": "01m4wn88ow19",
      "pos": 58685,
      "end": 58714,
      "text": "<T>(...items: T[]): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "CallSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkebklh"
      ]
    },
    "01m4wm1uuusy": {
      "id": "01m4wm1uuusy",
      "pos": 1345,
      "end": 1383,
      "text": "[Symbol.iterator](): Iterator<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnpwsg3p"
      ],
      "name": "[Symbol.iterator]",
      "type": [
        "type",
        752
      ]
    },
    "01m4wntv5u4t": {
      "id": "01m4wntv5u4t",
      "pos": 48367,
      "end": 48461,
      "text": "toString(): string;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "toString",
      "type": [
        "type",
        757
      ]
    },
    "01m4wlq0qhwc": {
      "id": "01m4wlq0qhwc",
      "pos": 48461,
      "end": 48633,
      "text": "toLocaleString(): string;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "toLocaleString",
      "type": [
        "type",
        758
      ]
    },
    "01m4wmme78d1": {
      "id": "01m4wmme78d1",
      "pos": 48633,
      "end": 48739,
      "text": "pop(): T | undefined;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "pop",
      "type": [
        "type",
        759
      ]
    },
    "01m4wnw5suxt": {
      "id": "01m4wnw5suxt",
      "pos": 48739,
      "end": 48920,
      "text": "push(...items: T[]): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "push",
      "type": [
        "type",
        760
      ]
    },
    "01m4wnwwd8r1": {
      "id": "01m4wnwwd8r1",
      "pos": 48920,
      "end": 49086,
      "text": "concat(...items: ConcatArray<T>[]): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "concat",
      "type": [
        "type",
        761
      ]
    },
    "01m4wnd7050f": {
      "id": "01m4wnd7050f",
      "pos": 49086,
      "end": 49258,
      "text": "concat(...items: (T | ConcatArray<T>)[]): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "concat",
      "type": [
        "type",
        761
      ]
    },
    "01m4wmkv3iyx": {
      "id": "01m4wmkv3iyx",
      "pos": 49258,
      "end": 49573,
      "text": "join(separator?: string): string;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "join",
      "type": [
        "type",
        762
      ]
    },
    "01m4wmtm5iif": {
      "id": "01m4wmtm5iif",
      "pos": 49573,
      "end": 49653,
      "text": "reverse(): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reverse",
      "type": [
        "type",
        763
      ]
    },
    "01m4wlnvo2te": {
      "id": "01m4wlnvo2te",
      "pos": 49653,
      "end": 49762,
      "text": "shift(): T | undefined;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "shift",
      "type": [
        "type",
        764
      ]
    },
    "01m4wn1954kn": {
      "id": "01m4wn1954kn",
      "pos": 49762,
      "end": 50004,
      "text": "slice(start?: number, end?: number): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "slice",
      "type": [
        "type",
        765
      ]
    },
    "01m4wn1sovgj": {
      "id": "01m4wn1sovgj",
      "pos": 50004,
      "end": 50265,
      "text": "sort(compareFn?: (a: T, b: T) => number): this;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "sort",
      "type": [
        "type",
        766
      ]
    },
    "01m4wn54onx7": {
      "id": "01m4wn54onx7",
      "pos": 50265,
      "end": 50621,
      "text": "splice(start: number, deleteCount?: number): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "splice",
      "type": [
        "type",
        767
      ]
    },
    "01m4wmn9xbky": {
      "id": "01m4wmn9xbky",
      "pos": 50621,
      "end": 51080,
      "text": "splice(start: number, deleteCount: number, ...items: T[]): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "splice",
      "type": [
        "type",
        767
      ]
    },
    "01m4wlnlvpab": {
      "id": "01m4wlnlvpab",
      "pos": 51080,
      "end": 51256,
      "text": "unshift(...items: T[]): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "unshift",
      "type": [
        "type",
        768
      ]
    },
    "01m4wm5rtckw": {
      "id": "01m4wm5rtckw",
      "pos": 51256,
      "end": 51595,
      "text": "indexOf(searchElement: T, fromIndex?: number): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "indexOf",
      "type": [
        "type",
        769
      ]
    },
    "01m4wnt8s8i3": {
      "id": "01m4wnt8s8i3",
      "pos": 51595,
      "end": 51967,
      "text": "lastIndexOf(searchElement: T, fromIndex?: number): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "lastIndexOf",
      "type": [
        "type",
        770
      ]
    },
    "01m4wm4dwd82": {
      "id": "01m4wm4dwd82",
      "pos": 51967,
      "end": 52535,
      "text": "every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "every",
      "type": [
        "type",
        771
      ]
    },
    "01m4wm4tafsm": {
      "id": "01m4wm4tafsm",
      "pos": 52535,
      "end": 53118,
      "text": "some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "some",
      "type": [
        "type",
        772
      ]
    },
    "01m4wmcc145k": {
      "id": "01m4wmcc145k",
      "pos": 53118,
      "end": 53606,
      "text": "forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "forEach",
      "type": [
        "type",
        773
      ]
    },
    "01m4wm2s0ug3": {
      "id": "01m4wm2s0ug3",
      "pos": 53606,
      "end": 54145,
      "text": "map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "map",
      "type": [
        "type",
        774
      ]
    },
    "01m4wmaubbpx": {
      "id": "01m4wmaubbpx",
      "pos": 54145,
      "end": 54685,
      "text": "filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "filter",
      "type": [
        "type",
        777
      ]
    },
    "01m4wlr7nuuj": {
      "id": "01m4wlr7nuuj",
      "pos": 54685,
      "end": 55209,
      "text": "filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "filter",
      "type": [
        "type",
        777
      ]
    },
    "01m4wnndd0ac": {
      "id": "01m4wnndd0ac",
      "pos": 55209,
      "end": 55933,
      "text": "reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduce",
      "type": [
        "type",
        780
      ]
    },
    "01m4wne1cbav": {
      "id": "01m4wne1cbav",
      "pos": 55933,
      "end": 56053,
      "text": "reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduce",
      "type": [
        "type",
        780
      ]
    },
    "01m4wm9f0g9j": {
      "id": "01m4wm9f0g9j",
      "pos": 56053,
      "end": 56797,
      "text": "reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduce",
      "type": [
        "type",
        780
      ]
    },
    "01m4wmo4ah7v": {
      "id": "01m4wmo4ah7v",
      "pos": 56797,
      "end": 57552,
      "text": "reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduceRight",
      "type": [
        "type",
        782
      ]
    },
    "01m4wm813hhm": {
      "id": "01m4wm813hhm",
      "pos": 57552,
      "end": 57677,
      "text": "reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduceRight",
      "type": [
        "type",
        782
      ]
    },
    "01m4wlur24yf": {
      "id": "01m4wlur24yf",
      "pos": 57677,
      "end": 58452,
      "text": "reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduceRight",
      "type": [
        "type",
        782
      ]
    },
    "01m4wlw4k75i": {
      "id": "01m4wlw4k75i",
      "pos": 882,
      "end": 1574,
      "text": "find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "find",
      "type": [
        "type",
        784
      ]
    },
    "01m4wnjgehwi": {
      "id": "01m4wnjgehwi",
      "pos": 1574,
      "end": 1673,
      "text": "find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "find",
      "type": [
        "type",
        784
      ]
    },
    "01m4wlndi7wb": {
      "id": "01m4wlndi7wb",
      "pos": 1673,
      "end": 2332,
      "text": "findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "findIndex",
      "type": [
        "type",
        786
      ]
    },
    "01m4wm5qffwb": {
      "id": "01m4wm5qffwb",
      "pos": 2332,
      "end": 2821,
      "text": "fill(value: T, start?: number, end?: number): this;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "fill",
      "type": [
        "type",
        787
      ]
    },
    "01m4wlvwkmtk": {
      "id": "01m4wlvwkmtk",
      "pos": 2821,
      "end": 3398,
      "text": "copyWithin(target: number, start: number, end?: number): this;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "copyWithin",
      "type": [
        "type",
        788
      ]
    },
    "01m4wmmfl5n3": {
      "id": "01m4wmmfl5n3",
      "pos": 1508,
      "end": 1574,
      "text": "[Symbol.iterator](): IterableIterator<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsp0ijk"
      ],
      "name": "[Symbol.iterator]",
      "type": [
        "type",
        789
      ]
    },
    "01m4wnrmvp4v": {
      "id": "01m4wnrmvp4v",
      "pos": 1574,
      "end": 1713,
      "text": "entries(): IterableIterator<[number, T]>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsp0ijk"
      ],
      "name": "entries",
      "type": [
        "type",
        794
      ]
    },
    "01m4wlqg4j19": {
      "id": "01m4wlqg4j19",
      "pos": 1713,
      "end": 1816,
      "text": "keys(): IterableIterator<number>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsp0ijk"
      ],
      "name": "keys",
      "type": [
        "type",
        797
      ]
    },
    "01m4wmkbiqj1": {
      "id": "01m4wmkbiqj1",
      "pos": 1816,
      "end": 1918,
      "text": "values(): IterableIterator<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsp0ijk"
      ],
      "name": "values",
      "type": [
        "type",
        799
      ]
    },
    "01m4wm980vtr": {
      "id": "01m4wm980vtr",
      "pos": 2973,
      "end": 3332,
      "text": "[Symbol.unscopables](): {\n        copyWithin: boolean;\n        entries: boolean;\n        fill: boolean;\n        find: boolean;\n        findIndex: boolean;\n        keys: boolean;\n        values: boolean;\n    };",
      "sourceFile": [
        "sourceFile",
        "01m4wncw7qaf"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm6f6ypg"
      ],
      "name": "[Symbol.unscopables]",
      "type": [
        "type",
        800
      ]
    },
    "01m4wns8ueh2": {
      "id": "01m4wns8ueh2",
      "pos": 882,
      "end": 1215,
      "text": "includes(searchElement: T, fromIndex?: number): boolean;",
      "sourceFile": [
        "sourceFile",
        "01m4wn4ej8td"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm0ux22r"
      ],
      "name": "includes",
      "type": [
        "type",
        802
      ]
    },
    "01m4wmq4664d": {
      "id": "01m4wmq4664d",
      "pos": 4772,
      "end": 5467,
      "text": "flatMap<U, This = undefined> (\n        callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>,\n        thisArg?: This\n    ): U[]",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flatMap",
      "type": [
        "type",
        803
      ]
    },
    "01m4wns8udyh": {
      "id": "01m4wns8udyh",
      "pos": 5467,
      "end": 5714,
      "text": "flat<U>(this: U[][][][][][][][], depth: 7): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wmi1uoc1": {
      "id": "01m4wmi1uoc1",
      "pos": 5714,
      "end": 5959,
      "text": "flat<U>(this: U[][][][][][][], depth: 6): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wnjrksae": {
      "id": "01m4wnjrksae",
      "pos": 5959,
      "end": 6202,
      "text": "flat<U>(this: U[][][][][][], depth: 5): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wm9vreby": {
      "id": "01m4wm9vreby",
      "pos": 6202,
      "end": 6443,
      "text": "flat<U>(this: U[][][][][], depth: 4): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wnbxnsyd": {
      "id": "01m4wnbxnsyd",
      "pos": 6443,
      "end": 6682,
      "text": "flat<U>(this: U[][][][], depth: 3): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wm2e1poy": {
      "id": "01m4wm2e1poy",
      "pos": 6682,
      "end": 6919,
      "text": "flat<U>(this: U[][][], depth: 2): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wmpme7pj": {
      "id": "01m4wmpme7pj",
      "pos": 6919,
      "end": 7155,
      "text": "flat<U>(this: U[][], depth?: 1): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wluinng1": {
      "id": "01m4wluinng1",
      "pos": 7155,
      "end": 7388,
      "text": "flat<U>(this: U[], depth: 0): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wn3skjoe": {
      "id": "01m4wn3skjoe",
      "pos": 7388,
      "end": 7683,
      "text": "flat<U>(depth?: number): any[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flat",
      "type": [
        "type",
        807
      ]
    },
    "01m4wmitsy1r": {
      "id": "01m4wmitsy1r",
      "pos": 50234,
      "end": 50257,
      "text": "(a: T, b: T) => number",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnf89p5u"
      ]
    },
    "01m4wm6jdp7k": {
      "id": "01m4wm6jdp7k",
      "pos": 53043,
      "end": 53092,
      "text": "(value: T, index: number, array: T[]) => boolean",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmwncwjd"
      ]
    },
    "01m4wn6legmo": {
      "id": "01m4wn6legmo",
      "pos": 53537,
      "end": 53583,
      "text": "(value: T, index: number, array: T[]) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkv3j0q"
      ]
    },
    "01m4wmr5hvyd": {
      "id": "01m4wmr5hvyd",
      "pos": 54080,
      "end": 54123,
      "text": "(value: T, index: number, array: T[]) => U",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn7h5jvg"
      ]
    },
    "01m4wlsy62dk": {
      "id": "01m4wlsy62dk",
      "pos": 54611,
      "end": 54663,
      "text": "(value: T, index: number, array: T[]) => value is S",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn98mq38"
      ]
    },
    "01m4wmkcwnn6": {
      "id": "01m4wmkcwnn6",
      "pos": 55142,
      "end": 55187,
      "text": "(value: T, index: number, array: T[]) => any",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn4aci1t"
      ]
    },
    "01m4wmwyj874": {
      "id": "01m4wmwyj874",
      "pos": 57580,
      "end": 57655,
      "text": "(previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmo1hnx1"
      ]
    },
    "01m4wn0979xx": {
      "id": "01m4wn0979xx",
      "pos": 58355,
      "end": 58430,
      "text": "(previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmqb5pou"
      ]
    },
    "01m4wn0iynjd": {
      "id": "01m4wn0iynjd",
      "pos": 1480,
      "end": 1542,
      "text": "(this: void, value: T, index: number, obj: T[]) => value is S",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wna76n1n"
      ]
    },
    "01m4wmaexael": {
      "id": "01m4wmaexael",
      "pos": 2260,
      "end": 2307,
      "text": "(value: T, index: number, obj: T[]) => boolean",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmi4niuq"
      ]
    },
    "01m4wm7rp0tx": {
      "id": "01m4wm7rp0tx",
      "pos": 5360,
      "end": 5432,
      "text": "(this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmwvqe8j"
      ]
    },
    "01m4wmyst8dx": {
      "id": "01m4wmyst8dx",
      "pos": 58714,
      "end": 58756,
      "text": "isArray(arg: any): arg is Array<any>;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmkebklh"
      ],
      "name": "isArray",
      "type": [
        "type",
        894
      ]
    },
    "01m4wmrkuxf3": {
      "id": "01m4wmrkuxf3",
      "pos": 3430,
      "end": 3609,
      "text": "from<T>(arrayLike: ArrayLike<T>): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnspmc95"
      ],
      "name": "from",
      "type": [
        "type",
        895
      ]
    },
    "01m4wm3xjctl": {
      "id": "01m4wm3xjctl",
      "pos": 3609,
      "end": 3978,
      "text": "from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnspmc95"
      ],
      "name": "from",
      "type": [
        "type",
        895
      ]
    },
    "01m4wnpoey02": {
      "id": "01m4wnpoey02",
      "pos": 1950,
      "end": 2137,
      "text": "from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnfrthog"
      ],
      "name": "from",
      "type": [
        "type",
        895
      ]
    },
    "01m4wn9099ak": {
      "id": "01m4wn9099ak",
      "pos": 2137,
      "end": 2516,
      "text": "from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnfrthog"
      ],
      "name": "from",
      "type": [
        "type",
        895
      ]
    },
    "01m4wm08keo5": {
      "id": "01m4wm08keo5",
      "pos": 3978,
      "end": 4151,
      "text": "of<T>(...items: T[]): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnspmc95"
      ],
      "name": "of",
      "type": [
        "type",
        906
      ]
    },
    "01m4wn0hkqo5": {
      "id": "01m4wn0hkqo5",
      "pos": 7428,
      "end": 7470,
      "text": "next(value?: any): IteratorResult<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmbdh7dp"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm1mhe44"
      ],
      "name": "next",
      "type": [
        "type",
        909
      ]
    },
    "01m4wlplrcnk": {
      "id": "01m4wlplrcnk",
      "pos": 1233,
      "end": 1278,
      "text": "return?(value?: any): IteratorResult<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnujwd5o"
      ],
      "name": "return",
      "type": [
        "type",
        914
      ]
    },
    "01m4wmrgo7ls": {
      "id": "01m4wmrgo7ls",
      "pos": 1278,
      "end": 1318,
      "text": "throw?(e?: any): IteratorResult<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnujwd5o"
      ],
      "name": "throw",
      "type": [
        "type",
        915
      ]
    },
    "01m4wn1hikvd": {
      "id": "01m4wn1hikvd",
      "pos": 1438,
      "end": 1484,
      "text": "[Symbol.iterator](): IterableIterator<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenox55"
      ],
      "name": "[Symbol.iterator]",
      "type": [
        "type",
        916
      ]
    },
    "01m4wni3vgcg": {
      "id": "01m4wni3vgcg",
      "pos": 48102,
      "end": 48140,
      "text": "join(separator?: string): string;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wntpk74k"
      ],
      "name": "join",
      "type": [
        "type",
        917
      ]
    },
    "01m4wmow8r74": {
      "id": "01m4wmow8r74",
      "pos": 48140,
      "end": 48186,
      "text": "slice(start?: number, end?: number): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "declaration",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wntpk74k"
      ],
      "name": "slice",
      "type": [
        "type",
        918
      ]
    },
    "01m4wnq66wlg": {
      "id": "01m4wnq66wlg",
      "pos": 2471,
      "end": 2494,
      "text": "(v: T, k: number) => U",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "declaration",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmebvrlc"
      ]
    }
  },
  "symbol": {
    "01m4wmn1jtlc": {
      "id": "01m4wmn1jtlc",
      "thing": "symbol",
      "name": "\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/types\"",
      "documentation": "",
      "flags": "ValueModule",
      "type": [
        "type",
        67
      ],
      "exports": [
        [
          "symbol",
          "01m4wnhowbqe"
        ],
        [
          "symbol",
          "01m4wlw4k7d8"
        ]
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wne8buvw": {
      "id": "01m4wne8buvw",
      "thing": "symbol",
      "name": "\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/vehicle\"",
      "documentation": "",
      "flags": "ValueModule",
      "type": [
        "type",
        68
      ],
      "exports": [
        [
          "symbol",
          "01m4wnhf4x6o"
        ],
        [
          "symbol",
          "01m4wndgrix2"
        ]
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wllkm4ws": {
      "id": "01m4wllkm4ws",
      "thing": "symbol",
      "name": "\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/cycles\"",
      "documentation": "",
      "flags": "ValueModule",
      "type": [
        "type",
        69
      ],
      "exports": [
        [
          "symbol",
          "01m4wmqi5ait"
        ],
        [
          "symbol",
          "01m4wly78ocm"
        ]
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlrk93ht": {
      "id": "01m4wlrk93ht",
      "thing": "symbol",
      "name": "\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/car\"",
      "documentation": "",
      "flags": "ValueModule",
      "type": [
        "type",
        70
      ],
      "exports": [
        [
          "symbol",
          "01m4wnht42ro"
        ]
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnb74hed": {
      "id": "01m4wnb74hed",
      "thing": "symbol",
      "name": "\"cases/6-ts-advanced-types/src/index\"",
      "documentation": "",
      "flags": "ValueModule",
      "type": [
        "type",
        71
      ],
      "exports": [
        [
          "symbol",
          "01m4wlu1vpg7"
        ],
        [
          "symbol",
          "01m4wlpal23s"
        ],
        [
          "symbol",
          "01m4wm4mav1q"
        ],
        [
          "symbol",
          "01m4wnekw3tt"
        ],
        [
          "symbol",
          "01m4wmq6xytp"
        ],
        [
          "symbol",
          "01m4wnwuybyt"
        ],
        [
          "symbol",
          "01m4wmpe0pp6"
        ],
        [
          "symbol",
          "01m4wlldmjxi"
        ],
        [
          "symbol",
          "01m4wn0iynnr"
        ],
        [
          "symbol",
          "01m4wniou5w3"
        ]
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnhowbqe": {
      "id": "01m4wnhowbqe",
      "thing": "symbol",
      "name": "VehicleLike",
      "documentation": "A vehicle-like thing",
      "flags": "Interface",
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wlqu3nkj"
        ]
      ]
    },
    "01m4wlw4k7d8": {
      "id": "01m4wlw4k7d8",
      "thing": "symbol",
      "name": "VehicleFactory",
      "documentation": "A factory for vehicles",
      "flags": "TypeAlias",
      "type": [
        "type",
        4
      ]
    },
    "01m4wnhf4x6o": {
      "id": "01m4wnhf4x6o",
      "thing": "symbol",
      "name": "default",
      "documentation": "A vehicle is a thing that goes places",
      "flags": "Class",
      "type": [
        "type",
        72
      ],
      "members": [
        [
          "symbol",
          "01m4wnrabhh9"
        ],
        [
          "symbol",
          "01m4wn9cth3r"
        ],
        [
          "symbol",
          "01m4wnw088q1"
        ]
      ],
      "exports": [
        [
          "symbol",
          "01m4wnv1obsd"
        ]
      ],
      "constructorSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnabde5r"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlvblxmn"
          ],
          "returnType": [
            "type",
            73
          ],
          "documentation": "Create a new vehicle"
        }
      ],
      "callSignatures": []
    },
    "01m4wndgrix2": {
      "id": "01m4wndgrix2",
      "thing": "symbol",
      "name": "Factory4",
      "documentation": "",
      "flags": "BlockScopedVariable",
      "type": [
        "type",
        79
      ],
      "exports": [],
      "constructorSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn0n6ego"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlriu6r5"
          ],
          "returnType": [
            "type",
            80
          ],
          "documentation": ""
        }
      ],
      "callSignatures": []
    },
    "01m4wmqi5ait": {
      "id": "01m4wmqi5ait",
      "thing": "symbol",
      "name": "Bike",
      "documentation": "A bike is a 2-wheeled vehicle",
      "flags": "Class",
      "type": [
        "type",
        81
      ],
      "members": [
        [
          "symbol",
          "01m4wnrabhh9"
        ]
      ],
      "exports": [
        [
          "symbol",
          "01m4wnv1obsd"
        ]
      ],
      "constructorSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wndtcqy6"
          ],
          "returnType": [
            "type",
            82
          ],
          "documentation": ""
        }
      ],
      "callSignatures": []
    },
    "01m4wly78ocm": {
      "id": "01m4wly78ocm",
      "thing": "symbol",
      "name": "Unicycle",
      "documentation": "A Unicycle is a 1-wheeled vehicle",
      "flags": "Class",
      "type": [
        "type",
        85
      ],
      "members": [
        [
          "symbol",
          "01m4wnrabhh9"
        ]
      ],
      "exports": [
        [
          "symbol",
          "01m4wnv1obsd"
        ]
      ],
      "constructorSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wne2q8pw"
          ],
          "returnType": [
            "type",
            86
          ],
          "documentation": ""
        }
      ],
      "callSignatures": []
    },
    "01m4wnht42ro": {
      "id": "01m4wnht42ro",
      "thing": "symbol",
      "name": "default",
      "documentation": "A car is a 4-wheeled vehicle",
      "flags": "Class",
      "type": [
        "type",
        89
      ],
      "members": [
        [
          "symbol",
          "01m4wnrabhh9"
        ]
      ],
      "exports": [
        [
          "symbol",
          "01m4wnv1obsd"
        ]
      ],
      "constructorSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wn3wrayb"
          ],
          "returnType": [
            "type",
            90
          ],
          "documentation": "Create a new car"
        }
      ],
      "callSignatures": []
    },
    "01m4wlu1vpg7": {
      "id": "01m4wlu1vpg7",
      "thing": "symbol",
      "name": "add",
      "documentation": "Add two numbers together",
      "flags": "Function",
      "type": [
        "type",
        92
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wlv38gfk"
            ],
            [
              "symbol",
              "01m4wluwmsl2"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlorf6g7"
          ],
          "returnType": [
            "type",
            11
          ],
          "documentation": "Add two numbers together"
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wltej43k"
            ],
            [
              "symbol",
              "01m4wlt8xg92"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wna76n7c"
          ],
          "returnType": [
            "type",
            10
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "a first number"
        },
        {
          "name": "param",
          "text": "b second number"
        }
      ]
    },
    "01m4wlpal23s": {
      "id": "01m4wlpal23s",
      "thing": "symbol",
      "name": "SECRET_STRING",
      "documentation": "",
      "flags": "BlockScopedVariable",
      "type": [
        "type",
        94
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wm4mav1q": {
      "id": "01m4wm4mav1q",
      "thing": "symbol",
      "name": "Car",
      "documentation": "",
      "flags": "Alias",
      "type": [
        "type",
        4
      ]
    },
    "01m4wnekw3tt": {
      "id": "01m4wnekw3tt",
      "thing": "symbol",
      "name": "Unicycle",
      "documentation": "",
      "flags": "Alias",
      "type": [
        "type",
        4
      ]
    },
    "01m4wmq6xytp": {
      "id": "01m4wmq6xytp",
      "thing": "symbol",
      "name": "Bike",
      "documentation": "",
      "flags": "Alias",
      "type": [
        "type",
        4
      ]
    },
    "01m4wnwuybyt": {
      "id": "01m4wnwuybyt",
      "thing": "symbol",
      "name": "VehicleLike",
      "documentation": "",
      "flags": "Alias",
      "type": [
        "type",
        4
      ]
    },
    "01m4wmpe0pp6": {
      "id": "01m4wmpe0pp6",
      "thing": "symbol",
      "name": "firstBike",
      "documentation": "The first bike",
      "flags": "BlockScopedVariable",
      "type": [
        "type",
        82
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlldmjxi": {
      "id": "01m4wlldmjxi",
      "thing": "symbol",
      "name": "bikeNow",
      "documentation": "",
      "flags": "BlockScopedVariable",
      "type": [
        "type",
        147
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn0iynnr": {
      "id": "01m4wn0iynnr",
      "thing": "symbol",
      "name": "bikeSoon",
      "documentation": "",
      "flags": "BlockScopedVariable",
      "type": [
        "type",
        147
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wniou5w3": {
      "id": "01m4wniou5w3",
      "thing": "symbol",
      "name": "bikeLater",
      "documentation": "Get a bike later",
      "flags": "BlockScopedVariable",
      "type": [
        "type",
        147
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlqu3nkj": {
      "id": "01m4wlqu3nkj",
      "thing": "symbol",
      "name": "drive",
      "documentation": "Start driving",
      "flags": "Method",
      "type": [
        "type",
        154
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wmalwu21"
          ],
          "returnType": [
            "type",
            21
          ],
          "documentation": "Start driving"
        }
      ]
    },
    "01m4wnrabhh9": {
      "id": "01m4wnrabhh9",
      "thing": "symbol",
      "name": "__constructor",
      "documentation": "Create a new car",
      "flags": "Constructor",
      "type": [
        "type",
        4
      ]
    },
    "01m4wn9cth3r": {
      "id": "01m4wn9cth3r",
      "thing": "symbol",
      "name": "numWheels",
      "documentation": "Number of wheels",
      "flags": "Property",
      "type": [
        "type",
        11
      ],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "numWheels Number of wheels"
        }
      ]
    },
    "01m4wnw088q1": {
      "id": "01m4wnw088q1",
      "thing": "symbol",
      "name": "drive",
      "documentation": "Drive the vehicle",
      "flags": "Method",
      "type": [
        "type",
        155
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wmqi5ass"
          ],
          "returnType": [
            "type",
            10
          ],
          "documentation": "Drive the vehicle"
        }
      ],
      "jsDocTags": [
        {
          "name": "returns"
        }
      ]
    },
    "01m4wnv1obsd": {
      "id": "01m4wnv1obsd",
      "thing": "symbol",
      "name": "prototype",
      "documentation": "",
      "flags": [
        "Property",
        "Prototype"
      ],
      "type": [
        "type",
        4
      ]
    },
    "01m4wnabde5r": {
      "id": "01m4wnabde5r",
      "thing": "symbol",
      "name": "numWheels",
      "documentation": "Number of wheels",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "numWheels Number of wheels"
        }
      ]
    },
    "01m4wn0n6ego": {
      "id": "01m4wn0n6ego",
      "thing": "symbol",
      "name": "numWheels",
      "documentation": "",
      "flags": [
        "FunctionScopedVariable",
        "Transient"
      ],
      "type": [
        "type",
        75
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlv38gfk": {
      "id": "01m4wlv38gfk",
      "thing": "symbol",
      "name": "a",
      "documentation": "first number",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "a first number"
        }
      ]
    },
    "01m4wluwmsl2": {
      "id": "01m4wluwmsl2",
      "thing": "symbol",
      "name": "b",
      "documentation": "second number",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "b second number"
        }
      ]
    },
    "01m4wltej43k": {
      "id": "01m4wltej43k",
      "thing": "symbol",
      "name": "a",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        10
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlt8xg92": {
      "id": "01m4wlt8xg92",
      "thing": "symbol",
      "name": "b",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        10
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wmaexabu": {
      "id": "01m4wmaexabu",
      "thing": "symbol",
      "name": "__type",
      "documentation": "",
      "flags": "TypeLiteral",
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wm9dljc8"
        ]
      ]
    },
    "01m4wnqtxfsw": {
      "id": "01m4wnqtxfsw",
      "thing": "symbol",
      "name": "Promise",
      "documentation": "Represents the completion of an asynchronous operation\nRepresents the completion of an asynchronous operation",
      "flags": [
        "FunctionScopedVariable",
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        103
      ],
      "members": [
        [
          "symbol",
          "01m4wnhowbqm"
        ],
        [
          "symbol",
          "01m4wm3fdh7b"
        ],
        [
          "symbol",
          "01m4wmnibsdr"
        ],
        [
          "symbol",
          "01m4wnawc3gh"
        ],
        [
          "symbol",
          "01m4wmuaw1vg"
        ]
      ],
      "exports": [],
      "constructorSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn6h7psy"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlvv6pv0"
          ],
          "returnType": [
            "type",
            125
          ],
          "documentation": "Creates a new Promise."
        }
      ],
      "callSignatures": []
    },
    "01m4wne9ps6v": {
      "id": "01m4wne9ps6v",
      "thing": "symbol",
      "name": "VehicleUtils",
      "documentation": "A class that helps with vehicle maintenance",
      "flags": [
        "Class",
        "ValueModule"
      ],
      "type": [
        "type",
        96
      ],
      "members": [
        [
          "symbol",
          "01m4wmjfrnfr"
        ]
      ],
      "exports": [
        [
          "symbol",
          "01m4wnv1obsd"
        ],
        [
          "symbol",
          "01m4wn1sovi3"
        ],
        [
          "symbol",
          "01m4wn8xucdo"
        ]
      ],
      "constructorSignatures": [
        {
          "parameters": [],
          "returnType": [
            "type",
            97
          ],
          "documentation": ""
        }
      ],
      "callSignatures": []
    },
    "01m4wmdrbyxe": {
      "id": "01m4wmdrbyxe",
      "thing": "symbol",
      "name": "timeout",
      "documentation": "Create a promise that resolves after a period of time has elapsed",
      "flags": "Function",
      "type": [
        "type",
        101
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnu5x8nb"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm2gtk7p"
          ],
          "returnType": [
            "type",
            126
          ],
          "documentation": "Create a promise that resolves after a period of time has elapsed"
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "n number of milliseconds to wait"
        }
      ]
    },
    "01m4wnvh2d7d": {
      "id": "01m4wnvh2d7d",
      "thing": "symbol",
      "name": "__new",
      "documentation": "",
      "flags": "Signature",
      "type": [
        "type",
        4
      ]
    },
    "01m4wnhowbqm": {
      "id": "01m4wnhowbqm",
      "thing": "symbol",
      "name": "T",
      "documentation": "",
      "flags": [
        "TypeParameter",
        "Transient"
      ],
      "type": [
        "type",
        4
      ]
    },
    "01m4wm3fdh7b": {
      "id": "01m4wm3fdh7b",
      "thing": "symbol",
      "name": "then",
      "documentation": "Attaches callbacks for the resolution and/or rejection of the Promise.",
      "flags": "Method",
      "type": [
        "type",
        127
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn2wtgeg"
            ],
            [
              "symbol",
              "01m4wnkswjqy"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnjf0l7m"
          ],
          "returnType": [
            "type",
            144
          ],
          "documentation": "Attaches callbacks for the resolution and/or rejection of the Promise."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "onfulfilled The callback to execute when the Promise is resolved."
        },
        {
          "name": "param",
          "text": "onrejected The callback to execute when the Promise is rejected."
        },
        {
          "name": "returns",
          "text": "A Promise for the completion of which ever callback is executed."
        }
      ]
    },
    "01m4wmnibsdr": {
      "id": "01m4wmnibsdr",
      "thing": "symbol",
      "name": "catch",
      "documentation": "Attaches a callback for only the rejection of the Promise.",
      "flags": "Method",
      "type": [
        "type",
        159
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnnn5dy6"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmd7r6vt"
          ],
          "returnType": [
            "type",
            162
          ],
          "documentation": "Attaches a callback for only the rejection of the Promise."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "onrejected The callback to execute when the Promise is rejected."
        },
        {
          "name": "returns",
          "text": "A Promise for the completion of the callback."
        }
      ]
    },
    "01m4wnawc3gh": {
      "id": "01m4wnawc3gh",
      "thing": "symbol",
      "name": "__@toStringTag",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        163
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wmuaw1vg": {
      "id": "01m4wmuaw1vg",
      "thing": "symbol",
      "name": "finally",
      "documentation": "Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\nresolved value cannot be modified from the callback.",
      "flags": "Method",
      "type": [
        "type",
        165
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn2agu18"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wluttyqs"
          ],
          "returnType": [
            "type",
            122
          ],
          "documentation": "Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\nresolved value cannot be modified from the callback."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "onfinally The callback to execute when the Promise is settled (fulfilled or rejected)."
        },
        {
          "name": "returns",
          "text": "A Promise for the completion of the callback."
        }
      ]
    },
    "01m4wn6h7psy": {
      "id": "01m4wn6h7psy",
      "thing": "symbol",
      "name": "executor",
      "documentation": "A callback used to initialize the promise. This callback is passed two arguments:\na resolve callback used to resolve the promise with a value or the result of another promise,\nand a reject callback used to reject the promise with a provided reason or error.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        105
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wngqdest"
            ],
            [
              "symbol",
              "01m4wng6smag"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmxdiclu"
          ],
          "returnType": [
            "type",
            21
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "executor A callback used to initialize the promise. This callback is passed two arguments:\na resolve callback used to resolve the promise with a value or the result of another promise,\nand a reject callback used to reject the promise with a provided reason or error."
        }
      ]
    },
    "01m4wmjfrnfr": {
      "id": "01m4wmjfrnfr",
      "thing": "symbol",
      "name": "memberFn",
      "documentation": "Members",
      "flags": "Method",
      "type": [
        "type",
        166
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wm3476eb"
          ],
          "returnType": [
            "type",
            10
          ],
          "documentation": "Members"
        }
      ]
    },
    "01m4wn1sovi3": {
      "id": "01m4wn1sovi3",
      "thing": "symbol",
      "name": "description",
      "documentation": "Static things",
      "flags": "Property",
      "type": [
        "type",
        168
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn8xucdo": {
      "id": "01m4wn8xucdo",
      "thing": "symbol",
      "name": "createBike",
      "documentation": "Create a new bike",
      "flags": "Function",
      "type": [
        "type",
        99
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wm6gkv1x"
          ],
          "returnType": [
            "type",
            82
          ],
          "documentation": "Create a new bike"
        }
      ]
    },
    "01m4wnu5x8nb": {
      "id": "01m4wnu5x8nb",
      "thing": "symbol",
      "name": "n",
      "documentation": "number of milliseconds to wait",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "n number of milliseconds to wait"
        }
      ]
    },
    "01m4wn2wtgeg": {
      "id": "01m4wn2wtgeg",
      "thing": "symbol",
      "name": "onfulfilled",
      "documentation": "The callback to execute when the Promise is resolved.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        133
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn2ln5po"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm2i8h63"
          ],
          "returnType": [
            "type",
            137
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "onfulfilled The callback to execute when the Promise is resolved."
        }
      ]
    },
    "01m4wnkswjqy": {
      "id": "01m4wnkswjqy",
      "thing": "symbol",
      "name": "onrejected",
      "documentation": "The callback to execute when the Promise is rejected.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        170
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn4wp4de"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmalwu66"
          ],
          "returnType": [
            "type",
            172
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "onrejected The callback to execute when the Promise is rejected."
        }
      ]
    },
    "01m4wnnn5dy6": {
      "id": "01m4wnnn5dy6",
      "thing": "symbol",
      "name": "onrejected",
      "documentation": "The callback to execute when the Promise is rejected.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        173
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnb5pk8f"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnnviugy"
          ],
          "returnType": [
            "type",
            175
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "onrejected The callback to execute when the Promise is rejected."
        }
      ]
    },
    "01m4wn2agu18": {
      "id": "01m4wn2agu18",
      "thing": "symbol",
      "name": "onfinally",
      "documentation": "The callback to execute when the Promise is settled (fulfilled or rejected).",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        176
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wn4ej8tc"
          ],
          "returnType": [
            "type",
            21
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "onfinally The callback to execute when the Promise is settled (fulfilled or rejected)."
        }
      ]
    },
    "01m4wngqdest": {
      "id": "01m4wngqdest",
      "thing": "symbol",
      "name": "resolve",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        108
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnj11gkv"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlx4i1ku"
          ],
          "returnType": [
            "type",
            21
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wng6smag": {
      "id": "01m4wng6smag",
      "thing": "symbol",
      "name": "reject",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        121
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnegpcyc"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn638l5i"
          ],
          "returnType": [
            "type",
            21
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wn2ln5po": {
      "id": "01m4wn2ln5po",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        123
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn4wp4de": {
      "id": "01m4wn4wp4de",
      "thing": "symbol",
      "name": "reason",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnb5pk8f": {
      "id": "01m4wnb5pk8f",
      "thing": "symbol",
      "name": "reason",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnj11gkv": {
      "id": "01m4wnj11gkv",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        116
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnegpcyc": {
      "id": "01m4wnegpcyc",
      "thing": "symbol",
      "name": "reason",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wm83vbk7": {
      "id": "01m4wm83vbk7",
      "thing": "symbol",
      "name": "PromiseConstructor",
      "documentation": "",
      "flags": [
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wm2nt4ua"
        ],
        [
          "symbol",
          "01m4wln54q77"
        ],
        [
          "symbol",
          "01m4wnnixn63"
        ],
        [
          "symbol",
          "01m4wnvh2d7d"
        ],
        [
          "symbol",
          "01m4wm2b8wa0"
        ],
        [
          "symbol",
          "01m4wmqrwo63"
        ],
        [
          "symbol",
          "01m4wmfemffe"
        ]
      ]
    },
    "01m4wna9yh22": {
      "id": "01m4wna9yh22",
      "thing": "symbol",
      "name": "T",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wln9bh4o": {
      "id": "01m4wln9bh4o",
      "thing": "symbol",
      "name": "TResult1",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wlnj3uu2": {
      "id": "01m4wlnj3uu2",
      "thing": "symbol",
      "name": "TResult2",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wntikm57": {
      "id": "01m4wntikm57",
      "thing": "symbol",
      "name": "TResult",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wm2nt4ua": {
      "id": "01m4wm2nt4ua",
      "thing": "symbol",
      "name": "all",
      "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.\nCreates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected.",
      "flags": [
        "Method",
        "Transient"
      ],
      "type": [
        "type",
        177
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnhcc45g"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnb04wlk"
          ],
          "returnType": [
            "type",
            235
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wni6oabe"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmugho26"
          ],
          "returnType": [
            "type",
            250
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnhgiu1c"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmxdicne"
          ],
          "returnType": [
            "type",
            264
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnhowbrs"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm41c6cm"
          ],
          "returnType": [
            "type",
            277
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnegpcyi"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnhax6us"
          ],
          "returnType": [
            "type",
            289
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnfw18jt"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmhr3anb"
          ],
          "returnType": [
            "type",
            300
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wngkrqvi"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnw3125t"
          ],
          "returnType": [
            "type",
            310
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wng40scy"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn4sicsq"
          ],
          "returnType": [
            "type",
            318
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wndyxefx"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnctex9d"
          ],
          "returnType": [
            "type",
            326
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnh6qgaw"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlytlb6h"
          ],
          "returnType": [
            "type",
            333
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnfw18js"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmqyw9d6"
          ],
          "returnType": [
            "type",
            335
          ],
          "documentation": "Creates a Promise that is resolved with an array of results when all of the provided Promises\nresolve, or rejected when any Promise is rejected."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        }
      ]
    },
    "01m4wln54q77": {
      "id": "01m4wln54q77",
      "thing": "symbol",
      "name": "race",
      "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.\nCreates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected.",
      "flags": [
        "Method",
        "Transient"
      ],
      "type": [
        "type",
        336
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnf42yce"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn27o14c"
          ],
          "returnType": [
            "type",
            393
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnd9ry5o"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmk7c1ex"
          ],
          "returnType": [
            "type",
            395
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnfm8ttp"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmo4aj04"
          ],
          "returnType": [
            "type",
            397
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnf5gvb6"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnlaoh6m"
          ],
          "returnType": [
            "type",
            399
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnhrp5p1"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlrsmlfh"
          ],
          "returnType": [
            "type",
            401
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnd7058d"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmlh27mc"
          ],
          "returnType": [
            "type",
            403
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wndw5kio"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm542u35"
          ],
          "returnType": [
            "type",
            405
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wngf741n"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn3eleas"
          ],
          "returnType": [
            "type",
            407
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnervnni"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmxuabkn"
          ],
          "returnType": [
            "type",
            409
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnei49x4"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnhgits4"
          ],
          "returnType": [
            "type",
            411
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wm5b2eby"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn2ln5o8"
          ],
          "returnType": [
            "type",
            412
          ],
          "documentation": "Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\nor rejected."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        },
        {
          "name": "param",
          "text": "values An array of Promises."
        },
        {
          "name": "returns",
          "text": "A new Promise."
        }
      ]
    },
    "01m4wnnixn63": {
      "id": "01m4wnnixn63",
      "thing": "symbol",
      "name": "prototype",
      "documentation": "A reference to the prototype.",
      "flags": "Property",
      "type": [
        "type",
        413
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wm2b8wa0": {
      "id": "01m4wm2b8wa0",
      "thing": "symbol",
      "name": "reject",
      "documentation": "Creates a new rejected promise for the provided reason.",
      "flags": "Method",
      "type": [
        "type",
        414
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnacrb18"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlswr5a8"
          ],
          "returnType": [
            "type",
            416
          ],
          "documentation": "Creates a new rejected promise for the provided reason."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "reason The reason the promise was rejected."
        },
        {
          "name": "returns",
          "text": "A new rejected Promise."
        }
      ]
    },
    "01m4wmqrwo63": {
      "id": "01m4wmqrwo63",
      "thing": "symbol",
      "name": "resolve",
      "documentation": "Creates a new resolved promise for the provided value.\nCreates a new resolved promise .",
      "flags": "Method",
      "type": [
        "type",
        417
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn70dle6"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlvtrsc5"
          ],
          "returnType": [
            "type",
            419
          ],
          "documentation": "Creates a new resolved promise for the provided value."
        },
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wnnrc4vi"
          ],
          "returnType": [
            "type",
            126
          ],
          "documentation": "Creates a new resolved promise ."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "value A promise."
        },
        {
          "name": "returns",
          "text": "A promise whose internal state matches the provided promise."
        },
        {
          "name": "returns",
          "text": "A resolved promise."
        }
      ]
    },
    "01m4wmfemffe": {
      "id": "01m4wmfemffe",
      "thing": "symbol",
      "name": "__@species",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        103
      ],
      "constructorSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn6h7psy"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlvv6pv0"
          ],
          "returnType": [
            "type",
            125
          ],
          "documentation": "Creates a new Promise."
        }
      ],
      "callSignatures": []
    },
    "01m4wm9dljc8": {
      "id": "01m4wm9dljc8",
      "thing": "symbol",
      "name": "__call",
      "documentation": "",
      "flags": "Signature",
      "type": [
        "type",
        4
      ]
    },
    "01m4wnhcc45g": {
      "id": "01m4wnhcc45g",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        425
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wni6oabe": {
      "id": "01m4wni6oabe",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        446
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnhgiu1c": {
      "id": "01m4wnhgiu1c",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        470
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnhowbrs": {
      "id": "01m4wnhowbrs",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        492
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnegpcyi": {
      "id": "01m4wnegpcyi",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        512
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnfw18jt": {
      "id": "01m4wnfw18jt",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        530
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wngkrqvi": {
      "id": "01m4wngkrqvi",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        546
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wng40scy": {
      "id": "01m4wng40scy",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        560
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wndyxefx": {
      "id": "01m4wndyxefx",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        572
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnh6qgaw": {
      "id": "01m4wnh6qgaw",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        582
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnfw18js": {
      "id": "01m4wnfw18js",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        590
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnf42yce": {
      "id": "01m4wnf42yce",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        593
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnd9ry5o": {
      "id": "01m4wnd9ry5o",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        614
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnfm8ttp": {
      "id": "01m4wnfm8ttp",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        636
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnf5gvb6": {
      "id": "01m4wnf5gvb6",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        656
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnhrp5p1": {
      "id": "01m4wnhrp5p1",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        674
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnd7058d": {
      "id": "01m4wnd7058d",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        690
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wndw5kio": {
      "id": "01m4wndw5kio",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        704
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wngf741n": {
      "id": "01m4wngf741n",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        716
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnervnni": {
      "id": "01m4wnervnni",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        726
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnei49x4": {
      "id": "01m4wnei49x4",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        734
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wm5b2eby": {
      "id": "01m4wm5b2eby",
      "thing": "symbol",
      "name": "values",
      "documentation": "An array of Promises.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        740
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "values An array of Promises."
        }
      ]
    },
    "01m4wnacrb18": {
      "id": "01m4wnacrb18",
      "thing": "symbol",
      "name": "reason",
      "documentation": "The reason the promise was rejected.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "reason The reason the promise was rejected."
        }
      ]
    },
    "01m4wn70dle6": {
      "id": "01m4wn70dle6",
      "thing": "symbol",
      "name": "value",
      "documentation": "A promise.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        742
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "value A promise."
        }
      ]
    },
    "01m4wm7ax2e8": {
      "id": "01m4wm7ax2e8",
      "thing": "symbol",
      "name": "TAll",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wm8ng432": {
      "id": "01m4wm8ng432",
      "thing": "symbol",
      "name": "T1",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wm8x8hsf": {
      "id": "01m4wm8x8hsf",
      "thing": "symbol",
      "name": "T2",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wm980vis": {
      "id": "01m4wm980vis",
      "thing": "symbol",
      "name": "T3",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wm9hsa96": {
      "id": "01m4wm9hsa96",
      "thing": "symbol",
      "name": "T4",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wm9rknyj": {
      "id": "01m4wm9rknyj",
      "thing": "symbol",
      "name": "T5",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wma2d2ow": {
      "id": "01m4wma2d2ow",
      "thing": "symbol",
      "name": "T6",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wmac5gfa": {
      "id": "01m4wmac5gfa",
      "thing": "symbol",
      "name": "T7",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wmalwu5n": {
      "id": "01m4wmalwu5n",
      "thing": "symbol",
      "name": "T8",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wmavp8v1": {
      "id": "01m4wmavp8v1",
      "thing": "symbol",
      "name": "T9",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wneqhqnh": {
      "id": "01m4wneqhqnh",
      "thing": "symbol",
      "name": "T10",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wn1hikok": {
      "id": "01m4wn1hikok",
      "thing": "symbol",
      "name": "Iterable",
      "documentation": "",
      "flags": [
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wnhowbqm"
        ],
        [
          "symbol",
          "01m4wmkcwngf"
        ]
      ]
    },
    "01m4wm0bd96q": {
      "id": "01m4wm0bd96q",
      "thing": "symbol",
      "name": "Array",
      "documentation": "",
      "flags": [
        "BlockScopedVariable",
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        743
      ],
      "members": [
        [
          "symbol",
          "01m4wnhowbqm"
        ],
        [
          "symbol",
          "01m4wnuv3nty"
        ],
        [
          "symbol",
          "01m4wmeu2mxo"
        ],
        [
          "symbol",
          "01m4wmwhr9lt"
        ],
        [
          "symbol",
          "01m4wmih8qbg"
        ],
        [
          "symbol",
          "01m4wm4cihad"
        ],
        [
          "symbol",
          "01m4wmls8j4u"
        ],
        [
          "symbol",
          "01m4wmj8s3mw"
        ],
        [
          "symbol",
          "01m4wnb04wal"
        ],
        [
          "symbol",
          "01m4wn1vhp8c"
        ],
        [
          "symbol",
          "01m4wmoxmny5"
        ],
        [
          "symbol",
          "01m4wm56ungj"
        ],
        [
          "symbol",
          "01m4wm01kuij"
        ],
        [
          "symbol",
          "01m4wnc5ne5u"
        ],
        [
          "symbol",
          "01m4wn6d0yty"
        ],
        [
          "symbol",
          "01m4wmvatuqe"
        ],
        [
          "symbol",
          "01m4wlytlamw"
        ],
        [
          "symbol",
          "01m4wlxjv2ym"
        ],
        [
          "symbol",
          "01m4wn8s9ogm"
        ],
        [
          "symbol",
          "01m4wmme78gw"
        ],
        [
          "symbol",
          "01m4wmn8jepo"
        ],
        [
          "symbol",
          "01m4wm6qd9wy"
        ],
        [
          "symbol",
          "01m4wmbhnx71"
        ],
        [
          "symbol",
          "01m4wnucwsb6"
        ],
        [
          "symbol",
          "01m4wnbxntfk"
        ],
        [
          "symbol",
          "01m4wm5jfv0y"
        ],
        [
          "symbol",
          "01m4wmer9t1s"
        ],
        [
          "symbol",
          "01m4wmtoxccq"
        ],
        [
          "symbol",
          "01m4wmma0hkg"
        ],
        [
          "symbol",
          "01m4wmi4ninj"
        ],
        [
          "symbol",
          "01m4wm6b08cx"
        ],
        [
          "symbol",
          "01m4wm9dljbw"
        ],
        [
          "symbol",
          "01m4wnvtmkv1"
        ],
        [
          "symbol",
          "01m4wn98mq4g"
        ],
        [
          "symbol",
          "01m4wllkm4n4"
        ],
        [
          "symbol",
          "01m4wmsm7ofa"
        ]
      ],
      "exports": [],
      "constructorSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wmid20lk"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlv4mdet"
          ],
          "returnType": [
            "type",
            58
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wmj609t0"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnmg7yxw"
          ],
          "returnType": [
            "type",
            748
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnnby3cw"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnqpqosj"
          ],
          "returnType": [
            "type",
            749
          ],
          "documentation": ""
        }
      ],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wmj0elyg"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wne6wy94"
          ],
          "returnType": [
            "type",
            58
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wmi1uowm"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmfy77qk"
          ],
          "returnType": [
            "type",
            750
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnn6dfie"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn88ow19"
          ],
          "returnType": [
            "type",
            751
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wmkcwngf": {
      "id": "01m4wmkcwngf",
      "thing": "symbol",
      "name": "__@iterator",
      "documentation": "",
      "flags": "Method",
      "type": [
        "type",
        752
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wm1uuusy"
          ],
          "returnType": [
            "type",
            756
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wnuv3nty": {
      "id": "01m4wnuv3nty",
      "thing": "symbol",
      "name": "length",
      "documentation": "Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.",
      "flags": "Property",
      "type": [
        "type",
        11
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wmeu2mxo": {
      "id": "01m4wmeu2mxo",
      "thing": "symbol",
      "name": "toString",
      "documentation": "Returns a string representation of an array.",
      "flags": "Method",
      "type": [
        "type",
        757
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wntv5u4t"
          ],
          "returnType": [
            "type",
            10
          ],
          "documentation": "Returns a string representation of an array."
        }
      ]
    },
    "01m4wmwhr9lt": {
      "id": "01m4wmwhr9lt",
      "thing": "symbol",
      "name": "toLocaleString",
      "documentation": "Returns a string representation of an array. The elements are converted to string using their toLocalString methods.",
      "flags": "Method",
      "type": [
        "type",
        758
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wlq0qhwc"
          ],
          "returnType": [
            "type",
            10
          ],
          "documentation": "Returns a string representation of an array. The elements are converted to string using their toLocalString methods."
        }
      ]
    },
    "01m4wmih8qbg": {
      "id": "01m4wmih8qbg",
      "thing": "symbol",
      "name": "pop",
      "documentation": "Removes the last element from an array and returns it.",
      "flags": "Method",
      "type": [
        "type",
        759
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wmme78d1"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": "Removes the last element from an array and returns it."
        }
      ]
    },
    "01m4wm4cihad": {
      "id": "01m4wm4cihad",
      "thing": "symbol",
      "name": "push",
      "documentation": "Appends new elements to an array, and returns the new length of the array.",
      "flags": "Method",
      "type": [
        "type",
        760
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnm98feu"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnw5suxt"
          ],
          "returnType": [
            "type",
            11
          ],
          "documentation": "Appends new elements to an array, and returns the new length of the array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items New elements of the Array."
        }
      ]
    },
    "01m4wmls8j4u": {
      "id": "01m4wmls8j4u",
      "thing": "symbol",
      "name": "concat",
      "documentation": "Combines two or more arrays.\nCombines two or more arrays.",
      "flags": "Method",
      "type": [
        "type",
        761
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnq3e3mq"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnwwd8r1"
          ],
          "returnType": [
            "type",
            48
          ],
          "documentation": "Combines two or more arrays."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnmn7k0w"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnd7050f"
          ],
          "returnType": [
            "type",
            48
          ],
          "documentation": "Combines two or more arrays."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items Additional items to add to the end of array1."
        },
        {
          "name": "param",
          "text": "items Additional items to add to the end of array1."
        }
      ]
    },
    "01m4wmj8s3mw": {
      "id": "01m4wmj8s3mw",
      "thing": "symbol",
      "name": "join",
      "documentation": "Adds all the elements of an array separated by the specified separator string.",
      "flags": "Method",
      "type": [
        "type",
        762
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wlxwgap9"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmkv3iyx"
          ],
          "returnType": [
            "type",
            10
          ],
          "documentation": "Adds all the elements of an array separated by the specified separator string."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma."
        }
      ]
    },
    "01m4wnb04wal": {
      "id": "01m4wnb04wal",
      "thing": "symbol",
      "name": "reverse",
      "documentation": "Reverses the elements in an Array.",
      "flags": "Method",
      "type": [
        "type",
        763
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wmtm5iif"
          ],
          "returnType": [
            "type",
            48
          ],
          "documentation": "Reverses the elements in an Array."
        }
      ]
    },
    "01m4wn1vhp8c": {
      "id": "01m4wn1vhp8c",
      "thing": "symbol",
      "name": "shift",
      "documentation": "Removes the first element from an array and returns it.",
      "flags": "Method",
      "type": [
        "type",
        764
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wlnvo2te"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": "Removes the first element from an array and returns it."
        }
      ]
    },
    "01m4wmoxmny5": {
      "id": "01m4wmoxmny5",
      "thing": "symbol",
      "name": "slice",
      "documentation": "Returns a section of an array.",
      "flags": "Method",
      "type": [
        "type",
        765
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnj6m4fi"
            ],
            [
              "symbol",
              "01m4wnsv80vx"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn1954kn"
          ],
          "returnType": [
            "type",
            48
          ],
          "documentation": "Returns a section of an array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "start The beginning of the specified portion of the array."
        },
        {
          "name": "param",
          "text": "end The end of the specified portion of the array."
        }
      ]
    },
    "01m4wm56ungj": {
      "id": "01m4wm56ungj",
      "thing": "symbol",
      "name": "sort",
      "documentation": "Sorts an array.",
      "flags": "Method",
      "type": [
        "type",
        766
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn7cxt23"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn1sovgj"
          ],
          "returnType": [
            "type",
            50
          ],
          "documentation": "Sorts an array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order."
        }
      ]
    },
    "01m4wm01kuij": {
      "id": "01m4wm01kuij",
      "thing": "symbol",
      "name": "splice",
      "documentation": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\nRemoves elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
      "flags": "Method",
      "type": [
        "type",
        767
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wng87jc9"
            ],
            [
              "symbol",
              "01m4wn4hc2ul"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn54onx7"
          ],
          "returnType": [
            "type",
            48
          ],
          "documentation": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wni9h4ca"
            ],
            [
              "symbol",
              "01m4wn4bqf11"
            ],
            [
              "symbol",
              "01m4wnk9crdh"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmn9xbky"
          ],
          "returnType": [
            "type",
            48
          ],
          "documentation": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "start The zero-based location in the array from which to start removing elements."
        },
        {
          "name": "param",
          "text": "deleteCount The number of elements to remove."
        },
        {
          "name": "param",
          "text": "start The zero-based location in the array from which to start removing elements."
        },
        {
          "name": "param",
          "text": "deleteCount The number of elements to remove."
        },
        {
          "name": "param",
          "text": "items Elements to insert into the array in place of the deleted elements."
        }
      ]
    },
    "01m4wnc5ne5u": {
      "id": "01m4wnc5ne5u",
      "thing": "symbol",
      "name": "unshift",
      "documentation": "Inserts new elements at the start of an array.",
      "flags": "Method",
      "type": [
        "type",
        768
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnk7xuf1"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlnlvpab"
          ],
          "returnType": [
            "type",
            11
          ],
          "documentation": "Inserts new elements at the start of an array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items Elements to insert at the start of the Array."
        }
      ]
    },
    "01m4wn6d0yty": {
      "id": "01m4wn6d0yty",
      "thing": "symbol",
      "name": "indexOf",
      "documentation": "Returns the index of the first occurrence of a value in an array.",
      "flags": "Method",
      "type": [
        "type",
        769
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wlokflsm"
            ],
            [
              "symbol",
              "01m4wnvbgpi4"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm5rtckw"
          ],
          "returnType": [
            "type",
            11
          ],
          "documentation": "Returns the index of the first occurrence of a value in an array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "searchElement The value to locate in the array."
        },
        {
          "name": "param",
          "text": "fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0."
        }
      ]
    },
    "01m4wmvatuqe": {
      "id": "01m4wmvatuqe",
      "thing": "symbol",
      "name": "lastIndexOf",
      "documentation": "Returns the index of the last occurrence of a specified value in an array.",
      "flags": "Method",
      "type": [
        "type",
        770
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wlo7ue66"
            ],
            [
              "symbol",
              "01m4wnsa9bhu"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnt8s8i3"
          ],
          "returnType": [
            "type",
            11
          ],
          "documentation": "Returns the index of the last occurrence of a specified value in an array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "searchElement The value to locate in the array."
        },
        {
          "name": "param",
          "text": "fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array."
        }
      ]
    },
    "01m4wlytlamw": {
      "id": "01m4wlytlamw",
      "thing": "symbol",
      "name": "every",
      "documentation": "Determines whether all the members of an array satisfy the specified test.",
      "flags": "Method",
      "type": [
        "type",
        771
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wna2ywbf"
            ],
            [
              "symbol",
              "01m4wlq3jbbh"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm4dwd82"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": "Determines whether all the members of an array satisfy the specified test."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array."
        },
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wlxjv2ym": {
      "id": "01m4wlxjv2ym",
      "thing": "symbol",
      "name": "some",
      "documentation": "Determines whether the specified callback function returns true for any element of an array.",
      "flags": "Method",
      "type": [
        "type",
        772
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wndyxeg3"
            ],
            [
              "symbol",
              "01m4wltwoyji"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm4tafsm"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": "Determines whether the specified callback function returns true for any element of an array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array."
        },
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wn8s9ogm": {
      "id": "01m4wn8s9ogm",
      "thing": "symbol",
      "name": "forEach",
      "documentation": "Performs the specified action for each element in an array.",
      "flags": "Method",
      "type": [
        "type",
        773
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnapcio1"
            ],
            [
              "symbol",
              "01m4wlru1hkw"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmcc145k"
          ],
          "returnType": [
            "type",
            21
          ],
          "documentation": "Performs the specified action for each element in an array."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wmme78gw": {
      "id": "01m4wmme78gw",
      "thing": "symbol",
      "name": "map",
      "documentation": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
      "flags": "Method",
      "type": [
        "type",
        774
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnd9ry63"
            ],
            [
              "symbol",
              "01m4wls0m5fh"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm2s0ug3"
          ],
          "returnType": [
            "type",
            776
          ],
          "documentation": "Calls a defined callback function on each element of an array, and returns an array that contains the results."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wmn8jepo": {
      "id": "01m4wmn8jepo",
      "thing": "symbol",
      "name": "filter",
      "documentation": "Returns the elements of an array that meet the condition specified in a callback function.\nReturns the elements of an array that meet the condition specified in a callback function.",
      "flags": "Method",
      "type": [
        "type",
        777
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnbl3lss"
            ],
            [
              "symbol",
              "01m4wlragp58"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmaubbpx"
          ],
          "returnType": [
            "type",
            779
          ],
          "documentation": "Returns the elements of an array that meet the condition specified in a callback function."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wneqhqp4"
            ],
            [
              "symbol",
              "01m4wlt0jyg1"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlr7nuuj"
          ],
          "returnType": [
            "type",
            48
          ],
          "documentation": "Returns the elements of an array that meet the condition specified in a callback function."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        },
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wm6qd9wy": {
      "id": "01m4wm6qd9wy",
      "thing": "symbol",
      "name": "reduce",
      "documentation": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\nCalls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
      "flags": "Method",
      "type": [
        "type",
        780
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnbnvfqc"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnndd0ac"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnbiarvf"
            ],
            [
              "symbol",
              "01m4wlpg6out"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wne1cbav"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wncl1fth"
            ],
            [
              "symbol",
              "01m4wln0x09k"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm9f0g9j"
          ],
          "returnType": [
            "type",
            781
          ],
          "documentation": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
        },
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
        }
      ]
    },
    "01m4wmbhnx71": {
      "id": "01m4wmbhnx71",
      "thing": "symbol",
      "name": "reduceRight",
      "documentation": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\nCalls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
      "flags": "Method",
      "type": [
        "type",
        782
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnf42ycv"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmo4ah7v"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnctewl9"
            ],
            [
              "symbol",
              "01m4wln9bh1c"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm813hhm"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnenowrt"
            ],
            [
              "symbol",
              "01m4wlp27k9l"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlur24yf"
          ],
          "returnType": [
            "type",
            783
          ],
          "documentation": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
        },
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
        }
      ]
    },
    "01m4wnucwsb6": {
      "id": "01m4wnucwsb6",
      "thing": "symbol",
      "name": "__index",
      "documentation": "",
      "flags": "Signature",
      "type": [
        "type",
        4
      ]
    },
    "01m4wnbxntfk": {
      "id": "01m4wnbxntfk",
      "thing": "symbol",
      "name": "find",
      "documentation": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
      "flags": "Method",
      "type": [
        "type",
        784
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wno6b9il"
            ],
            [
              "symbol",
              "01m4wlye895n"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wlw4k75i"
          ],
          "returnType": [
            "type",
            785
          ],
          "documentation": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnowulrf"
            ],
            [
              "symbol",
              "01m4wlye895n"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnjgehwi"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "predicate find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
        },
        {
          "name": "param",
          "text": "thisArg If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
        }
      ]
    },
    "01m4wm5jfv0y": {
      "id": "01m4wm5jfv0y",
      "thing": "symbol",
      "name": "findIndex",
      "documentation": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
      "flags": "Method",
      "type": [
        "type",
        786
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnnviuse"
            ],
            [
              "symbol",
              "01m4wm0mjjwt"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlndi7wb"
          ],
          "returnType": [
            "type",
            11
          ],
          "documentation": "Returns the index of the first element in the array where predicate is true, and -1\notherwise."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "predicate find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
        },
        {
          "name": "param",
          "text": "thisArg If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
        }
      ]
    },
    "01m4wmer9t1s": {
      "id": "01m4wmer9t1s",
      "thing": "symbol",
      "name": "fill",
      "documentation": "Returns the this object after filling the section identified by start and end with value",
      "flags": "Method",
      "type": [
        "type",
        787
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnic9x9b"
            ],
            [
              "symbol",
              "01m4wnsmtj59"
            ],
            [
              "symbol",
              "01m4wlp7s872"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm5qffwb"
          ],
          "returnType": [
            "type",
            50
          ],
          "documentation": "Returns the this object after filling the section identified by start and end with value"
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "value value to fill array section with"
        },
        {
          "name": "param",
          "text": "start index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
        },
        {
          "name": "param",
          "text": "end index to stop filling the array at. If end is negative, it is treated as\nlength+end."
        }
      ]
    },
    "01m4wmtoxccq": {
      "id": "01m4wmtoxccq",
      "thing": "symbol",
      "name": "copyWithin",
      "documentation": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
      "flags": "Method",
      "type": [
        "type",
        788
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnq8yqdy"
            ],
            [
              "symbol",
              "01m4wnrmvp4i"
            ],
            [
              "symbol",
              "01m4wlo29qbi"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlvwkmtk"
          ],
          "returnType": [
            "type",
            50
          ],
          "documentation": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target"
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "target If target is negative, it is treated as length+target where length is the\nlength of the array."
        },
        {
          "name": "param",
          "text": "start If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
        },
        {
          "name": "param",
          "text": "end If not specified, length of the this object is used as its default value."
        }
      ]
    },
    "01m4wmma0hkg": {
      "id": "01m4wmma0hkg",
      "thing": "symbol",
      "name": "__@iterator",
      "documentation": "Iterator",
      "flags": "Method",
      "type": [
        "type",
        789
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wmmfl5n3"
          ],
          "returnType": [
            "type",
            793
          ],
          "documentation": "Iterator"
        }
      ]
    },
    "01m4wmi4ninj": {
      "id": "01m4wmi4ninj",
      "thing": "symbol",
      "name": "entries",
      "documentation": "Returns an iterable of key, value pairs for every entry in the array",
      "flags": "Method",
      "type": [
        "type",
        794
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wnrmvp4v"
          ],
          "returnType": [
            "type",
            796
          ],
          "documentation": "Returns an iterable of key, value pairs for every entry in the array"
        }
      ]
    },
    "01m4wm6b08cx": {
      "id": "01m4wm6b08cx",
      "thing": "symbol",
      "name": "keys",
      "documentation": "Returns an iterable of keys in the array",
      "flags": "Method",
      "type": [
        "type",
        797
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wlqg4j19"
          ],
          "returnType": [
            "type",
            798
          ],
          "documentation": "Returns an iterable of keys in the array"
        }
      ]
    },
    "01m4wm9dljbw": {
      "id": "01m4wm9dljbw",
      "thing": "symbol",
      "name": "values",
      "documentation": "Returns an iterable of values in the array",
      "flags": "Method",
      "type": [
        "type",
        799
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wmkbiqj1"
          ],
          "returnType": [
            "type",
            793
          ],
          "documentation": "Returns an iterable of values in the array"
        }
      ]
    },
    "01m4wnvtmkv1": {
      "id": "01m4wnvtmkv1",
      "thing": "symbol",
      "name": "__@unscopables",
      "documentation": "Returns an object whose properties have the value 'true'\nwhen they will be absent when used in a 'with' statement.",
      "flags": "Method",
      "type": [
        "type",
        800
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wm980vtr"
          ],
          "returnType": [
            "type",
            801
          ],
          "documentation": "Returns an object whose properties have the value 'true'\nwhen they will be absent when used in a 'with' statement."
        }
      ]
    },
    "01m4wn98mq4g": {
      "id": "01m4wn98mq4g",
      "thing": "symbol",
      "name": "includes",
      "documentation": "Determines whether an array includes a certain element, returning true or false as appropriate.",
      "flags": "Method",
      "type": [
        "type",
        802
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wly1n1hm"
            ],
            [
              "symbol",
              "01m4wlrr8nnw"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wns8ueh2"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": "Determines whether an array includes a certain element, returning true or false as appropriate."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "searchElement The element to search for."
        },
        {
          "name": "param",
          "text": "fromIndex The position in this array at which to begin searching for searchElement."
        }
      ]
    },
    "01m4wllkm4n4": {
      "id": "01m4wllkm4n4",
      "thing": "symbol",
      "name": "flatMap",
      "documentation": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
      "flags": "Method",
      "type": [
        "type",
        803
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnemb0sw"
            ],
            [
              "symbol",
              "01m4wlxmnvvn"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmq4664d"
          ],
          "returnType": [
            "type",
            806
          ],
          "documentation": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callback A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
        },
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wmsm7ofa": {
      "id": "01m4wmsm7ofa",
      "thing": "symbol",
      "name": "flat",
      "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.\nReturns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth. If no depth is provided, flat method defaults to the depth of 1.",
      "flags": "Method",
      "type": [
        "type",
        807
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnqy56s1"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wns8udyh"
          ],
          "returnType": [
            "type",
            817
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wns1utpo"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmi1uoc1"
          ],
          "returnType": [
            "type",
            818
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnq206o9"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnjrksae"
          ],
          "returnType": [
            "type",
            819
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wns1utpo"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm9vreby"
          ],
          "returnType": [
            "type",
            820
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnrfw5b9"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnbxnsyd"
          ],
          "returnType": [
            "type",
            821
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnsmtj54"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm2e1poy"
          ],
          "returnType": [
            "type",
            822
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnr8wki5"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmpme7pj"
          ],
          "returnType": [
            "type",
            823
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnpn122y"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wluinng1"
          ],
          "returnType": [
            "type",
            824
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnq206oe"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn3skjoe"
          ],
          "returnType": [
            "type",
            58
          ],
          "documentation": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth. If no depth is provided, flat method defaults to the depth of 1."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        },
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wmid20lk": {
      "id": "01m4wmid20lk",
      "thing": "symbol",
      "name": "arrayLength",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wmj609t0": {
      "id": "01m4wmj609t0",
      "thing": "symbol",
      "name": "arrayLength",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnnby3cw": {
      "id": "01m4wnnby3cw",
      "thing": "symbol",
      "name": "items",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        749
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wmj0elyg": {
      "id": "01m4wmj0elyg",
      "thing": "symbol",
      "name": "arrayLength",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wmi1uowm": {
      "id": "01m4wmi1uowm",
      "thing": "symbol",
      "name": "arrayLength",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnn6dfie": {
      "id": "01m4wnn6dfie",
      "thing": "symbol",
      "name": "items",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        751
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnm98feu": {
      "id": "01m4wnm98feu",
      "thing": "symbol",
      "name": "items",
      "documentation": "New elements of the Array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items New elements of the Array."
        }
      ]
    },
    "01m4wnq3e3mq": {
      "id": "01m4wnq3e3mq",
      "thing": "symbol",
      "name": "items",
      "documentation": "Additional items to add to the end of array1.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        829
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items Additional items to add to the end of array1."
        }
      ]
    },
    "01m4wnmn7k0w": {
      "id": "01m4wnmn7k0w",
      "thing": "symbol",
      "name": "items",
      "documentation": "Additional items to add to the end of array1.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        831
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items Additional items to add to the end of array1."
        }
      ]
    },
    "01m4wlxwgap9": {
      "id": "01m4wlxwgap9",
      "thing": "symbol",
      "name": "separator",
      "documentation": "A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        10
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma."
        }
      ]
    },
    "01m4wnj6m4fi": {
      "id": "01m4wnj6m4fi",
      "thing": "symbol",
      "name": "start",
      "documentation": "The beginning of the specified portion of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "start The beginning of the specified portion of the array."
        }
      ]
    },
    "01m4wnsv80vx": {
      "id": "01m4wnsv80vx",
      "thing": "symbol",
      "name": "end",
      "documentation": "The end of the specified portion of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "end The end of the specified portion of the array."
        }
      ]
    },
    "01m4wn7cxt23": {
      "id": "01m4wn7cxt23",
      "thing": "symbol",
      "name": "compareFn",
      "documentation": "The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        832
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnp22co3"
            ],
            [
              "symbol",
              "01m4wnpy7crk"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmitsy1r"
          ],
          "returnType": [
            "type",
            11
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order."
        }
      ]
    },
    "01m4wng87jc9": {
      "id": "01m4wng87jc9",
      "thing": "symbol",
      "name": "start",
      "documentation": "The zero-based location in the array from which to start removing elements.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "start The zero-based location in the array from which to start removing elements."
        }
      ]
    },
    "01m4wn4hc2ul": {
      "id": "01m4wn4hc2ul",
      "thing": "symbol",
      "name": "deleteCount",
      "documentation": "The number of elements to remove.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "deleteCount The number of elements to remove."
        }
      ]
    },
    "01m4wni9h4ca": {
      "id": "01m4wni9h4ca",
      "thing": "symbol",
      "name": "start",
      "documentation": "The zero-based location in the array from which to start removing elements.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "start The zero-based location in the array from which to start removing elements."
        }
      ]
    },
    "01m4wn4bqf11": {
      "id": "01m4wn4bqf11",
      "thing": "symbol",
      "name": "deleteCount",
      "documentation": "The number of elements to remove.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "deleteCount The number of elements to remove."
        }
      ]
    },
    "01m4wnk9crdh": {
      "id": "01m4wnk9crdh",
      "thing": "symbol",
      "name": "items",
      "documentation": "Elements to insert into the array in place of the deleted elements.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items Elements to insert into the array in place of the deleted elements."
        }
      ]
    },
    "01m4wnk7xuf1": {
      "id": "01m4wnk7xuf1",
      "thing": "symbol",
      "name": "items",
      "documentation": "Elements to insert at the start of the Array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items Elements to insert at the start of the Array."
        }
      ]
    },
    "01m4wlokflsm": {
      "id": "01m4wlokflsm",
      "thing": "symbol",
      "name": "searchElement",
      "documentation": "The value to locate in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "searchElement The value to locate in the array."
        }
      ]
    },
    "01m4wnvbgpi4": {
      "id": "01m4wnvbgpi4",
      "thing": "symbol",
      "name": "fromIndex",
      "documentation": "The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0."
        }
      ]
    },
    "01m4wlo7ue66": {
      "id": "01m4wlo7ue66",
      "thing": "symbol",
      "name": "searchElement",
      "documentation": "The value to locate in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "searchElement The value to locate in the array."
        }
      ]
    },
    "01m4wnsa9bhu": {
      "id": "01m4wnsa9bhu",
      "thing": "symbol",
      "name": "fromIndex",
      "documentation": "The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array."
        }
      ]
    },
    "01m4wna2ywbf": {
      "id": "01m4wna2ywbf",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        833
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn70dle5"
            ],
            [
              "symbol",
              "01m4wnamjotf"
            ],
            [
              "symbol",
              "01m4wn6bm32v"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm6jdp7k"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array."
        }
      ]
    },
    "01m4wlq3jbbh": {
      "id": "01m4wlq3jbbh",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wndyxeg3": {
      "id": "01m4wndyxeg3",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        834
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn7pj1og"
            ],
            [
              "symbol",
              "01m4wnbcp54q"
            ],
            [
              "symbol",
              "01m4wn736fbi"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm6jdp7k"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array."
        }
      ]
    },
    "01m4wltwoyji": {
      "id": "01m4wltwoyji",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wnapcio1": {
      "id": "01m4wnapcio1",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        835
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn4fx5wh"
            ],
            [
              "symbol",
              "01m4wn84i6b3"
            ],
            [
              "symbol",
              "01m4wn6h7pwc"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn6legmo"
          ],
          "returnType": [
            "type",
            21
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wlru1hkw": {
      "id": "01m4wlru1hkw",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wnd9ry63": {
      "id": "01m4wnd9ry63",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        836
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wna76n8y"
            ],
            [
              "symbol",
              "01m4wndcks61"
            ],
            [
              "symbol",
              "01m4wn5wmxgr"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmr5hvyd"
          ],
          "returnType": [
            "type",
            775
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wls0m5fh": {
      "id": "01m4wls0m5fh",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wnbl3lss": {
      "id": "01m4wnbl3lss",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        837
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn5bo923"
            ],
            [
              "symbol",
              "01m4wn8xuchd"
            ],
            [
              "symbol",
              "01m4wn4mwppt"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlsy62dk"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wlragp58": {
      "id": "01m4wlragp58",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wneqhqp4": {
      "id": "01m4wneqhqp4",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        838
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wn8ihavw"
            ],
            [
              "symbol",
              "01m4wnc5nec7"
            ],
            [
              "symbol",
              "01m4wn7tprkn"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmkcwnn6"
          ],
          "returnType": [
            "type",
            1
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wlt0jyg1": {
      "id": "01m4wlt0jyg1",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wnbnvfqc": {
      "id": "01m4wnbnvfqc",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        839
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnwl6x8o"
            ],
            [
              "symbol",
              "01m4wnohhk58"
            ],
            [
              "symbol",
              "01m4wnpslou6"
            ],
            [
              "symbol",
              "01m4wn4ppjmy"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmwyj874"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wnbiarvf": {
      "id": "01m4wnbiarvf",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        840
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnvh2dcb"
            ],
            [
              "symbol",
              "01m4wnneqw76"
            ],
            [
              "symbol",
              "01m4wnsa9beq"
            ],
            [
              "symbol",
              "01m4wn8349cd"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmwyj874"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wlpg6out": {
      "id": "01m4wlpg6out",
      "thing": "symbol",
      "name": "initialValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wncl1fth": {
      "id": "01m4wncl1fth",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        841
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnwjs1ad"
            ],
            [
              "symbol",
              "01m4wnlsudrf"
            ],
            [
              "symbol",
              "01m4wnq8yqf3"
            ],
            [
              "symbol",
              "01m4wn5lgmrs"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn0979xx"
          ],
          "returnType": [
            "type",
            781
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wln0x09k": {
      "id": "01m4wln0x09k",
      "thing": "symbol",
      "name": "initialValue",
      "documentation": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        781
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
        }
      ]
    },
    "01m4wnf42ycv": {
      "id": "01m4wnf42ycv",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        842
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wlo99b3w"
            ],
            [
              "symbol",
              "01m4wnrfw58j"
            ],
            [
              "symbol",
              "01m4wnq3e3ko"
            ],
            [
              "symbol",
              "01m4wn85w39i"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmwyj874"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wnctewl9": {
      "id": "01m4wnctewl9",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        843
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wloltiqr"
            ],
            [
              "symbol",
              "01m4wnp693gw"
            ],
            [
              "symbol",
              "01m4wnqhd86u"
            ],
            [
              "symbol",
              "01m4wn5tu4jk"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmwyj874"
          ],
          "returnType": [
            "type",
            49
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wln9bh1c": {
      "id": "01m4wln9bh1c",
      "thing": "symbol",
      "name": "initialValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnenowrt": {
      "id": "01m4wnenowrt",
      "thing": "symbol",
      "name": "callbackfn",
      "documentation": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        844
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wlnrhckj"
            ],
            [
              "symbol",
              "01m4wnrhb26p"
            ],
            [
              "symbol",
              "01m4wnvfngb5"
            ],
            [
              "symbol",
              "01m4wn7o54q5"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn0979xx"
          ],
          "returnType": [
            "type",
            783
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
        }
      ]
    },
    "01m4wlp27k9l": {
      "id": "01m4wlp27k9l",
      "thing": "symbol",
      "name": "initialValue",
      "documentation": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        783
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
        }
      ]
    },
    "01m4wno6b9il": {
      "id": "01m4wno6b9il",
      "thing": "symbol",
      "name": "predicate",
      "documentation": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        845
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wngnkkw9"
            ],
            [
              "symbol",
              "01m4wnmamcdq"
            ],
            [
              "symbol",
              "01m4wnnak6eg"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn0iynjd"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "predicate find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
        }
      ]
    },
    "01m4wlye895n": {
      "id": "01m4wlye895n",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnowulrf": {
      "id": "01m4wnowulrf",
      "thing": "symbol",
      "name": "predicate",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        846
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnhgiu4s"
            ],
            [
              "symbol",
              "01m4wnmvl1s6"
            ],
            [
              "symbol",
              "01m4wnln9q10"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmaexael"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wnnviuse": {
      "id": "01m4wnnviuse",
      "thing": "symbol",
      "name": "predicate",
      "documentation": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        847
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wngxcymb"
            ],
            [
              "symbol",
              "01m4wnjorywv"
            ],
            [
              "symbol",
              "01m4wnkopsxl"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmaexael"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "predicate find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
        }
      ]
    },
    "01m4wm0mjjwt": {
      "id": "01m4wm0mjjwt",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
        }
      ]
    },
    "01m4wnic9x9b": {
      "id": "01m4wnic9x9b",
      "thing": "symbol",
      "name": "value",
      "documentation": "value to fill array section with",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "value value to fill array section with"
        }
      ]
    },
    "01m4wnsmtj59": {
      "id": "01m4wnsmtj59",
      "thing": "symbol",
      "name": "start",
      "documentation": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "start index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
        }
      ]
    },
    "01m4wlp7s872": {
      "id": "01m4wlp7s872",
      "thing": "symbol",
      "name": "end",
      "documentation": "index to stop filling the array at. If end is negative, it is treated as\nlength+end.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "end index to stop filling the array at. If end is negative, it is treated as\nlength+end."
        }
      ]
    },
    "01m4wnq8yqdy": {
      "id": "01m4wnq8yqdy",
      "thing": "symbol",
      "name": "target",
      "documentation": "If target is negative, it is treated as length+target where length is the\nlength of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "target If target is negative, it is treated as length+target where length is the\nlength of the array."
        }
      ]
    },
    "01m4wnrmvp4i": {
      "id": "01m4wnrmvp4i",
      "thing": "symbol",
      "name": "start",
      "documentation": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "start If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
        }
      ]
    },
    "01m4wlo29qbi": {
      "id": "01m4wlo29qbi",
      "thing": "symbol",
      "name": "end",
      "documentation": "If not specified, length of the this object is used as its default value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "end If not specified, length of the this object is used as its default value."
        }
      ]
    },
    "01m4wly1n1hm": {
      "id": "01m4wly1n1hm",
      "thing": "symbol",
      "name": "searchElement",
      "documentation": "The element to search for.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "searchElement The element to search for."
        }
      ]
    },
    "01m4wlrr8nnw": {
      "id": "01m4wlrr8nnw",
      "thing": "symbol",
      "name": "fromIndex",
      "documentation": "The position in this array at which to begin searching for searchElement.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "fromIndex The position in this array at which to begin searching for searchElement."
        }
      ]
    },
    "01m4wnemb0sw": {
      "id": "01m4wnemb0sw",
      "thing": "symbol",
      "name": "callback",
      "documentation": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        848
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wngjdu12"
            ],
            [
              "symbol",
              "01m4wnjhsf4q"
            ],
            [
              "symbol",
              "01m4wngxcymx"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wm7rp0tx"
          ],
          "returnType": [
            "type",
            850
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "callback A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
        }
      ]
    },
    "01m4wlxmnvvn": {
      "id": "01m4wlxmnvvn",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        805
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
        }
      ]
    },
    "01m4wnqy56s1": {
      "id": "01m4wnqy56s1",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        285
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wns1utpo": {
      "id": "01m4wns1utpo",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        75
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wnq206o9": {
      "id": "01m4wnq206o9",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        306
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wnrfw5b9": {
      "id": "01m4wnrfw5b9",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        322
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wnsmtj54": {
      "id": "01m4wnsmtj54",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        329
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wnr8wki5": {
      "id": "01m4wnr8wki5",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        856
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wnpn122y": {
      "id": "01m4wnpn122y",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        38
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wnq206oe": {
      "id": "01m4wnq206oe",
      "thing": "symbol",
      "name": "depth",
      "documentation": "The maximum recursion depth",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "depth The maximum recursion depth"
        }
      ]
    },
    "01m4wnp22co3": {
      "id": "01m4wnp22co3",
      "thing": "symbol",
      "name": "a",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnpy7crk": {
      "id": "01m4wnpy7crk",
      "thing": "symbol",
      "name": "b",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn70dle5": {
      "id": "01m4wn70dle5",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnamjotf": {
      "id": "01m4wnamjotf",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn6bm32v": {
      "id": "01m4wn6bm32v",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn7pj1og": {
      "id": "01m4wn7pj1og",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnbcp54q": {
      "id": "01m4wnbcp54q",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn736fbi": {
      "id": "01m4wn736fbi",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn4fx5wh": {
      "id": "01m4wn4fx5wh",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn84i6b3": {
      "id": "01m4wn84i6b3",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn6h7pwc": {
      "id": "01m4wn6h7pwc",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wna76n8y": {
      "id": "01m4wna76n8y",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wndcks61": {
      "id": "01m4wndcks61",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn5wmxgr": {
      "id": "01m4wn5wmxgr",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn5bo923": {
      "id": "01m4wn5bo923",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn8xuchd": {
      "id": "01m4wn8xuchd",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn4mwppt": {
      "id": "01m4wn4mwppt",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn8ihavw": {
      "id": "01m4wn8ihavw",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnc5nec7": {
      "id": "01m4wnc5nec7",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn7tprkn": {
      "id": "01m4wn7tprkn",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnwl6x8o": {
      "id": "01m4wnwl6x8o",
      "thing": "symbol",
      "name": "previousValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnohhk58": {
      "id": "01m4wnohhk58",
      "thing": "symbol",
      "name": "currentValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnpslou6": {
      "id": "01m4wnpslou6",
      "thing": "symbol",
      "name": "currentIndex",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn4ppjmy": {
      "id": "01m4wn4ppjmy",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnvh2dcb": {
      "id": "01m4wnvh2dcb",
      "thing": "symbol",
      "name": "previousValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnneqw76": {
      "id": "01m4wnneqw76",
      "thing": "symbol",
      "name": "currentValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnsa9beq": {
      "id": "01m4wnsa9beq",
      "thing": "symbol",
      "name": "currentIndex",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn8349cd": {
      "id": "01m4wn8349cd",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnwjs1ad": {
      "id": "01m4wnwjs1ad",
      "thing": "symbol",
      "name": "previousValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        781
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnlsudrf": {
      "id": "01m4wnlsudrf",
      "thing": "symbol",
      "name": "currentValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnq8yqf3": {
      "id": "01m4wnq8yqf3",
      "thing": "symbol",
      "name": "currentIndex",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn5lgmrs": {
      "id": "01m4wn5lgmrs",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlo99b3w": {
      "id": "01m4wlo99b3w",
      "thing": "symbol",
      "name": "previousValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnrfw58j": {
      "id": "01m4wnrfw58j",
      "thing": "symbol",
      "name": "currentValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnq3e3ko": {
      "id": "01m4wnq3e3ko",
      "thing": "symbol",
      "name": "currentIndex",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn85w39i": {
      "id": "01m4wn85w39i",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wloltiqr": {
      "id": "01m4wloltiqr",
      "thing": "symbol",
      "name": "previousValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnp693gw": {
      "id": "01m4wnp693gw",
      "thing": "symbol",
      "name": "currentValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnqhd86u": {
      "id": "01m4wnqhd86u",
      "thing": "symbol",
      "name": "currentIndex",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn5tu4jk": {
      "id": "01m4wn5tu4jk",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlnrhckj": {
      "id": "01m4wlnrhckj",
      "thing": "symbol",
      "name": "previousValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        783
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnrhb26p": {
      "id": "01m4wnrhb26p",
      "thing": "symbol",
      "name": "currentValue",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnvfngb5": {
      "id": "01m4wnvfngb5",
      "thing": "symbol",
      "name": "currentIndex",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn7o54q5": {
      "id": "01m4wn7o54q5",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wngnkkw9": {
      "id": "01m4wngnkkw9",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnmamcdq": {
      "id": "01m4wnmamcdq",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnnak6eg": {
      "id": "01m4wnnak6eg",
      "thing": "symbol",
      "name": "obj",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnhgiu4s": {
      "id": "01m4wnhgiu4s",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnmvl1s6": {
      "id": "01m4wnmvl1s6",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnln9q10": {
      "id": "01m4wnln9q10",
      "thing": "symbol",
      "name": "obj",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wngxcymb": {
      "id": "01m4wngxcymb",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnjorywv": {
      "id": "01m4wnjorywv",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnkopsxl": {
      "id": "01m4wnkopsxl",
      "thing": "symbol",
      "name": "obj",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wngjdu12": {
      "id": "01m4wngjdu12",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        49
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnjhsf4q": {
      "id": "01m4wnjhsf4q",
      "thing": "symbol",
      "name": "index",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wngxcymx": {
      "id": "01m4wngxcymx",
      "thing": "symbol",
      "name": "array",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        48
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlm2e38s": {
      "id": "01m4wlm2e38s",
      "thing": "symbol",
      "name": "ArrayConstructor",
      "documentation": "",
      "flags": [
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wnvh2d7d"
        ],
        [
          "symbol",
          "01m4wm9dljc8"
        ],
        [
          "symbol",
          "01m4wlsg06wc"
        ],
        [
          "symbol",
          "01m4wn9a1n5l"
        ],
        [
          "symbol",
          "01m4wm7xanqy"
        ],
        [
          "symbol",
          "01m4wmdspvyi"
        ],
        [
          "symbol",
          "01m4wn9s7iis"
        ]
      ]
    },
    "01m4wncusthw": {
      "id": "01m4wncusthw",
      "thing": "symbol",
      "name": "Iterator",
      "documentation": "",
      "flags": [
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wnhowbqm"
        ],
        [
          "symbol",
          "01m4wllvsff8"
        ],
        [
          "symbol",
          "01m4wnooh505"
        ],
        [
          "symbol",
          "01m4wn14xd06"
        ]
      ]
    },
    "01m4wnajqurf": {
      "id": "01m4wnajqurf",
      "thing": "symbol",
      "name": "U",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wna073bo": {
      "id": "01m4wna073bo",
      "thing": "symbol",
      "name": "S",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wlwcxo1c": {
      "id": "01m4wlwcxo1c",
      "thing": "symbol",
      "name": "IterableIterator",
      "documentation": "",
      "flags": [
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wnhowbqm"
        ],
        [
          "symbol",
          "01m4wmle9efo"
        ]
      ]
    },
    "01m4wmo8h8qc": {
      "id": "01m4wmo8h8qc",
      "thing": "symbol",
      "name": "This",
      "documentation": "",
      "flags": "TypeParameter",
      "type": [
        "type",
        4
      ]
    },
    "01m4wmqfcgkk": {
      "id": "01m4wmqfcgkk",
      "thing": "symbol",
      "name": "ConcatArray",
      "documentation": "",
      "flags": "Interface",
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wna9yh22"
        ],
        [
          "symbol",
          "01m4wnvo1x2a"
        ],
        [
          "symbol",
          "01m4wnucwsb6"
        ],
        [
          "symbol",
          "01m4wmjbkwk2"
        ],
        [
          "symbol",
          "01m4wmrrui68"
        ]
      ]
    },
    "01m4wlsg06wc": {
      "id": "01m4wlsg06wc",
      "thing": "symbol",
      "name": "isArray",
      "documentation": "",
      "flags": "Method",
      "type": [
        "type",
        894
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnta75ig"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmyst8dx"
          ],
          "returnType": [
            "type",
            16
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wn9a1n5l": {
      "id": "01m4wn9a1n5l",
      "thing": "symbol",
      "name": "prototype",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        58
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wm7xanqy": {
      "id": "01m4wm7xanqy",
      "thing": "symbol",
      "name": "from",
      "documentation": "Creates an array from an array-like object.\nCreates an array from an iterable object.\nCreates an array from an iterable object.\nCreates an array from an iterable object.",
      "flags": [
        "Method",
        "Transient"
      ],
      "type": [
        "type",
        895
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wms2mw3f"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmrkuxf3"
          ],
          "returnType": [
            "type",
            902
          ],
          "documentation": "Creates an array from an array-like object."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wmtay7uw"
            ],
            [
              "symbol",
              "01m4wnb8ie8y"
            ],
            [
              "symbol",
              "01m4wm0fk04o"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm3xjctl"
          ],
          "returnType": [
            "type",
            903
          ],
          "documentation": "Creates an array from an iterable object."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wn2iubou"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnpoey02"
          ],
          "returnType": [
            "type",
            904
          ],
          "documentation": "Creates an array from an iterable object."
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wn5sg7h3"
            ],
            [
              "symbol",
              "01m4wn98mq7j"
            ],
            [
              "symbol",
              "01m4wlwwiglp"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn9099ak"
          ],
          "returnType": [
            "type",
            905
          ],
          "documentation": "Creates an array from an iterable object."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "arrayLike An array-like object to convert to an array."
        },
        {
          "name": "param",
          "text": "arrayLike An array-like object to convert to an array."
        },
        {
          "name": "param",
          "text": "mapfn A mapping function to call on every element of the array."
        },
        {
          "name": "param",
          "text": "thisArg Value of 'this' used to invoke the mapfn."
        },
        {
          "name": "param",
          "text": "iterable An iterable object to convert to an array."
        },
        {
          "name": "param",
          "text": "iterable An iterable object to convert to an array."
        },
        {
          "name": "param",
          "text": "mapfn A mapping function to call on every element of the array."
        },
        {
          "name": "param",
          "text": "thisArg Value of 'this' used to invoke the mapfn."
        }
      ]
    },
    "01m4wmdspvyi": {
      "id": "01m4wmdspvyi",
      "thing": "symbol",
      "name": "of",
      "documentation": "Returns a new array from a set of elements.",
      "flags": "Method",
      "type": [
        "type",
        906
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnth6pbc"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wm08keo5"
          ],
          "returnType": [
            "type",
            908
          ],
          "documentation": "Returns a new array from a set of elements."
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items A set of elements to include in the new array object."
        }
      ]
    },
    "01m4wn9s7iis": {
      "id": "01m4wn9s7iis",
      "thing": "symbol",
      "name": "__@species",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        743
      ],
      "constructorSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wmid20lk"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlv4mdet"
          ],
          "returnType": [
            "type",
            58
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wmj609t0"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnmg7yxw"
          ],
          "returnType": [
            "type",
            748
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnnby3cw"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wnqpqosj"
          ],
          "returnType": [
            "type",
            749
          ],
          "documentation": ""
        }
      ],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wmj0elyg"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wne6wy94"
          ],
          "returnType": [
            "type",
            58
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wmi1uowm"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wmfy77qk"
          ],
          "returnType": [
            "type",
            750
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wnn6dfie"
            ]
          ],
          "typeParameters": [],
          "declaration": [
            "declaration",
            "01m4wn88ow19"
          ],
          "returnType": [
            "type",
            751
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wllvsff8": {
      "id": "01m4wllvsff8",
      "thing": "symbol",
      "name": "next",
      "documentation": "",
      "flags": [
        "Method",
        "Transient"
      ],
      "type": [
        "type",
        909
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wni5adg9"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn0hkqo5"
          ],
          "returnType": [
            "type",
            913
          ],
          "documentation": ""
        },
        {
          "parameters": [
            [
              "symbol",
              "01m4wni5adg9"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wn0hkqo5"
          ],
          "returnType": [
            "type",
            913
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wnooh505": {
      "id": "01m4wnooh505",
      "thing": "symbol",
      "name": "return",
      "documentation": "",
      "flags": [
        "Method",
        "Optional"
      ],
      "type": [
        "type",
        914
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnic9x9e"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wlplrcnk"
          ],
          "returnType": [
            "type",
            913
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wn14xd06": {
      "id": "01m4wn14xd06",
      "thing": "symbol",
      "name": "throw",
      "documentation": "",
      "flags": [
        "Method",
        "Optional"
      ],
      "type": [
        "type",
        915
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wll9ft39"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmrgo7ls"
          ],
          "returnType": [
            "type",
            913
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wmle9efo": {
      "id": "01m4wmle9efo",
      "thing": "symbol",
      "name": "__@iterator",
      "documentation": "",
      "flags": "Method",
      "type": [
        "type",
        916
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [],
          "declaration": [
            "declaration",
            "01m4wn1hikvd"
          ],
          "returnType": [
            "type",
            790
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wmx2c23q": {
      "id": "01m4wmx2c23q",
      "thing": "symbol",
      "name": "copyWithin",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnfxf5lu": {
      "id": "01m4wnfxf5lu",
      "thing": "symbol",
      "name": "entries",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wn78r32m": {
      "id": "01m4wn78r32m",
      "thing": "symbol",
      "name": "fill",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wncb9236": {
      "id": "01m4wncb9236",
      "thing": "symbol",
      "name": "find",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wns1utpe": {
      "id": "01m4wns1utpe",
      "thing": "symbol",
      "name": "findIndex",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnetaklm": {
      "id": "01m4wnetaklm",
      "thing": "symbol",
      "name": "keys",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wneuohkp": {
      "id": "01m4wneuohkp",
      "thing": "symbol",
      "name": "values",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnvo1x2a": {
      "id": "01m4wnvo1x2a",
      "thing": "symbol",
      "name": "length",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        11
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wmjbkwk2": {
      "id": "01m4wmjbkwk2",
      "thing": "symbol",
      "name": "join",
      "documentation": "",
      "flags": "Method",
      "type": [
        "type",
        917
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wlys7dtw"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wni3vgcg"
          ],
          "returnType": [
            "type",
            10
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wmrrui68": {
      "id": "01m4wmrrui68",
      "thing": "symbol",
      "name": "slice",
      "documentation": "",
      "flags": "Method",
      "type": [
        "type",
        918
      ],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnng5t8a"
            ],
            [
              "symbol",
              "01m4wnuh4jbw"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wmow8r74"
          ],
          "returnType": [
            "type",
            919
          ],
          "documentation": ""
        }
      ]
    },
    "01m4wnta75ig": {
      "id": "01m4wnta75ig",
      "thing": "symbol",
      "name": "arg",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wms2mw3f": {
      "id": "01m4wms2mw3f",
      "thing": "symbol",
      "name": "arrayLike",
      "documentation": "An array-like object to convert to an array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        923
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "arrayLike An array-like object to convert to an array."
        }
      ]
    },
    "01m4wmtay7uw": {
      "id": "01m4wmtay7uw",
      "thing": "symbol",
      "name": "arrayLike",
      "documentation": "An array-like object to convert to an array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        924
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "arrayLike An array-like object to convert to an array."
        }
      ]
    },
    "01m4wnb8ie8y": {
      "id": "01m4wnb8ie8y",
      "thing": "symbol",
      "name": "mapfn",
      "documentation": "A mapping function to call on every element of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        925
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wns39qp1"
            ],
            [
              "symbol",
              "01m4wnw77snb"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnq66wlg"
          ],
          "returnType": [
            "type",
            898
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "mapfn A mapping function to call on every element of the array."
        }
      ]
    },
    "01m4wm0fk04o": {
      "id": "01m4wm0fk04o",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "Value of 'this' used to invoke the mapfn.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg Value of 'this' used to invoke the mapfn."
        }
      ]
    },
    "01m4wn2iubou": {
      "id": "01m4wn2iubou",
      "thing": "symbol",
      "name": "iterable",
      "documentation": "An iterable object to convert to an array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        928
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "iterable An iterable object to convert to an array."
        }
      ]
    },
    "01m4wn5sg7h3": {
      "id": "01m4wn5sg7h3",
      "thing": "symbol",
      "name": "iterable",
      "documentation": "An iterable object to convert to an array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        931
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "iterable An iterable object to convert to an array."
        }
      ]
    },
    "01m4wn98mq7j": {
      "id": "01m4wn98mq7j",
      "thing": "symbol",
      "name": "mapfn",
      "documentation": "A mapping function to call on every element of the array.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        932
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [
        {
          "parameters": [
            [
              "symbol",
              "01m4wnq3e3nl"
            ],
            [
              "symbol",
              "01m4wnwe7dgg"
            ]
          ],
          "declaration": [
            "declaration",
            "01m4wnq66wlg"
          ],
          "returnType": [
            "type",
            901
          ],
          "documentation": ""
        }
      ],
      "jsDocTags": [
        {
          "name": "param",
          "text": "mapfn A mapping function to call on every element of the array."
        }
      ]
    },
    "01m4wlwwiglp": {
      "id": "01m4wlwwiglp",
      "thing": "symbol",
      "name": "thisArg",
      "documentation": "Value of 'this' used to invoke the mapfn.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "thisArg Value of 'this' used to invoke the mapfn."
        }
      ]
    },
    "01m4wnth6pbc": {
      "id": "01m4wnth6pbc",
      "thing": "symbol",
      "name": "items",
      "documentation": "A set of elements to include in the new array object.",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        908
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": [],
      "jsDocTags": [
        {
          "name": "param",
          "text": "items A set of elements to include in the new array object."
        }
      ]
    },
    "01m4wni5adg9": {
      "id": "01m4wni5adg9",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnic9x9e": {
      "id": "01m4wnic9x9e",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wll9ft39": {
      "id": "01m4wll9ft39",
      "thing": "symbol",
      "name": "e",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        1
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wlys7dtw": {
      "id": "01m4wlys7dtw",
      "thing": "symbol",
      "name": "separator",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        10
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnng5t8a": {
      "id": "01m4wnng5t8a",
      "thing": "symbol",
      "name": "start",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnuh4jbw": {
      "id": "01m4wnuh4jbw",
      "thing": "symbol",
      "name": "end",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wns39qp1": {
      "id": "01m4wns39qp1",
      "thing": "symbol",
      "name": "v",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        897
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnw77snb": {
      "id": "01m4wnw77snb",
      "thing": "symbol",
      "name": "k",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnq3e3nl": {
      "id": "01m4wnq3e3nl",
      "thing": "symbol",
      "name": "v",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        900
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnwe7dgg": {
      "id": "01m4wnwe7dgg",
      "thing": "symbol",
      "name": "k",
      "documentation": "",
      "flags": "FunctionScopedVariable",
      "type": [
        "type",
        11
      ],
      "exports": [],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wll81vyk": {
      "id": "01m4wll81vyk",
      "thing": "symbol",
      "name": "IteratorResult",
      "documentation": "",
      "flags": [
        "Interface",
        "Transient"
      ],
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wnhowbqm"
        ],
        [
          "symbol",
          "01m4wn6a860e"
        ],
        [
          "symbol",
          "01m4wnfjg10k"
        ]
      ]
    },
    "01m4wnf89p62": {
      "id": "01m4wnf89p62",
      "thing": "symbol",
      "name": "ArrayLike",
      "documentation": "",
      "flags": "Interface",
      "type": [
        "type",
        4
      ],
      "members": [
        [
          "symbol",
          "01m4wna9yh22"
        ],
        [
          "symbol",
          "01m4wnp7n0f9"
        ],
        [
          "symbol",
          "01m4wnucwsb6"
        ]
      ]
    },
    "01m4wn6a860e": {
      "id": "01m4wn6a860e",
      "thing": "symbol",
      "name": "done",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        16
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnfjg10k": {
      "id": "01m4wnfjg10k",
      "thing": "symbol",
      "name": "value",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        911
      ],
      "constructorSignatures": [],
      "callSignatures": []
    },
    "01m4wnp7n0f9": {
      "id": "01m4wnp7n0f9",
      "thing": "symbol",
      "name": "length",
      "documentation": "",
      "flags": "Property",
      "type": [
        "type",
        11
      ],
      "constructorSignatures": [],
      "callSignatures": []
    }
  },
  "type": {
    "1": {
      "id": 1,
      "thing": "type",
      "typeString": "any",
      "flags": "Any"
    },
    "4": {
      "id": 4,
      "thing": "type",
      "typeString": "any",
      "flags": "Any"
    },
    "6": {
      "id": 6,
      "thing": "type",
      "typeString": "undefined",
      "flags": "Undefined"
    },
    "10": {
      "id": 10,
      "thing": "type",
      "typeString": "string",
      "flags": "String",
      "numberIndexType": [
        "type",
        10
      ],
      "stringIndexType": [
        "type",
        10
      ]
    },
    "11": {
      "id": 11,
      "thing": "type",
      "typeString": "number",
      "flags": "Number"
    },
    "16": {
      "id": 16,
      "thing": "type",
      "typeString": "boolean",
      "flags": [
        "Boolean",
        "Union",
        "UnionOfPrimitiveTypes"
      ],
      "constraint": [
        "type",
        16
      ]
    },
    "21": {
      "id": 21,
      "thing": "type",
      "typeString": "void",
      "flags": "Void"
    },
    "22": {
      "id": 22,
      "thing": "type",
      "typeString": "never",
      "flags": "Never"
    },
    "38": {
      "id": 38,
      "thing": "type",
      "typeString": "0",
      "flags": "NumberLiteral"
    },
    "48": {
      "id": 48,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": [
        "Interface",
        "Reference"
      ],
      "numberIndexType": [
        "type",
        49
      ],
      "stringIndexType": [
        "type",
        49
      ],
      "baseTypes": []
    },
    "49": {
      "id": 49,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnhowbqm"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "50": {
      "id": 50,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "this",
      "flags": "TypeParameter",
      "numberIndexType": [
        "type",
        49
      ],
      "stringIndexType": [
        "type",
        49
      ],
      "constraint": [
        "type",
        858
      ]
    },
    "58": {
      "id": 58,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "any[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        1
      ],
      "stringIndexType": [
        "type",
        1
      ]
    },
    "67": {
      "id": 67,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmn1jtlc"
      ],
      "typeString": "typeof import(\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/types\")",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "68": {
      "id": 68,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wne8buvw"
      ],
      "typeString": "typeof import(\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/vehicle\")",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "69": {
      "id": 69,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wllkm4ws"
      ],
      "typeString": "typeof import(\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/cycles\")",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "70": {
      "id": 70,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlrk93ht"
      ],
      "typeString": "typeof import(\"/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/car\")",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "71": {
      "id": 71,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnb74hed"
      ],
      "typeString": "typeof import(\"cases/6-ts-advanced-types/src/index\")",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "72": {
      "id": 72,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnhf4x6o"
      ],
      "typeString": "typeof Vehicle",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "73": {
      "id": 73,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnhf4x6o"
      ],
      "typeString": "Vehicle",
      "flags": "Object",
      "objectFlags": [
        "Class",
        "Reference"
      ],
      "baseTypes": []
    },
    "75": {
      "id": 75,
      "thing": "type",
      "typeString": "4",
      "flags": "NumberLiteral"
    },
    "79": {
      "id": 79,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "VehicleFactory<4>",
      "aliasTypeArguments": [],
      "aliasSymbol": [
        "symbol",
        "01m4wlw4k7d8"
      ],
      "flags": "Object",
      "objectFlags": [
        "Anonymous",
        "Instantiated"
      ]
    },
    "80": {
      "id": 80,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnhowbqe"
      ],
      "typeString": "VehicleLike",
      "flags": "Object",
      "objectFlags": "Interface",
      "baseTypes": []
    },
    "81": {
      "id": 81,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmqi5ait"
      ],
      "typeString": "typeof Bike",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "82": {
      "id": 82,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmqi5ait"
      ],
      "typeString": "Bike",
      "flags": "Object",
      "objectFlags": [
        "Class",
        "Reference"
      ],
      "baseTypes": []
    },
    "85": {
      "id": 85,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wly78ocm"
      ],
      "typeString": "typeof Unicycle",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "86": {
      "id": 86,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wly78ocm"
      ],
      "typeString": "Unicycle",
      "flags": "Object",
      "objectFlags": [
        "Class",
        "Reference"
      ],
      "baseTypes": []
    },
    "89": {
      "id": 89,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnht42ro"
      ],
      "typeString": "typeof Car",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "90": {
      "id": 90,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnht42ro"
      ],
      "typeString": "Car",
      "flags": "Object",
      "objectFlags": [
        "Class",
        "Reference"
      ],
      "baseTypes": []
    },
    "92": {
      "id": 92,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlu1vpg7"
      ],
      "typeString": "{ (a: number, b: number): number; (a: string, b: string): string; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "94": {
      "id": 94,
      "thing": "type",
      "typeString": "\"shhhhh!\"",
      "flags": [
        "StringLiteral",
        "FreshLiteral"
      ],
      "numberIndexType": [
        "type",
        10
      ],
      "stringIndexType": [
        "type",
        10
      ]
    },
    "96": {
      "id": 96,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wne9ps6v"
      ],
      "typeString": "typeof VehicleUtils",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "97": {
      "id": 97,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wne9ps6v"
      ],
      "typeString": "VehicleUtils",
      "flags": "Object",
      "objectFlags": [
        "Class",
        "Reference"
      ],
      "baseTypes": []
    },
    "99": {
      "id": 99,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn8xucdo"
      ],
      "typeString": "() => Bike",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "101": {
      "id": 101,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmdrbyxe"
      ],
      "typeString": "(n: number) => Promise<void>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "103": {
      "id": 103,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm83vbk7"
      ],
      "typeString": "PromiseConstructor",
      "flags": "Object",
      "objectFlags": "Interface",
      "baseTypes": []
    },
    "104": {
      "id": 104,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "105": {
      "id": 105,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "108": {
      "id": 108,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value?: T | PromiseLike<T>) => void",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "116": {
      "id": 116,
      "thing": "type",
      "typeString": "T | PromiseLike<T>",
      "flags": "Union"
    },
    "121": {
      "id": 121,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(reason?: any) => void",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "122": {
      "id": 122,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T>",
      "flags": "Object",
      "objectFlags": [
        "Interface",
        "Reference"
      ],
      "baseTypes": []
    },
    "123": {
      "id": 123,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnhowbqm"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "125": {
      "id": 125,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "126": {
      "id": 126,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<void>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "127": {
      "id": 127,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm3fdh7b"
      ],
      "typeString": "<TResult1 = T, TResult2 = never>(onfulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>) => Promise<TResult1 | TResult2>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "129": {
      "id": 129,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wln9bh4o"
      ],
      "typeString": "TResult1",
      "flags": "TypeParameter",
      "defaultType": [
        "type",
        123
      ]
    },
    "130": {
      "id": 130,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlnj3uu2"
      ],
      "typeString": "TResult2",
      "flags": "TypeParameter",
      "defaultType": [
        "type",
        22
      ]
    },
    "133": {
      "id": 133,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T) => TResult1 | PromiseLike<TResult1>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "137": {
      "id": 137,
      "thing": "type",
      "typeString": "TResult1 | PromiseLike<TResult1>",
      "flags": "Union"
    },
    "144": {
      "id": 144,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<TResult1 | TResult2>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "147": {
      "id": 147,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<Bike>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "154": {
      "id": 154,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlqu3nkj"
      ],
      "typeString": "() => void",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "155": {
      "id": 155,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnw088q1"
      ],
      "typeString": "() => string",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "159": {
      "id": 159,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmnibsdr"
      ],
      "typeString": "<TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>) => Promise<T | TResult>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "160": {
      "id": 160,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wntikm57"
      ],
      "typeString": "TResult",
      "flags": "TypeParameter",
      "defaultType": [
        "type",
        22
      ]
    },
    "162": {
      "id": 162,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T | TResult>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "163": {
      "id": 163,
      "thing": "type",
      "typeString": "\"Promise\"",
      "flags": "StringLiteral",
      "numberIndexType": [
        "type",
        10
      ],
      "stringIndexType": [
        "type",
        10
      ]
    },
    "165": {
      "id": 165,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmuaw1vg"
      ],
      "typeString": "(onfinally?: () => void) => Promise<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "166": {
      "id": 166,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmjfrnfr"
      ],
      "typeString": "() => string",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "168": {
      "id": 168,
      "thing": "type",
      "typeString": "\"Utilities for vehicles\"",
      "flags": "StringLiteral",
      "numberIndexType": [
        "type",
        10
      ],
      "stringIndexType": [
        "type",
        10
      ]
    },
    "170": {
      "id": 170,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(reason: any) => TResult2 | PromiseLike<TResult2>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "172": {
      "id": 172,
      "thing": "type",
      "typeString": "TResult2 | PromiseLike<TResult2>",
      "flags": "Union"
    },
    "173": {
      "id": 173,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(reason: any) => TResult | PromiseLike<TResult>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "175": {
      "id": 175,
      "thing": "type",
      "typeString": "TResult | PromiseLike<TResult>",
      "flags": "Union"
    },
    "176": {
      "id": 176,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "() => void",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "177": {
      "id": 177,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm2nt4ua"
      ],
      "typeString": "{ <TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, ... 5 more ..., T10 | PromiseLike<...>]): Promise<...>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [...])...",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "178": {
      "id": 178,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm7ax2e8"
      ],
      "typeString": "TAll",
      "flags": "TypeParameter"
    },
    "179": {
      "id": 179,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "180": {
      "id": 180,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "181": {
      "id": 181,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "182": {
      "id": 182,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "183": {
      "id": 183,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "184": {
      "id": 184,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "185": {
      "id": 185,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "186": {
      "id": 186,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmalwu5n"
      ],
      "typeString": "T8",
      "flags": "TypeParameter"
    },
    "187": {
      "id": 187,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmavp8v1"
      ],
      "typeString": "T9",
      "flags": "TypeParameter"
    },
    "188": {
      "id": 188,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wneqhqnh"
      ],
      "typeString": "T10",
      "flags": "TypeParameter"
    },
    "189": {
      "id": 189,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "190": {
      "id": 190,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "191": {
      "id": 191,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "192": {
      "id": 192,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "193": {
      "id": 193,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "194": {
      "id": 194,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "195": {
      "id": 195,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "196": {
      "id": 196,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmalwu5n"
      ],
      "typeString": "T8",
      "flags": "TypeParameter"
    },
    "197": {
      "id": 197,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmavp8v1"
      ],
      "typeString": "T9",
      "flags": "TypeParameter"
    },
    "198": {
      "id": 198,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "199": {
      "id": 199,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "200": {
      "id": 200,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "201": {
      "id": 201,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "202": {
      "id": 202,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "203": {
      "id": 203,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "204": {
      "id": 204,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "205": {
      "id": 205,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmalwu5n"
      ],
      "typeString": "T8",
      "flags": "TypeParameter"
    },
    "206": {
      "id": 206,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "207": {
      "id": 207,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "208": {
      "id": 208,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "209": {
      "id": 209,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "210": {
      "id": 210,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "211": {
      "id": 211,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "212": {
      "id": 212,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "213": {
      "id": 213,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "214": {
      "id": 214,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "215": {
      "id": 215,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "216": {
      "id": 216,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "217": {
      "id": 217,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "218": {
      "id": 218,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "219": {
      "id": 219,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "220": {
      "id": 220,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "221": {
      "id": 221,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "222": {
      "id": 222,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "223": {
      "id": 223,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "224": {
      "id": 224,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "225": {
      "id": 225,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "226": {
      "id": 226,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "227": {
      "id": 227,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "228": {
      "id": 228,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "229": {
      "id": 229,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "230": {
      "id": 230,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "231": {
      "id": 231,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "232": {
      "id": 232,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "233": {
      "id": 233,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "235": {
      "id": 235,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<TAll[]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "250": {
      "id": 250,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "264": {
      "id": 264,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "277": {
      "id": 277,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "285": {
      "id": 285,
      "thing": "type",
      "typeString": "7",
      "flags": "NumberLiteral"
    },
    "289": {
      "id": 289,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3, T4, T5, T6, T7]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "296": {
      "id": 296,
      "thing": "type",
      "typeString": "6",
      "flags": "NumberLiteral"
    },
    "300": {
      "id": 300,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3, T4, T5, T6]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "306": {
      "id": 306,
      "thing": "type",
      "typeString": "5",
      "flags": "NumberLiteral"
    },
    "310": {
      "id": 310,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3, T4, T5]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "318": {
      "id": 318,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3, T4]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "322": {
      "id": 322,
      "thing": "type",
      "typeString": "3",
      "flags": "NumberLiteral"
    },
    "326": {
      "id": 326,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2, T3]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "329": {
      "id": 329,
      "thing": "type",
      "typeString": "2",
      "flags": "NumberLiteral"
    },
    "333": {
      "id": 333,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<[T1, T2]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "335": {
      "id": 335,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T[]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "336": {
      "id": 336,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wln54q77"
      ],
      "typeString": "{ <T>(values: Iterable<T | PromiseLike<T>>): Promise<T>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, ... 5 more ..., T10 | PromiseLike<...>]): Promise<...>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [...]): Promise<...>...",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "337": {
      "id": 337,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "338": {
      "id": 338,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "339": {
      "id": 339,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "340": {
      "id": 340,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "341": {
      "id": 341,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "342": {
      "id": 342,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "343": {
      "id": 343,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "344": {
      "id": 344,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "345": {
      "id": 345,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmalwu5n"
      ],
      "typeString": "T8",
      "flags": "TypeParameter"
    },
    "346": {
      "id": 346,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmavp8v1"
      ],
      "typeString": "T9",
      "flags": "TypeParameter"
    },
    "347": {
      "id": 347,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wneqhqnh"
      ],
      "typeString": "T10",
      "flags": "TypeParameter"
    },
    "348": {
      "id": 348,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "349": {
      "id": 349,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "350": {
      "id": 350,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "351": {
      "id": 351,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "352": {
      "id": 352,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "353": {
      "id": 353,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "354": {
      "id": 354,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "355": {
      "id": 355,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmalwu5n"
      ],
      "typeString": "T8",
      "flags": "TypeParameter"
    },
    "356": {
      "id": 356,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmavp8v1"
      ],
      "typeString": "T9",
      "flags": "TypeParameter"
    },
    "357": {
      "id": 357,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "358": {
      "id": 358,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "359": {
      "id": 359,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "360": {
      "id": 360,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "361": {
      "id": 361,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "362": {
      "id": 362,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "363": {
      "id": 363,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "364": {
      "id": 364,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmalwu5n"
      ],
      "typeString": "T8",
      "flags": "TypeParameter"
    },
    "365": {
      "id": 365,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "366": {
      "id": 366,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "367": {
      "id": 367,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "368": {
      "id": 368,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "369": {
      "id": 369,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "370": {
      "id": 370,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "371": {
      "id": 371,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmac5gfa"
      ],
      "typeString": "T7",
      "flags": "TypeParameter"
    },
    "372": {
      "id": 372,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "373": {
      "id": 373,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "374": {
      "id": 374,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "375": {
      "id": 375,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "376": {
      "id": 376,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "377": {
      "id": 377,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wma2d2ow"
      ],
      "typeString": "T6",
      "flags": "TypeParameter"
    },
    "378": {
      "id": 378,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "379": {
      "id": 379,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "380": {
      "id": 380,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "381": {
      "id": 381,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "382": {
      "id": 382,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9rknyj"
      ],
      "typeString": "T5",
      "flags": "TypeParameter"
    },
    "383": {
      "id": 383,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "384": {
      "id": 384,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "385": {
      "id": 385,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "386": {
      "id": 386,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9hsa96"
      ],
      "typeString": "T4",
      "flags": "TypeParameter"
    },
    "387": {
      "id": 387,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "388": {
      "id": 388,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "389": {
      "id": 389,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm980vis"
      ],
      "typeString": "T3",
      "flags": "TypeParameter"
    },
    "390": {
      "id": 390,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8ng432"
      ],
      "typeString": "T1",
      "flags": "TypeParameter"
    },
    "391": {
      "id": 391,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm8x8hsf"
      ],
      "typeString": "T2",
      "flags": "TypeParameter"
    },
    "392": {
      "id": 392,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "393": {
      "id": 393,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "395": {
      "id": 395,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "397": {
      "id": 397,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "399": {
      "id": 399,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "401": {
      "id": 401,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "403": {
      "id": 403,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3 | T4 | T5 | T6>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "405": {
      "id": 405,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3 | T4 | T5>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "407": {
      "id": 407,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3 | T4>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "409": {
      "id": 409,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2 | T3>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "411": {
      "id": 411,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T1 | T2>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "412": {
      "id": 412,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "413": {
      "id": 413,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<any>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "414": {
      "id": 414,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm2b8wa0"
      ],
      "typeString": "<T = never>(reason?: any) => Promise<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "415": {
      "id": 415,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter",
      "defaultType": [
        "type",
        22
      ]
    },
    "416": {
      "id": 416,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "417": {
      "id": 417,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmqrwo63"
      ],
      "typeString": "{ <T>(value: T | PromiseLike<T>): Promise<T>; (): Promise<void>; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "418": {
      "id": 418,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "419": {
      "id": 419,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnqtxfsw"
      ],
      "typeString": "Promise<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "425": {
      "id": 425,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn1hikok"
      ],
      "typeString": "Iterable<TAll | PromiseLike<TAll>>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "446": {
      "id": 446,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>, T8 | PromiseLike<...>, T9 | PromiseLike<...>, T10 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        449
      ],
      "stringIndexType": [
        "type",
        449
      ]
    },
    "449": {
      "id": 449,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<...> | PromiseLike<...> | PromiseLike<...> | PromiseLike<...>",
      "flags": "Union"
    },
    "470": {
      "id": 470,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>, T8 | PromiseLike<...>, T9 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        473
      ],
      "stringIndexType": [
        "type",
        473
      ]
    },
    "473": {
      "id": 473,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<...> | PromiseLike<...> | PromiseLike<...>",
      "flags": "Union"
    },
    "492": {
      "id": 492,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>, T8 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        495
      ],
      "stringIndexType": [
        "type",
        495
      ]
    },
    "495": {
      "id": 495,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<T7> | PromiseLike<...>",
      "flags": "Union"
    },
    "512": {
      "id": 512,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        515
      ],
      "stringIndexType": [
        "type",
        515
      ]
    },
    "515": {
      "id": 515,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<T7>",
      "flags": "Union"
    },
    "530": {
      "id": 530,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        533
      ],
      "stringIndexType": [
        "type",
        533
      ]
    },
    "533": {
      "id": 533,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6>",
      "flags": "Union"
    },
    "546": {
      "id": 546,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        549
      ],
      "stringIndexType": [
        "type",
        549
      ]
    },
    "549": {
      "id": 549,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5>",
      "flags": "Union"
    },
    "560": {
      "id": 560,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        563
      ],
      "stringIndexType": [
        "type",
        563
      ]
    },
    "563": {
      "id": 563,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4>",
      "flags": "Union"
    },
    "572": {
      "id": 572,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        575
      ],
      "stringIndexType": [
        "type",
        575
      ]
    },
    "575": {
      "id": 575,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3>",
      "flags": "Union"
    },
    "582": {
      "id": 582,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        585
      ],
      "stringIndexType": [
        "type",
        585
      ]
    },
    "585": {
      "id": 585,
      "thing": "type",
      "typeString": "T1 | T2 | PromiseLike<T1> | PromiseLike<T2>",
      "flags": "Union"
    },
    "589": {
      "id": 589,
      "thing": "type",
      "typeString": "T | PromiseLike<T>",
      "flags": "Union"
    },
    "590": {
      "id": 590,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "(T | PromiseLike<T>)[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        589
      ],
      "stringIndexType": [
        "type",
        589
      ]
    },
    "593": {
      "id": 593,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn1hikok"
      ],
      "typeString": "Iterable<T | PromiseLike<T>>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "614": {
      "id": 614,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>, T8 | PromiseLike<...>, T9 | PromiseLike<...>, T10 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        615
      ],
      "stringIndexType": [
        "type",
        615
      ]
    },
    "615": {
      "id": 615,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<...> | PromiseLike<...> | PromiseLike<...> | PromiseLike<...>",
      "flags": "Union"
    },
    "636": {
      "id": 636,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>, T8 | PromiseLike<...>, T9 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        637
      ],
      "stringIndexType": [
        "type",
        637
      ]
    },
    "637": {
      "id": 637,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<...> | PromiseLike<...> | PromiseLike<...>",
      "flags": "Union"
    },
    "656": {
      "id": 656,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>, T8 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        657
      ],
      "stringIndexType": [
        "type",
        657
      ]
    },
    "657": {
      "id": 657,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<T7> | PromiseLike<...>",
      "flags": "Union"
    },
    "674": {
      "id": 674,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<...>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        675
      ],
      "stringIndexType": [
        "type",
        675
      ]
    },
    "675": {
      "id": 675,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | T7 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6> | PromiseLike<T7>",
      "flags": "Union"
    },
    "690": {
      "id": 690,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        691
      ],
      "stringIndexType": [
        "type",
        691
      ]
    },
    "691": {
      "id": 691,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | T6 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5> | PromiseLike<T6>",
      "flags": "Union"
    },
    "704": {
      "id": 704,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        705
      ],
      "stringIndexType": [
        "type",
        705
      ]
    },
    "705": {
      "id": 705,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | T5 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4> | PromiseLike<T5>",
      "flags": "Union"
    },
    "716": {
      "id": 716,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        717
      ],
      "stringIndexType": [
        "type",
        717
      ]
    },
    "717": {
      "id": 717,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | T4 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3> | PromiseLike<T4>",
      "flags": "Union"
    },
    "726": {
      "id": 726,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        727
      ],
      "stringIndexType": [
        "type",
        727
      ]
    },
    "727": {
      "id": 727,
      "thing": "type",
      "typeString": "T1 | T2 | T3 | PromiseLike<T1> | PromiseLike<T2> | PromiseLike<T3>",
      "flags": "Union"
    },
    "734": {
      "id": 734,
      "thing": "type",
      "typeString": "[T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        735
      ],
      "stringIndexType": [
        "type",
        735
      ]
    },
    "735": {
      "id": 735,
      "thing": "type",
      "typeString": "T1 | T2 | PromiseLike<T1> | PromiseLike<T2>",
      "flags": "Union"
    },
    "739": {
      "id": 739,
      "thing": "type",
      "typeString": "T | PromiseLike<T>",
      "flags": "Union"
    },
    "740": {
      "id": 740,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "(T | PromiseLike<T>)[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        739
      ],
      "stringIndexType": [
        "type",
        739
      ]
    },
    "742": {
      "id": 742,
      "thing": "type",
      "typeString": "T | PromiseLike<T>",
      "flags": "Union"
    },
    "743": {
      "id": 743,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlm2e38s"
      ],
      "typeString": "ArrayConstructor",
      "flags": "Object",
      "objectFlags": "Interface",
      "baseTypes": []
    },
    "744": {
      "id": 744,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "745": {
      "id": 745,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "746": {
      "id": 746,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "747": {
      "id": 747,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "748": {
      "id": 748,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        746
      ],
      "stringIndexType": [
        "type",
        746
      ]
    },
    "749": {
      "id": 749,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        747
      ],
      "stringIndexType": [
        "type",
        747
      ]
    },
    "750": {
      "id": 750,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        744
      ],
      "stringIndexType": [
        "type",
        744
      ]
    },
    "751": {
      "id": 751,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        745
      ],
      "stringIndexType": [
        "type",
        745
      ]
    },
    "752": {
      "id": 752,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmkcwngf"
      ],
      "typeString": "() => Iterator<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "756": {
      "id": 756,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wncusthw"
      ],
      "typeString": "Iterator<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "757": {
      "id": 757,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmeu2mxo"
      ],
      "typeString": "() => string",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "758": {
      "id": 758,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmwhr9lt"
      ],
      "typeString": "() => string",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "759": {
      "id": 759,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmih8qbg"
      ],
      "typeString": "() => T",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "760": {
      "id": 760,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm4cihad"
      ],
      "typeString": "(...items: T[]) => number",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "761": {
      "id": 761,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmls8j4u"
      ],
      "typeString": "{ (...items: ConcatArray<T>[]): T[]; (...items: (T | ConcatArray<T>)[]): T[]; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "762": {
      "id": 762,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmj8s3mw"
      ],
      "typeString": "(separator?: string) => string",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "763": {
      "id": 763,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnb04wal"
      ],
      "typeString": "() => T[]",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "764": {
      "id": 764,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn1vhp8c"
      ],
      "typeString": "() => T",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "765": {
      "id": 765,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmoxmny5"
      ],
      "typeString": "(start?: number, end?: number) => T[]",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "766": {
      "id": 766,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm56ungj"
      ],
      "typeString": "(compareFn?: (a: T, b: T) => number) => this",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "767": {
      "id": 767,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm01kuij"
      ],
      "typeString": "{ (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "768": {
      "id": 768,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnc5ne5u"
      ],
      "typeString": "(...items: T[]) => number",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "769": {
      "id": 769,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn6d0yty"
      ],
      "typeString": "(searchElement: T, fromIndex?: number) => number",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "770": {
      "id": 770,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmvatuqe"
      ],
      "typeString": "(searchElement: T, fromIndex?: number) => number",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "771": {
      "id": 771,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlytlamw"
      ],
      "typeString": "(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => boolean",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "772": {
      "id": 772,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlxjv2ym"
      ],
      "typeString": "(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) => boolean",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "773": {
      "id": 773,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn8s9ogm"
      ],
      "typeString": "(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any) => void",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "774": {
      "id": 774,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmme78gw"
      ],
      "typeString": "<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "775": {
      "id": 775,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "776": {
      "id": 776,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        775
      ],
      "stringIndexType": [
        "type",
        775
      ]
    },
    "777": {
      "id": 777,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmn8jepo"
      ],
      "typeString": "{ <S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[]; (callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[]; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "778": {
      "id": 778,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna073bo"
      ],
      "typeString": "S",
      "flags": "TypeParameter"
    },
    "779": {
      "id": 779,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "S[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        778
      ],
      "stringIndexType": [
        "type",
        778
      ]
    },
    "780": {
      "id": 780,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm6qd9wy"
      ],
      "typeString": "{ (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "781": {
      "id": 781,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "782": {
      "id": 782,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmbhnx71"
      ],
      "typeString": "{ (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T; (callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T; <U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "783": {
      "id": 783,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "784": {
      "id": 784,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnbxntfk"
      ],
      "typeString": "{ <S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S; (predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "785": {
      "id": 785,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna073bo"
      ],
      "typeString": "S",
      "flags": "TypeParameter"
    },
    "786": {
      "id": 786,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm5jfv0y"
      ],
      "typeString": "(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any) => number",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "787": {
      "id": 787,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmer9t1s"
      ],
      "typeString": "(value: T, start?: number, end?: number) => this",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "788": {
      "id": 788,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmtoxccq"
      ],
      "typeString": "(target: number, start: number, end?: number) => this",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "789": {
      "id": 789,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmma0hkg"
      ],
      "typeString": "() => IterableIterator<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "790": {
      "id": 790,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlwcxo1c"
      ],
      "typeString": "IterableIterator<T>",
      "flags": "Object",
      "objectFlags": [
        "Interface",
        "Reference"
      ],
      "baseTypes": []
    },
    "793": {
      "id": 793,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlwcxo1c"
      ],
      "typeString": "IterableIterator<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "794": {
      "id": 794,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmi4ninj"
      ],
      "typeString": "() => IterableIterator<[number, T]>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "796": {
      "id": 796,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlwcxo1c"
      ],
      "typeString": "IterableIterator<[number, T]>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "797": {
      "id": 797,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm6b08cx"
      ],
      "typeString": "() => IterableIterator<number>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "798": {
      "id": 798,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlwcxo1c"
      ],
      "typeString": "IterableIterator<number>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "799": {
      "id": 799,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm9dljbw"
      ],
      "typeString": "() => IterableIterator<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "800": {
      "id": 800,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnvtmkv1"
      ],
      "typeString": "() => { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "801": {
      "id": 801,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "{ copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "802": {
      "id": 802,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn98mq4g"
      ],
      "typeString": "(searchElement: T, fromIndex?: number) => boolean",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "803": {
      "id": 803,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wllkm4n4"
      ],
      "typeString": "<U, This = undefined>(callback: (this: This, value: T, index: number, array: T[]) => U | ReadonlyArray<U>, thisArg?: This) => U[]",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "804": {
      "id": 804,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "805": {
      "id": 805,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmo8h8qc"
      ],
      "typeString": "This",
      "flags": "TypeParameter",
      "defaultType": [
        "type",
        6
      ]
    },
    "806": {
      "id": 806,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        804
      ],
      "stringIndexType": [
        "type",
        804
      ]
    },
    "807": {
      "id": 807,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmsm7ofa"
      ],
      "typeString": "{ <U>(this: U[][][][][][][][], depth: 7): U[]; <U>(this: U[][][][][][][], depth: 6): U[]; <U>(this: U[][][][][][], depth: 5): U[]; <U>(this: U[][][][][], depth: 4): U[]; <U>(this: U[][][][], depth: 3): U[]; <U>(this: U[][][], depth: 2): U[]; <U>(this: U[][], depth?: 1): U[]; <U>(this: U[], depth: 0): U[]; <U>(depth?...",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "808": {
      "id": 808,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "809": {
      "id": 809,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "810": {
      "id": 810,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "811": {
      "id": 811,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "812": {
      "id": 812,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "813": {
      "id": 813,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "814": {
      "id": 814,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "815": {
      "id": 815,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "816": {
      "id": 816,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "817": {
      "id": 817,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        808
      ],
      "stringIndexType": [
        "type",
        808
      ]
    },
    "818": {
      "id": 818,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        809
      ],
      "stringIndexType": [
        "type",
        809
      ]
    },
    "819": {
      "id": 819,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        810
      ],
      "stringIndexType": [
        "type",
        810
      ]
    },
    "820": {
      "id": 820,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        811
      ],
      "stringIndexType": [
        "type",
        811
      ]
    },
    "821": {
      "id": 821,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        812
      ],
      "stringIndexType": [
        "type",
        812
      ]
    },
    "822": {
      "id": 822,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        813
      ],
      "stringIndexType": [
        "type",
        813
      ]
    },
    "823": {
      "id": 823,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        814
      ],
      "stringIndexType": [
        "type",
        814
      ]
    },
    "824": {
      "id": 824,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        815
      ],
      "stringIndexType": [
        "type",
        815
      ]
    },
    "826": {
      "id": 826,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "828": {
      "id": 828,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmqfcgkk"
      ],
      "typeString": "ConcatArray<T>",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        49
      ],
      "stringIndexType": [
        "type",
        49
      ]
    },
    "829": {
      "id": 829,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "ConcatArray<T>[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        828
      ],
      "stringIndexType": [
        "type",
        828
      ]
    },
    "830": {
      "id": 830,
      "thing": "type",
      "typeString": "T | ConcatArray<T>",
      "flags": "Union"
    },
    "831": {
      "id": 831,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "(T | ConcatArray<T>)[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        830
      ],
      "stringIndexType": [
        "type",
        830
      ]
    },
    "832": {
      "id": 832,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(a: T, b: T) => number",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "833": {
      "id": 833,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, array: T[]) => boolean",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "834": {
      "id": 834,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, array: T[]) => boolean",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "835": {
      "id": 835,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, array: T[]) => void",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "836": {
      "id": 836,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, array: T[]) => U",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "837": {
      "id": 837,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, array: T[]) => value is S",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "838": {
      "id": 838,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, array: T[]) => any",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "839": {
      "id": 839,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "840": {
      "id": 840,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "841": {
      "id": 841,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "842": {
      "id": 842,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "843": {
      "id": 843,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "844": {
      "id": 844,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "845": {
      "id": 845,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(this: void, value: T, index: number, obj: T[]) => value is S",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "846": {
      "id": 846,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, obj: T[]) => boolean",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "847": {
      "id": 847,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(value: T, index: number, obj: T[]) => boolean",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "848": {
      "id": 848,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(this: This, value: T, index: number, array: T[]) => U | ReadonlyArray<U>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "850": {
      "id": 850,
      "thing": "type",
      "typeString": "U | ReadonlyArray<U>",
      "flags": "Union"
    },
    "856": {
      "id": 856,
      "thing": "type",
      "typeString": "1",
      "flags": "NumberLiteral"
    },
    "858": {
      "id": 858,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        49
      ],
      "stringIndexType": [
        "type",
        49
      ]
    },
    "859": {
      "id": 859,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wncusthw"
      ],
      "typeString": "Iterator<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "894": {
      "id": 894,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wlsg06wc"
      ],
      "typeString": "(arg: any) => arg is any[]",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "895": {
      "id": 895,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm7xanqy"
      ],
      "typeString": "{ <T>(arrayLike: ArrayLike<T>): T[]; <T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; <T>(iterable: Iterable<T> | ArrayLike<T>): T[]; <T, U>(iterable: Iterable<T> | ArrayLike<...>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "896": {
      "id": 896,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "897": {
      "id": 897,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "898": {
      "id": 898,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "899": {
      "id": 899,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "900": {
      "id": 900,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "901": {
      "id": 901,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnajqurf"
      ],
      "typeString": "U",
      "flags": "TypeParameter"
    },
    "902": {
      "id": 902,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        896
      ],
      "stringIndexType": [
        "type",
        896
      ]
    },
    "903": {
      "id": 903,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        898
      ],
      "stringIndexType": [
        "type",
        898
      ]
    },
    "904": {
      "id": 904,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        899
      ],
      "stringIndexType": [
        "type",
        899
      ]
    },
    "905": {
      "id": 905,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "U[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        901
      ],
      "stringIndexType": [
        "type",
        901
      ]
    },
    "906": {
      "id": 906,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmdspvyi"
      ],
      "typeString": "<T>(...items: T[]) => T[]",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "907": {
      "id": 907,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wna9yh22"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "908": {
      "id": 908,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        907
      ],
      "stringIndexType": [
        "type",
        907
      ]
    },
    "909": {
      "id": 909,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wllvsff8"
      ],
      "typeString": "{ (value?: any): IteratorResult<T>; (value?: any): IteratorResult<T>; }",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "911": {
      "id": 911,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnhowbqm"
      ],
      "typeString": "T",
      "flags": "TypeParameter"
    },
    "913": {
      "id": 913,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wll81vyk"
      ],
      "typeString": "IteratorResult<T>",
      "flags": "Object",
      "objectFlags": "Reference"
    },
    "914": {
      "id": 914,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnooh505"
      ],
      "typeString": "(value?: any) => IteratorResult<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "915": {
      "id": 915,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wn14xd06"
      ],
      "typeString": "(e?: any) => IteratorResult<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "916": {
      "id": 916,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmle9efo"
      ],
      "typeString": "() => IterableIterator<T>",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "917": {
      "id": 917,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmjbkwk2"
      ],
      "typeString": "(separator?: string) => string",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "918": {
      "id": 918,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmrrui68"
      ],
      "typeString": "(start?: number, end?: number) => T[]",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "919": {
      "id": 919,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wm0bd96q"
      ],
      "typeString": "T[]",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        826
      ],
      "stringIndexType": [
        "type",
        826
      ]
    },
    "923": {
      "id": 923,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnf89p62"
      ],
      "typeString": "ArrayLike<T>",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        896
      ],
      "stringIndexType": [
        "type",
        896
      ]
    },
    "924": {
      "id": 924,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wnf89p62"
      ],
      "typeString": "ArrayLike<T>",
      "flags": "Object",
      "objectFlags": "Reference",
      "numberIndexType": [
        "type",
        897
      ],
      "stringIndexType": [
        "type",
        897
      ]
    },
    "925": {
      "id": 925,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(v: T, k: number) => U",
      "flags": "Object",
      "objectFlags": "Anonymous"
    },
    "928": {
      "id": 928,
      "thing": "type",
      "typeString": "Iterable<T> | ArrayLike<T>",
      "flags": "Union",
      "constraint": [
        "type",
        928
      ]
    },
    "931": {
      "id": 931,
      "thing": "type",
      "typeString": "Iterable<T> | ArrayLike<T>",
      "flags": "Union",
      "constraint": [
        "type",
        931
      ]
    },
    "932": {
      "id": 932,
      "thing": "type",
      "symbol": [
        "symbol",
        "01m4wmaexabu"
      ],
      "typeString": "(v: T, k: number) => U",
      "flags": "Object",
      "objectFlags": "Anonymous"
    }
  },
  "node": {
    "01m4wn661fce": {
      "id": "01m4wn661fce",
      "pos": 0,
      "end": 112,
      "text": "export interface VehicleLike {\n  /**\n   * Start driving\n   */\n  drive(): void;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wnff99qd"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wnff99qd"
      ]
    },
    "01m4wmmjrvpn": {
      "id": "01m4wmmjrvpn",
      "pos": 112,
      "end": 234,
      "text": "export type VehicleFactory<N extends number> = new (\n  numWheels: N,\n) => VehicleLike;",
      "sourceFile": [
        "sourceFile",
        "01m4wnff99qd"
      ],
      "thing": "node",
      "kind": "TypeAliasDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wnff99qd"
      ]
    },
    "01m4wnmkepxu": {
      "id": "01m4wnmkepxu",
      "pos": 54,
      "end": 429,
      "text": "export default class Vehicle implements VehicleLike {\n  /**\n   * Create a new vehicle\n   * @param {number} numWheels Number of wheels\n   */\n  constructor(protected numWheels: number) {}\n  /**\n   * Drive the vehicle\n   * @returns {string}\n   */\n  public drive() {\n    return `Driving with all ${this.numWheels} wheels`;\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlu7hcxf"
      ],
      "thing": "node",
      "kind": "ClassDeclaration",
      "modifiers": [
        "ExportKeyword",
        "DefaultKeyword"
      ],
      "parent": [
        "node",
        "01m4wlu7hcxf"
      ],
      "name": "Vehicle",
      "type": [
        "type",
        72
      ]
    },
    "01m4wnhowcn6": {
      "id": "01m4wnhowcn6",
      "pos": 32,
      "end": 148,
      "text": "export class Bike extends Vehicle {\n  constructor() {\n    super(2);\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmg3dxx8"
      ],
      "thing": "node",
      "kind": "ClassDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wmg3dxx8"
      ],
      "name": "Bike",
      "type": [
        "type",
        81
      ]
    },
    "01m4wmxuabg6": {
      "id": "01m4wmxuabg6",
      "pos": 148,
      "end": 321,
      "text": "export class Unicycle extends Vehicle {\n  constructor() {\n    super(1);\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmg3dxx8"
      ],
      "thing": "node",
      "kind": "ClassDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wmg3dxx8"
      ],
      "name": "Unicycle",
      "type": [
        "type",
        85
      ]
    },
    "01m4wmyeu4oh": {
      "id": "01m4wmyeu4oh",
      "pos": 32,
      "end": 188,
      "text": "export default class Car extends Vehicle {\n  /**\n   * Create a new car\n   */\n  constructor() {\n    super(4);\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmnl4m34"
      ],
      "thing": "node",
      "kind": "ClassDeclaration",
      "modifiers": [
        "ExportKeyword",
        "DefaultKeyword"
      ],
      "parent": [
        "node",
        "01m4wmnl4m34"
      ],
      "name": "Car",
      "type": [
        "type",
        89
      ]
    },
    "01m4wlorf6g7": {
      "id": "01m4wlorf6g7",
      "pos": 65,
      "end": 204,
      "text": "export function add(a: number, b: number): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "FunctionDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "add",
      "type": [
        "type",
        92
      ]
    },
    "01m4wna76n7c": {
      "id": "01m4wna76n7c",
      "pos": 204,
      "end": 255,
      "text": "export function add(a: string, b: string): string;",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "FunctionDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "add",
      "type": [
        "type",
        92
      ]
    },
    "01m4wnso8fts": {
      "id": "01m4wnso8fts",
      "pos": 255,
      "end": 448,
      "text": "export function add(a: number | string, b: number | string): number | string {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  } else {\n    return '' + a + b;\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "FunctionDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "add",
      "type": [
        "type",
        92
      ]
    },
    "01m4wno7p69a": {
      "id": "01m4wno7p69a",
      "pos": 612,
      "end": 843,
      "text": "class VehicleUtils {\n  /**\n   * Static things\n   */\n  public static description: 'Utilities for vehicles';\n  /**\n   * Members\n   */\n  public memberFn() {\n    return '';\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "ClassDeclaration",
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "VehicleUtils",
      "type": [
        "type",
        96
      ]
    },
    "01m4wlrd9j0i": {
      "id": "01m4wlrd9j0i",
      "pos": 843,
      "end": 1013,
      "text": "namespace VehicleUtils {\n  /**\n   * Create a new bike\n   */\n  export function createBike(): Bike {\n    return new Bike();\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "ModuleDeclaration",
      "flags": "Namespace",
      "parent": [
        "node",
        "01m4wlr69xyn"
      ]
    },
    "01m4wm2gtk7p": {
      "id": "01m4wm2gtk7p",
      "pos": 1092,
      "end": 1308,
      "text": "function timeout(n: number) {\n  return new Promise<void>(resolve => setTimeout(resolve, n));\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "FunctionDeclaration",
      "parent": [
        "node",
        "01m4wlr69xyn"
      ],
      "name": "timeout",
      "type": [
        "type",
        101
      ]
    },
    "01m4wnff99qd": {
      "id": "01m4wnff99qd",
      "pos": 0,
      "end": 235,
      "text": "export interface VehicleLike {\n  /**\n   * Start driving\n   */\n  drive(): void;\n}\n\n/**\n * A factory for vehicles\n */\nexport type VehicleFactory<N extends number> = new (\n  numWheels: N,\n) => VehicleLike;\n",
      "sourceFile": [
        "sourceFile",
        "01m4wnff99qd"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wn661fce"
        ],
        [
          "node",
          "01m4wmmjrvpn"
        ]
      ]
    },
    "01m4wlu7hcxf": {
      "id": "01m4wlu7hcxf",
      "pos": 0,
      "end": 483,
      "text": "import { VehicleFactory, VehicleLike } from \"./types\";\n\n/**\n * A vehicle is a thing that goes places\n */\nexport default class Vehicle implements VehicleLike {\n  /**\n   * Create a new vehicle\n   * @param {number} numWheels Number of wheels\n   */\n  constructor(protected numWheels: number) {}\n  /**\n   * Drive the vehicle\n   * @returns {string}\n   */\n  public drive() {\n    return `Driving with all ${this.numWheels} wheels`;\n  }\n}\n\nexport const Factory4: VehicleFactory<4> = Vehicle;\n",
      "sourceFile": [
        "sourceFile",
        "01m4wlu7hcxf"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wnmkepxu"
        ]
      ]
    },
    "01m4wmg3dxx8": {
      "id": "01m4wmg3dxx8",
      "pos": 0,
      "end": 322,
      "text": "import Vehicle from './vehicle';\n\n/**\n * A bike is a 2-wheeled vehicle\n */\nexport class Bike extends Vehicle {\n  constructor() {\n    super(2);\n  }\n}\n\n/**\n * A Unicycle is a 1-wheeled vehicle\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class Unicycle extends Vehicle {\n  constructor() {\n    super(1);\n  }\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmg3dxx8"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wnhowcn6"
        ],
        [
          "node",
          "01m4wmxuabg6"
        ]
      ]
    },
    "01m4wmnl4m34": {
      "id": "01m4wmnl4m34",
      "pos": 0,
      "end": 189,
      "text": "import Vehicle from \"./vehicle\";\n\n/**\n * A car is a 4-wheeled vehicle\n */\nexport default class Car extends Vehicle {\n  /**\n   * Create a new car\n   */\n  constructor() {\n    super(4);\n  }\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmnl4m34"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wmyeu4oh"
        ]
      ]
    },
    "01m4wlr69xyn": {
      "id": "01m4wlr69xyn",
      "pos": 0,
      "end": 1541,
      "text": "import { Bike } from './cycles';\n\n/**\n * Add two numbers together\n * @param a first number\n * @param b second number\n */\nexport function add(a: number, b: number): number;\nexport function add(a: string, b: string): string;\nexport function add(a: number | string, b: number | string): number | string {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  } else {\n    return '' + a + b;\n  }\n}\n\nexport const SECRET_STRING = 'shhhhh!';\n\nexport { default as Car } from './car';\nexport { Unicycle, Bike } from './cycles';\nexport { VehicleLike } from './types';\n\n/**\n * A class that helps with vehicle maintenance\n */\nclass VehicleUtils {\n  /**\n   * Static things\n   */\n  public static description: 'Utilities for vehicles';\n  /**\n   * Members\n   */\n  public memberFn() {\n    return '';\n  }\n}\n\n// tslint:disable-next-line:no-namespace\nnamespace VehicleUtils {\n  /**\n   * Create a new bike\n   */\n  export function createBike(): Bike {\n    return new Bike();\n  }\n}\n\n/**\n * The first bike\n */\nexport const firstBike = VehicleUtils.createBike();\n\n/**\n * Create a promise that resolves after a period of time has elapsed\n * @param n number of milliseconds to wait\n */\nfunction timeout(n: number) {\n  return new Promise<void>(resolve => setTimeout(resolve, n));\n}\n\nexport const bikeNow = timeout(0).then(() => new Bike());\n// Get a bike soon\nexport const bikeSoon = timeout(3000).then(() => new Bike());\n/**\n * Get a bike later\n */\nexport const bikeLater = timeout(10000).then(() => new Bike());\n",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wlorf6g7"
        ],
        [
          "node",
          "01m4wna76n7c"
        ],
        [
          "node",
          "01m4wnso8fts"
        ],
        [
          "node",
          "01m4wno7p69a"
        ],
        [
          "node",
          "01m4wlrd9j0i"
        ],
        [
          "node",
          "01m4wm2gtk7p"
        ]
      ]
    },
    "01m4wn9e8dts": {
      "id": "01m4wn9e8dts",
      "pos": 0,
      "end": 10609,
      "text": "interface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise<any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>]): Promise<[T1, T2, T3, T4]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<T1 | T2 | T3 | T4 | T5 | T6>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<T1 | T2 | T3 | T4 | T5>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<T1 | T2 | T3 | T4>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<T1 | T2 | T3>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<T1 | T2>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: (T | PromiseLike<T>)[]): Promise<T>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject<T = never>(reason?: any): Promise<T>;\n\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\n    /**\n     * Creates a new resolved promise .\n     * @returns A resolved promise.\n     */\n    resolve(): Promise<void>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmvyle70"
      ]
    },
    "01m4wm7qb3gh": {
      "id": "01m4wm7qb3gh",
      "pos": 60253,
      "end": 61276,
      "text": "interface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlpn69il"
      ]
    },
    "01m4wmyvm22v": {
      "id": "01m4wmyvm22v",
      "pos": 0,
      "end": 1360,
      "text": "interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmxj40nf"
      ]
    },
    "01m4wncmfcnd": {
      "id": "01m4wncmfcnd",
      "pos": 1338,
      "end": 1435,
      "text": "executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlvv6pv0"
      ],
      "name": "executor",
      "type": [
        "type",
        105
      ]
    },
    "01m4wntedv7o": {
      "id": "01m4wntedv7o",
      "pos": 908,
      "end": 1013,
      "text": "{\n  /**\n   * Create a new bike\n   */\n  export function createBike(): Bike {\n    return new Bike();\n  }\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "ModuleBlock",
      "parent": [
        "node",
        "01m4wlrd9j0i"
      ],
      "children": [
        [
          "node",
          "01m4wm6gkv1x"
        ]
      ]
    },
    "01m4wlog8ur3": {
      "id": "01m4wlog8ur3",
      "pos": 60732,
      "end": 60781,
      "text": "((value: T) => TResult1 | PromiseLike<TResult1>)",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "ParenthesizedType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm7gip3n"
      ]
    },
    "01m4wmwkk3hw": {
      "id": "01m4wmwkk3hw",
      "pos": 60814,
      "end": 60866,
      "text": "((reason: any) => TResult2 | PromiseLike<TResult2>)",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "ParenthesizedType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmgocmyv"
      ]
    },
    "01m4wng5eplc": {
      "id": "01m4wng5eplc",
      "pos": 61181,
      "end": 61231,
      "text": "((reason: any) => TResult | PromiseLike<TResult>)",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "ParenthesizedType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wndnr3a8"
      ]
    },
    "01m4wmghd3d6": {
      "id": "01m4wmghd3d6",
      "pos": 1313,
      "end": 1326,
      "text": "(() => void)",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "node",
      "kind": "ParenthesizedType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmja70d6"
      ]
    },
    "01m4wnwcsgo8": {
      "id": "01m4wnwcsgo8",
      "pos": 1349,
      "end": 1394,
      "text": "resolve: (value?: T | PromiseLike<T>) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmxdiclu"
      ],
      "name": "resolve",
      "type": [
        "type",
        108
      ]
    },
    "01m4wlperru3": {
      "id": "01m4wlperru3",
      "pos": 1395,
      "end": 1426,
      "text": "reject: (reason?: any) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmxdiclu"
      ],
      "name": "reject",
      "type": [
        "type",
        121
      ]
    },
    "01m4wmvyle70": {
      "id": "01m4wmvyle70",
      "pos": 0,
      "end": 10652,
      "text": "interface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise<any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>]): Promise<[T1, T2, T3, T4]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<T1 | T2 | T3 | T4 | T5 | T6>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<T1 | T2 | T3 | T4 | T5>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<T1 | T2 | T3 | T4>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<T1 | T2 | T3>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<T1 | T2>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: (T | PromiseLike<T>)[]): Promise<T>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject<T = never>(reason?: any): Promise<T>;\n\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\n    /**\n     * Creates a new resolved promise .\n     * @returns A resolved promise.\n     */\n    resolve(): Promise<void>;\n}\n\ndeclare var Promise: PromiseConstructor;\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wlpn69il": {
      "id": "01m4wlpn69il",
      "pos": 0,
      "end": 196217,
      "text": "declare const NaN: number;\ndeclare const Infinity: number;\n\n/**\n  * Evaluates JavaScript code and executes it.\n  * @param x A String value that contains valid JavaScript code.\n  */\ndeclare function eval(x: string): any;\n\n/**\n  * Converts A string to an integer.\n  * @param s A string to convert into a number.\n  * @param radix A value between 2 and 36 that specifies the base of the number in numString.\n  * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n  * All other strings are considered decimal.\n  */\ndeclare function parseInt(s: string, radix?: number): number;\n\n/**\n  * Converts a string to a floating-point number.\n  * @param string A string that contains a floating-point number.\n  */\ndeclare function parseFloat(string: string): number;\n\n/**\n  * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number).\n  * @param number A numeric value.\n  */\ndeclare function isNaN(number: number): boolean;\n\n/**\n  * Determines whether a supplied number is finite.\n  * @param number Any numeric value.\n  */\ndeclare function isFinite(number: number): boolean;\n\n/**\n  * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\n  * @param encodedURI A value representing an encoded URI.\n  */\ndeclare function decodeURI(encodedURI: string): string;\n\n/**\n  * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\n  * @param encodedURIComponent A value representing an encoded URI component.\n  */\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\n\n/**\n  * Encodes a text string as a valid Uniform Resource Identifier (URI)\n  * @param uri A value representing an encoded URI.\n  */\ndeclare function encodeURI(uri: string): string;\n\n/**\n  * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\n  * @param uriComponent A value representing an encoded URI component.\n  */\ndeclare function encodeURIComponent(uriComponent: string): string;\n\n/**\n  * Computes a new string in which certain characters have been replaced by a hexadecimal escape sequence.\n  * @param string A string value\n  */\ndeclare function escape(string: string): string;\n\n/**\n  * Computes a new string in which hexadecimal escape sequences are replaced with the character that it represents.\n  * @param string A string value\n  */\ndeclare function unescape(string: string): string;\n\ninterface Symbol {\n  /** Returns a string representation of an object. */\n  toString(): string;\n\n  /** Returns the primitive value of the specified object. */\n  valueOf(): symbol;\n}\n\ndeclare type PropertyKey = string | number | symbol;\n\ninterface PropertyDescriptor {\n    configurable?: boolean;\n    enumerable?: boolean;\n    value?: any;\n    writable?: boolean;\n    get?(): any;\n    set?(v: any): void;\n}\n\ninterface PropertyDescriptorMap {\n    [s: string]: PropertyDescriptor;\n}\n\ninterface Object {\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\n    constructor: Function;\n\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns a date converted to a string using the current locale. */\n    toLocaleString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Object;\n\n    /**\n      * Determines whether an object has a property with the specified name.\n      * @param v A property name.\n      */\n    hasOwnProperty(v: PropertyKey): boolean;\n\n    /**\n      * Determines whether an object exists in another object's prototype chain.\n      * @param v Another object whose prototype chain is to be checked.\n      */\n    isPrototypeOf(v: Object): boolean;\n\n    /**\n      * Determines whether a specified property is enumerable.\n      * @param v A property name.\n      */\n    propertyIsEnumerable(v: PropertyKey): boolean;\n}\n\ninterface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    /**\n      * Returns the prototype of an object.\n      * @param o The object that references the prototype.\n      */\n    getPrototypeOf(o: any): any;\n\n    /**\n      * Gets the own property descriptor of the specified object.\n      * An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype.\n      * @param o Object that contains the property.\n      * @param p Name of the property.\n    */\n    getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;\n\n    /**\n      * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\n      * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\n      * @param o Object that contains the own properties.\n      */\n    getOwnPropertyNames(o: any): string[];\n\n    /**\n      * Creates an object that has the specified prototype or that has null prototype.\n      * @param o Object to use as a prototype. May be null.\n      */\n    create(o: object | null): any;\n\n    /**\n      * Creates an object that has the specified prototype, and that optionally contains specified properties.\n      * @param o Object to use as a prototype. May be null\n      * @param properties JavaScript object that contains one or more property descriptors.\n      */\n    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Adds a property to an object, or modifies attributes of an existing property.\n      * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.\n      * @param p The property name.\n      * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\n      */\n    defineProperty(o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): any;\n\n    /**\n      * Adds one or more properties to an object, and/or modifies attributes of existing properties.\n      * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.\n      * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.\n      */\n    defineProperties(o: any, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    seal<T>(o: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(a: T[]): ReadonlyArray<T>;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T extends Function>(f: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(o: T): Readonly<T>;\n\n    /**\n      * Prevents the addition of new properties to an object.\n      * @param o Object to make non-extensible.\n      */\n    preventExtensions<T>(o: T): T;\n\n    /**\n      * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isSealed(o: any): boolean;\n\n    /**\n      * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isFrozen(o: any): boolean;\n\n    /**\n      * Returns a value that indicates whether new properties can be added to an object.\n      * @param o Object to test.\n      */\n    isExtensible(o: any): boolean;\n\n    /**\n      * Returns the names of the enumerable properties and methods of an object.\n      * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n      */\n    keys(o: {}): string[];\n}\n\n/**\n  * Provides functionality common to all JavaScript objects.\n  */\ndeclare const Object: ObjectConstructor;\n\n/**\n  * Creates a new function.\n  */\ninterface Function {\n    /**\n      * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n      * @param thisArg The object to be used as the this object.\n      * @param argArray A set of arguments to be passed to the function.\n      */\n    apply(this: Function, thisArg: any, argArray?: any): any;\n\n    /**\n      * Calls a method of an object, substituting another object for the current object.\n      * @param thisArg The object to be used as the current object.\n      * @param argArray A list of arguments to be passed to the method.\n      */\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /**\n      * For a given function, creates a bound function that has the same body as the original function.\n      * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n      * @param thisArg An object to which the this keyword can refer inside the new function.\n      * @param argArray A list of arguments to be passed to the new function.\n      */\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /** Returns a string representation of a function. */\n    toString(): string;\n\n    prototype: any;\n    readonly length: number;\n\n    // Non-standard extensions\n    arguments: any;\n    caller: Function;\n}\n\ninterface FunctionConstructor {\n    /**\n      * Creates a new function.\n      * @param args A list of arguments the function accepts.\n      */\n    new(...args: string[]): Function;\n    (...args: string[]): Function;\n    readonly prototype: Function;\n}\n\ndeclare const Function: FunctionConstructor;\n\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n\ninterface String {\n    /** Returns a string representation of a string. */\n    toString(): string;\n\n    /**\n      * Returns the character at the specified index.\n      * @param pos The zero-based index of the desired character.\n      */\n    charAt(pos: number): string;\n\n    /**\n      * Returns the Unicode value of the character at the specified location.\n      * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n      */\n    charCodeAt(index: number): number;\n\n    /**\n      * Returns a string that contains the concatenation of two or more strings.\n      * @param strings The strings to append to the end of the string.\n      */\n    concat(...strings: string[]): string;\n\n    /**\n      * Returns the position of the first occurrence of a substring.\n      * @param searchString The substring to search for in the string\n      * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\n      */\n    indexOf(searchString: string, position?: number): number;\n\n    /**\n      * Returns the last occurrence of a substring in the string.\n      * @param searchString The substring to search for.\n      * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n      */\n    lastIndexOf(searchString: string, position?: number): number;\n\n    /**\n      * Determines whether two strings are equivalent in the current locale.\n      * @param that String to compare to target string\n      */\n    localeCompare(that: string): number;\n\n    /**\n      * Matches a string with a regular expression, and returns an array containing the results of that search.\n      * @param regexp A variable name or string literal containing the regular expression pattern and flags.\n      */\n    match(regexp: string | RegExp): RegExpMatchArray | null;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n      */\n    replace(searchValue: string | RegExp, replaceValue: string): string;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replacer A function that returns the replacement text.\n      */\n    replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n      * Finds the first substring match in a regular expression search.\n      * @param regexp The regular expression pattern and applicable flags.\n      */\n    search(regexp: string | RegExp): number;\n\n    /**\n      * Returns a section of a string.\n      * @param start The index to the beginning of the specified portion of stringObj.\n      * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\n      * If this value is not specified, the substring continues to the end of stringObj.\n      */\n    slice(start?: number, end?: number): string;\n\n    /**\n      * Split a string into substrings using the specified separator and return them as an array.\n      * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\n      * @param limit A value used to limit the number of elements returned in the array.\n      */\n    split(separator: string | RegExp, limit?: number): string[];\n\n    /**\n      * Returns the substring at the specified location within a String object.\n      * @param start The zero-based index number indicating the beginning of the substring.\n      * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\n      * If end is omitted, the characters from start through the end of the original string are returned.\n      */\n    substring(start: number, end?: number): string;\n\n    /** Converts all the alphabetic characters in a string to lowercase. */\n    toLowerCase(): string;\n\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */\n    toLocaleLowerCase(): string;\n\n    /** Converts all the alphabetic characters in a string to uppercase. */\n    toUpperCase(): string;\n\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */\n    toLocaleUpperCase(): string;\n\n    /** Removes the leading and trailing white space and line terminator characters from a string. */\n    trim(): string;\n\n    /** Returns the length of a String object. */\n    readonly length: number;\n\n    // IE extensions\n    /**\n      * Gets a substring beginning at the specified location and having the specified length.\n      * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n      * @param length The number of characters to include in the returned substring.\n      */\n    substr(from: number, length?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): string;\n\n    readonly [index: number]: string;\n}\n\ninterface StringConstructor {\n    new(value?: any): String;\n    (value?: any): string;\n    readonly prototype: String;\n    fromCharCode(...codes: number[]): string;\n}\n\n/**\n  * Allows manipulation and formatting of text strings and determination and location of substrings within strings.\n  */\ndeclare const String: StringConstructor;\n\ninterface Boolean {\n    /** Returns the primitive value of the specified object. */\n    valueOf(): boolean;\n}\n\ninterface BooleanConstructor {\n    new(value?: any): Boolean;\n    (value?: any): boolean;\n    readonly prototype: Boolean;\n}\n\ndeclare const Boolean: BooleanConstructor;\n\ninterface Number {\n    /**\n      * Returns a string representation of an object.\n      * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.\n      */\n    toString(radix?: number): string;\n\n    /**\n      * Returns a string representing a number in fixed-point notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toFixed(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented in exponential notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toExponential(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n      * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.\n      */\n    toPrecision(precision?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): number;\n}\n\ninterface NumberConstructor {\n    new(value?: any): Number;\n    (value?: any): number;\n    readonly prototype: Number;\n\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\n    readonly MAX_VALUE: number;\n\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\n    readonly MIN_VALUE: number;\n\n    /**\n      * A value that is not a number.\n      * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\n      */\n    readonly NaN: number;\n\n    /**\n      * A value that is less than the largest negative number that can be represented in JavaScript.\n      * JavaScript displays NEGATIVE_INFINITY values as -infinity.\n      */\n    readonly NEGATIVE_INFINITY: number;\n\n    /**\n      * A value greater than the largest number that can be represented in JavaScript.\n      * JavaScript displays POSITIVE_INFINITY values as infinity.\n      */\n    readonly POSITIVE_INFINITY: number;\n}\n\n/** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */\ndeclare const Number: NumberConstructor;\n\ninterface TemplateStringsArray extends ReadonlyArray<string> {\n    readonly raw: ReadonlyArray<string>;\n}\n\n/**\n * The type of `import.meta`.\n * \n * If you need to declare that a given property exists on `import.meta`,\n * this type may be augmented via interface merging.\n */\ninterface ImportMeta {\n}\n\ninterface Math {\n    /** The mathematical constant e. This is Euler's number, the base of natural logarithms. */\n    readonly E: number;\n    /** The natural logarithm of 10. */\n    readonly LN10: number;\n    /** The natural logarithm of 2. */\n    readonly LN2: number;\n    /** The base-2 logarithm of e. */\n    readonly LOG2E: number;\n    /** The base-10 logarithm of e. */\n    readonly LOG10E: number;\n    /** Pi. This is the ratio of the circumference of a circle to its diameter. */\n    readonly PI: number;\n    /** The square root of 0.5, or, equivalently, one divided by the square root of 2. */\n    readonly SQRT1_2: number;\n    /** The square root of 2. */\n    readonly SQRT2: number;\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    abs(x: number): number;\n    /**\n      * Returns the arc cosine (or inverse cosine) of a number.\n      * @param x A numeric expression.\n      */\n    acos(x: number): number;\n    /**\n      * Returns the arcsine of a number.\n      * @param x A numeric expression.\n      */\n    asin(x: number): number;\n    /**\n      * Returns the arctangent of a number.\n      * @param x A numeric expression for which the arctangent is needed.\n      */\n    atan(x: number): number;\n    /**\n      * Returns the angle (in radians) from the X axis to a point.\n      * @param y A numeric expression representing the cartesian y-coordinate.\n      * @param x A numeric expression representing the cartesian x-coordinate.\n      */\n    atan2(y: number, x: number): number;\n    /**\n      * Returns the smallest integer greater than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    ceil(x: number): number;\n    /**\n      * Returns the cosine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    cos(x: number): number;\n    /**\n      * Returns e (the base of natural logarithms) raised to a power.\n      * @param x A numeric expression representing the power of e.\n      */\n    exp(x: number): number;\n    /**\n      * Returns the greatest integer less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    floor(x: number): number;\n    /**\n      * Returns the natural logarithm (base e) of a number.\n      * @param x A numeric expression.\n      */\n    log(x: number): number;\n    /**\n      * Returns the larger of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    max(...values: number[]): number;\n    /**\n      * Returns the smaller of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    min(...values: number[]): number;\n    /**\n      * Returns the value of a base expression taken to a specified power.\n      * @param x The base value of the expression.\n      * @param y The exponent value of the expression.\n      */\n    pow(x: number, y: number): number;\n    /** Returns a pseudorandom number between 0 and 1. */\n    random(): number;\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    round(x: number): number;\n    /**\n      * Returns the sine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    sin(x: number): number;\n    /**\n      * Returns the square root of a number.\n      * @param x A numeric expression.\n      */\n    sqrt(x: number): number;\n    /**\n      * Returns the tangent of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    tan(x: number): number;\n}\n/** An intrinsic object that provides basic mathematics functionality and constants. */\ndeclare const Math: Math;\n\n/** Enables basic storage and retrieval of dates and times. */\ninterface Date {\n    /** Returns a string representation of a date. The format of the string depends on the locale. */\n    toString(): string;\n    /** Returns a date as a string value. */\n    toDateString(): string;\n    /** Returns a time as a string value. */\n    toTimeString(): string;\n    /** Returns a value as a string value appropriate to the host environment's current locale. */\n    toLocaleString(): string;\n    /** Returns a date as a string value appropriate to the host environment's current locale. */\n    toLocaleDateString(): string;\n    /** Returns a time as a string value appropriate to the host environment's current locale. */\n    toLocaleTimeString(): string;\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\n    valueOf(): number;\n    /** Gets the time value in milliseconds. */\n    getTime(): number;\n    /** Gets the year, using local time. */\n    getFullYear(): number;\n    /** Gets the year using Universal Coordinated Time (UTC). */\n    getUTCFullYear(): number;\n    /** Gets the month, using local time. */\n    getMonth(): number;\n    /** Gets the month of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMonth(): number;\n    /** Gets the day-of-the-month, using local time. */\n    getDate(): number;\n    /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */\n    getUTCDate(): number;\n    /** Gets the day of the week, using local time. */\n    getDay(): number;\n    /** Gets the day of the week using Universal Coordinated Time (UTC). */\n    getUTCDay(): number;\n    /** Gets the hours in a date, using local time. */\n    getHours(): number;\n    /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */\n    getUTCHours(): number;\n    /** Gets the minutes of a Date object, using local time. */\n    getMinutes(): number;\n    /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMinutes(): number;\n    /** Gets the seconds of a Date object, using local time. */\n    getSeconds(): number;\n    /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCSeconds(): number;\n    /** Gets the milliseconds of a Date, using local time. */\n    getMilliseconds(): number;\n    /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMilliseconds(): number;\n    /** Gets the difference in minutes between the time on the local computer and Universal Coordinated Time (UTC). */\n    getTimezoneOffset(): number;\n    /**\n      * Sets the date and time value in the Date object.\n      * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT.\n      */\n    setTime(time: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using local time.\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setMilliseconds(ms: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setUTCMilliseconds(ms: number): number;\n\n    /**\n      * Sets the seconds value in the Date object using local time.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using local time.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hour value in the Date object using local time.\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hours value in the Date object using Universal Coordinated Time (UTC).\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the numeric day-of-the-month value of the Date object using local time.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setDate(date: number): number;\n    /**\n      * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCDate(date: number): number;\n    /**\n      * Sets the month value in the Date object using local time.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.\n      */\n    setMonth(month: number, date?: number): number;\n    /**\n      * Sets the month value in the Date object using Universal Coordinated Time (UTC).\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.\n      */\n    setUTCMonth(month: number, date?: number): number;\n    /**\n      * Sets the year of the Date object using local time.\n      * @param year A numeric value for the year.\n      * @param month A zero-based numeric value for the month (0 for January, 11 for December). Must be specified if numDate is specified.\n      * @param date A numeric value equal for the day of the month.\n      */\n    setFullYear(year: number, month?: number, date?: number): number;\n    /**\n      * Sets the year value in the Date object using Universal Coordinated Time (UTC).\n      * @param year A numeric value equal to the year.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. Must be supplied if numDate is supplied.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCFullYear(year: number, month?: number, date?: number): number;\n    /** Returns a date converted to a string using Universal Coordinated Time (UTC). */\n    toUTCString(): string;\n    /** Returns a date as a string value in ISO format. */\n    toISOString(): string;\n    /** Used by the JSON.stringify method to enable the transformation of an object's data for JavaScript Object Notation (JSON) serialization. */\n    toJSON(key?: any): string;\n}\n\ninterface DateConstructor {\n    new(): Date;\n    new(value: number | string): Date;\n    new(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n    (): string;\n    readonly prototype: Date;\n    /**\n      * Parses a string containing a date, and returns the number of milliseconds between that date and midnight, January 1, 1970.\n      * @param s A date string\n      */\n    parse(s: string): number;\n    /**\n      * Returns the number of milliseconds between midnight, January 1, 1970 Universal Coordinated Time (UTC) (or GMT) and the specified date.\n      * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\n      * @param month The month as an number between 0 and 11 (January to December).\n      * @param date The date as an number between 1 and 31.\n      * @param hours Must be supplied if minutes is supplied. An number from 0 to 23 (midnight to 11pm) that specifies the hour.\n      * @param minutes Must be supplied if seconds is supplied. An number from 0 to 59 that specifies the minutes.\n      * @param seconds Must be supplied if milliseconds is supplied. An number from 0 to 59 that specifies the seconds.\n      * @param ms An number from 0 to 999 that specifies the milliseconds.\n      */\n    UTC(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number;\n    now(): number;\n}\n\ndeclare const Date: DateConstructor;\n\ninterface RegExpMatchArray extends Array<string> {\n    index?: number;\n    input?: string;\n}\n\ninterface RegExpExecArray extends Array<string> {\n    index: number;\n    input: string;\n}\n\ninterface RegExp {\n    /**\n      * Executes a search on a string using a regular expression pattern, and returns an array containing the results of that search.\n      * @param string The String object or string literal on which to perform the search.\n      */\n    exec(string: string): RegExpExecArray | null;\n\n    /**\n      * Returns a Boolean value that indicates whether or not a pattern exists in a searched string.\n      * @param string String on which to perform the search.\n      */\n    test(string: string): boolean;\n\n    /** Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal. */\n    readonly source: string;\n\n    /** Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only. */\n    readonly global: boolean;\n\n    /** Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only. */\n    readonly ignoreCase: boolean;\n\n    /** Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only. */\n    readonly multiline: boolean;\n\n    lastIndex: number;\n\n    // Non-standard extensions\n    compile(): this;\n}\n\ninterface RegExpConstructor {\n    new(pattern: RegExp | string): RegExp;\n    new(pattern: string, flags?: string): RegExp;\n    (pattern: RegExp | string): RegExp;\n    (pattern: string, flags?: string): RegExp;\n    readonly prototype: RegExp;\n\n    // Non-standard extensions\n    $1: string;\n    $2: string;\n    $3: string;\n    $4: string;\n    $5: string;\n    $6: string;\n    $7: string;\n    $8: string;\n    $9: string;\n    lastMatch: string;\n}\n\ndeclare const RegExp: RegExpConstructor;\n\ninterface Error {\n    name: string;\n    message: string;\n    stack?: string;\n}\n\ninterface ErrorConstructor {\n    new(message?: string): Error;\n    (message?: string): Error;\n    readonly prototype: Error;\n}\n\ndeclare const Error: ErrorConstructor;\n\ninterface EvalError extends Error {\n}\n\ninterface EvalErrorConstructor {\n    new(message?: string): EvalError;\n    (message?: string): EvalError;\n    readonly prototype: EvalError;\n}\n\ndeclare const EvalError: EvalErrorConstructor;\n\ninterface RangeError extends Error {\n}\n\ninterface RangeErrorConstructor {\n    new(message?: string): RangeError;\n    (message?: string): RangeError;\n    readonly prototype: RangeError;\n}\n\ndeclare const RangeError: RangeErrorConstructor;\n\ninterface ReferenceError extends Error {\n}\n\ninterface ReferenceErrorConstructor {\n    new(message?: string): ReferenceError;\n    (message?: string): ReferenceError;\n    readonly prototype: ReferenceError;\n}\n\ndeclare const ReferenceError: ReferenceErrorConstructor;\n\ninterface SyntaxError extends Error {\n}\n\ninterface SyntaxErrorConstructor {\n    new(message?: string): SyntaxError;\n    (message?: string): SyntaxError;\n    readonly prototype: SyntaxError;\n}\n\ndeclare const SyntaxError: SyntaxErrorConstructor;\n\ninterface TypeError extends Error {\n}\n\ninterface TypeErrorConstructor {\n    new(message?: string): TypeError;\n    (message?: string): TypeError;\n    readonly prototype: TypeError;\n}\n\ndeclare const TypeError: TypeErrorConstructor;\n\ninterface URIError extends Error {\n}\n\ninterface URIErrorConstructor {\n    new(message?: string): URIError;\n    (message?: string): URIError;\n    readonly prototype: URIError;\n}\n\ndeclare const URIError: URIErrorConstructor;\n\ninterface JSON {\n    /**\n      * Converts a JavaScript Object Notation (JSON) string into an object.\n      * @param text A valid JSON string.\n      * @param reviver A function that transforms the results. This function is called for each member of the object.\n      * If a member contains nested objects, the nested objects are transformed before the parent object is.\n      */\n    parse(text: string, reviver?: (key: any, value: any) => any): any;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer A function that transforms the results.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (key: string, value: any) => any, space?: string | number): string;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer An array of strings and numbers that acts as a approved list for selecting the object properties that will be stringified.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\n}\n\n/**\n  * An intrinsic object that provides functions to convert JavaScript values to and from the JavaScript Object Notation (JSON) format.\n  */\ndeclare const JSON: JSON;\n\n\n/////////////////////////////\n/// ECMAScript Array API (specially handled by compiler)\n/////////////////////////////\n\ninterface ReadonlyArray<T> {\n    /**\n      * Gets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    readonly length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n\n    readonly [n: number]: T;\n}\n\ninterface ConcatArray<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n    join(separator?: string): string;\n    slice(start?: number, end?: number): T[];\n}\n\ninterface Array<T> {\n    /**\n      * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Removes the last element from an array and returns it.\n      */\n    pop(): T | undefined;\n    /**\n      * Appends new elements to an array, and returns the new length of the array.\n      * @param items New elements of the Array.\n      */\n    push(...items: T[]): number;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): T[];\n    /**\n      * Removes the first element from an array and returns it.\n      */\n    shift(): T | undefined;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: T, b: T) => number): this;\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      */\n    splice(start: number, deleteCount?: number): T[];\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      * @param items Elements to insert into the array in place of the deleted elements.\n      */\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    /**\n      * Inserts new elements at the start of an array.\n      * @param items  Elements to insert at the start of the Array.\n      */\n    unshift(...items: T[]): number;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    [n: number]: T;\n}\n\ninterface ArrayConstructor {\n    new(arrayLength?: number): any[];\n    new <T>(arrayLength: number): T[];\n    new <T>(...items: T[]): T[];\n    (arrayLength?: number): any[];\n    <T>(arrayLength: number): T[];\n    <T>(...items: T[]): T[];\n    isArray(arg: any): arg is Array<any>;\n    readonly prototype: Array<any>;\n}\n\ndeclare const Array: ArrayConstructor;\n\ninterface TypedPropertyDescriptor<T> {\n    enumerable?: boolean;\n    configurable?: boolean;\n    writable?: boolean;\n    value?: T;\n    get?: () => T;\n    set?: (value: T) => void;\n}\n\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n\ndeclare type PromiseConstructorLike = new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) => PromiseLike<T>;\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;\n}\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}\n\ninterface ArrayLike<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n}\n\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\n/**\n * Make all properties in T required\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n\n/**\n * Make all properties in T readonly\n */\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n/**\n * From T pick a set of properties K\n */\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n\n/**\n * Extract from T those types that are assignable to U\n */\ntype Extract<T, U> = T extends U ? T : never;\n\n/**\n * Exclude null and undefined from T\n */\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n/**\n * Obtain the parameters of a function type in a tuple\n */\ntype Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the parameters of a constructor function type in a tuple\n */\ntype ConstructorParameters<T extends new (...args: any[]) => any> = T extends new (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;\n\n/**\n * Obtain the return type of a constructor function type\n */\ntype InstanceType<T extends new (...args: any[]) => any> = T extends new (...args: any[]) => infer R ? R : any;\n\n/**\n * Marker for contextual 'this' type\n */\ninterface ThisType<T> { }\n\n/**\n  * Represents a raw buffer of binary data, which is used to store data for the\n  * different typed arrays. ArrayBuffers cannot be read from or written to directly,\n  * but can be passed to a typed array or DataView Object to interpret the raw\n  * buffer as needed.\n  */\ninterface ArrayBuffer {\n    /**\n      * Read-only. The length of the ArrayBuffer (in bytes).\n      */\n    readonly byteLength: number;\n\n    /**\n      * Returns a section of an ArrayBuffer.\n      */\n    slice(begin: number, end?: number): ArrayBuffer;\n}\n\n/**\n * Allowed ArrayBuffer types for the buffer of an ArrayBufferView and related Typed Arrays.\n */\ninterface ArrayBufferTypes {\n    ArrayBuffer: ArrayBuffer;\n}\ntype ArrayBufferLike = ArrayBufferTypes[keyof ArrayBufferTypes];\n\ninterface ArrayBufferConstructor {\n    readonly prototype: ArrayBuffer;\n    new(byteLength: number): ArrayBuffer;\n    isView(arg: any): arg is ArrayBufferView;\n}\ndeclare const ArrayBuffer: ArrayBufferConstructor;\n\ninterface ArrayBufferView {\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    byteOffset: number;\n}\n\ninterface DataView {\n    readonly buffer: ArrayBuffer;\n    readonly byteLength: number;\n    readonly byteOffset: number;\n    /**\n      * Gets the Float32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Float64 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat64(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Int8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt8(byteOffset: number): number;\n\n    /**\n      * Gets the Int16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt16(byteOffset: number, littleEndian?: boolean): number;\n    /**\n      * Gets the Int32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint8(byteOffset: number): number;\n\n    /**\n      * Gets the Uint16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint16(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Stores an Float32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Float64 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat64(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setInt8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Int16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setUint8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Uint16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint32(byteOffset: number, value: number, littleEndian?: boolean): void;\n}\n\ninterface DataViewConstructor {\n    new(buffer: ArrayBufferLike, byteOffset?: number, byteLength?: number): DataView;\n}\ndeclare const DataView: DataViewConstructor;\n\n/**\n  * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Int8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int8Array) => any, thisArg?: any): Int8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int8Array) => number, thisArg?: any): Int8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\ninterface Int8ArrayConstructor {\n    readonly prototype: Int8Array;\n    new(length: number): Int8Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int8Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int8Array;\n\n\n}\ndeclare const Int8Array: Int8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8Array) => any, thisArg?: any): Uint8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any): Uint8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ArrayConstructor {\n    readonly prototype: Uint8Array;\n    new(length: number): Uint8Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint8Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8Array;\n\n}\ndeclare const Uint8Array: Uint8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\n  * If the requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8ClampedArray {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => any, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => number, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8ClampedArray;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8ClampedArray view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    readonly prototype: Uint8ClampedArray;\n    new(length: number): Uint8ClampedArray;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint8ClampedArray;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint8ClampedArray;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8ClampedArray;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\ndeclare const Uint8ClampedArray: Uint8ClampedArrayConstructor;\n\n/**\n  * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int16Array) => any, thisArg?: any): Int16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int16Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int16Array) => number, thisArg?: any): Int16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int16ArrayConstructor {\n    readonly prototype: Int16Array;\n    new(length: number): Int16Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int16Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int16Array;\n\n\n}\ndeclare const Int16Array: Int16ArrayConstructor;\n\n/**\n  * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint16Array) => any, thisArg?: any): Uint16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint16Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint16Array) => number, thisArg?: any): Uint16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint16ArrayConstructor {\n    readonly prototype: Uint16Array;\n    new(length: number): Uint16Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint16Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint16Array;\n\n\n}\ndeclare const Uint16Array: Uint16ArrayConstructor;\n/**\n  * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int32Array) => any, thisArg?: any): Int32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int32Array) => number, thisArg?: any): Int32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int32ArrayConstructor {\n    readonly prototype: Int32Array;\n    new(length: number): Int32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int32Array;\n\n}\ndeclare const Int32Array: Int32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint32Array) => any, thisArg?: any): Uint32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint32Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint32Array) => number, thisArg?: any): Uint32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint32ArrayConstructor {\n    readonly prototype: Uint32Array;\n    new(length: number): Uint32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint32Array;\n\n}\ndeclare const Uint32Array: Uint32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\n  * of bytes could not be allocated an exception is raised.\n  */\ninterface Float32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float32Array) => any, thisArg?: any): Float32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any): Float32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float32ArrayConstructor {\n    readonly prototype: Float32Array;\n    new(length: number): Float32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Float32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Float32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float32Array;\n\n\n}\ndeclare const Float32Array: Float32ArrayConstructor;\n\n/**\n  * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Float64Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float64Array) => any, thisArg?: any): Float64Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float64Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Float64Array) => number, thisArg?: any): Float64Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float64Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float64Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float64Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float64Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float64ArrayConstructor {\n    readonly prototype: Float64Array;\n    new(length: number): Float64Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Float64Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Float64Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float64Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float64Array;\n\n}\ndeclare const Float64Array: Float64ArrayConstructor;\n\n/////////////////////////////\n/// ECMAScript Internationalization API\n/////////////////////////////\n\ndeclare namespace Intl {\n    interface CollatorOptions {\n        usage?: string;\n        localeMatcher?: string;\n        numeric?: boolean;\n        caseFirst?: string;\n        sensitivity?: string;\n        ignorePunctuation?: boolean;\n    }\n\n    interface ResolvedCollatorOptions {\n        locale: string;\n        usage: string;\n        sensitivity: string;\n        ignorePunctuation: boolean;\n        collation: string;\n        caseFirst: string;\n        numeric: boolean;\n    }\n\n    interface Collator {\n        compare(x: string, y: string): number;\n        resolvedOptions(): ResolvedCollatorOptions;\n    }\n    var Collator: {\n        new(locales?: string | string[], options?: CollatorOptions): Collator;\n        (locales?: string | string[], options?: CollatorOptions): Collator;\n        supportedLocalesOf(locales: string | string[], options?: CollatorOptions): string[];\n    };\n\n    interface NumberFormatOptions {\n        localeMatcher?: string;\n        style?: string;\n        currency?: string;\n        currencyDisplay?: string;\n        useGrouping?: boolean;\n        minimumIntegerDigits?: number;\n        minimumFractionDigits?: number;\n        maximumFractionDigits?: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n    }\n\n    interface ResolvedNumberFormatOptions {\n        locale: string;\n        numberingSystem: string;\n        style: string;\n        currency?: string;\n        currencyDisplay?: string;\n        minimumIntegerDigits: number;\n        minimumFractionDigits: number;\n        maximumFractionDigits: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n        useGrouping: boolean;\n    }\n\n    interface NumberFormat {\n        format(value: number): string;\n        resolvedOptions(): ResolvedNumberFormatOptions;\n    }\n    var NumberFormat: {\n        new(locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        (locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        supportedLocalesOf(locales: string | string[], options?: NumberFormatOptions): string[];\n    };\n\n    interface DateTimeFormatOptions {\n        localeMatcher?: string;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n        formatMatcher?: string;\n        hour12?: boolean;\n        timeZone?: string;\n    }\n\n    interface ResolvedDateTimeFormatOptions {\n        locale: string;\n        calendar: string;\n        numberingSystem: string;\n        timeZone: string;\n        hour12?: boolean;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n    }\n\n    interface DateTimeFormat {\n        format(date?: Date | number): string;\n        resolvedOptions(): ResolvedDateTimeFormatOptions;\n    }\n    var DateTimeFormat: {\n        new(locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        (locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        supportedLocalesOf(locales: string | string[], options?: DateTimeFormatOptions): string[];\n    };\n}\n\ninterface String {\n    /**\n      * Determines whether two strings are equivalent in the current or specified locale.\n      * @param that String to compare to target string\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\n      * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\n      */\n    localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;\n}\n\ninterface Number {\n    /**\n      * Converts a number to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Date {\n    /**\n      * Converts a date and time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n    /**\n      * Converts a date to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n\n    /**\n      * Converts a time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wmxj40nf": {
      "id": "01m4wmxj40nf",
      "pos": 0,
      "end": 1361,
      "text": "interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wlvv6pv0": {
      "id": "01m4wlvv6pv0",
      "pos": 983,
      "end": 1449,
      "text": "new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "node",
      "kind": "ConstructSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9e8dts"
      ]
    },
    "01m4wm6gkv1x": {
      "id": "01m4wm6gkv1x",
      "pos": 910,
      "end": 1011,
      "text": "export function createBike(): Bike {\n    return new Bike();\n  }",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "node",
      "kind": "FunctionDeclaration",
      "modifiers": [
        "ExportKeyword"
      ],
      "parent": [
        "node",
        "01m4wntedv7o"
      ],
      "name": "createBike",
      "type": [
        "type",
        99
      ]
    },
    "01m4wm7gip3n": {
      "id": "01m4wm7gip3n",
      "pos": 60732,
      "end": 60800,
      "text": "((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "UnionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnspmcxw"
      ]
    },
    "01m4wmgocmyv": {
      "id": "01m4wmgocmyv",
      "pos": 60814,
      "end": 60885,
      "text": "((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "UnionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlqg4ipx"
      ]
    },
    "01m4wndnr3a8": {
      "id": "01m4wndnr3a8",
      "pos": 61181,
      "end": 61250,
      "text": "((reason: any) => TResult | PromiseLike<TResult>) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "UnionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlys7d93"
      ]
    },
    "01m4wmja70d6": {
      "id": "01m4wmja70d6",
      "pos": 1313,
      "end": 1345,
      "text": "(() => void) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "node",
      "kind": "UnionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlt3cs76"
      ]
    },
    "01m4wmxdiclu": {
      "id": "01m4wmxdiclu",
      "pos": 1347,
      "end": 1435,
      "text": "(resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "node",
      "kind": "FunctionType",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wncmfcnd"
      ]
    },
    "01m4wnspmcxw": {
      "id": "01m4wnspmcxw",
      "pos": 60719,
      "end": 60800,
      "text": "onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnjf0l7m"
      ],
      "name": "onfulfilled",
      "type": [
        "type",
        133
      ]
    },
    "01m4wlqg4ipx": {
      "id": "01m4wlqg4ipx",
      "pos": 60801,
      "end": 60885,
      "text": "onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnjf0l7m"
      ],
      "name": "onrejected",
      "type": [
        "type",
        170
      ]
    },
    "01m4wlys7d93": {
      "id": "01m4wlys7d93",
      "pos": 61169,
      "end": 61250,
      "text": "onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmd7r6vt"
      ],
      "name": "onrejected",
      "type": [
        "type",
        173
      ]
    },
    "01m4wlt3cs76": {
      "id": "01m4wlt3cs76",
      "pos": 1302,
      "end": 1345,
      "text": "onfinally?: (() => void) | undefined | null",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wluttyqs"
      ],
      "name": "onfinally",
      "type": [
        "type",
        176
      ]
    },
    "01m4wnjf0l7m": {
      "id": "01m4wnjf0l7m",
      "pos": 60343,
      "end": 60917,
      "text": "then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm7qb3gh"
      ],
      "name": "then",
      "type": [
        "type",
        127
      ]
    },
    "01m4wmd7r6vt": {
      "id": "01m4wmd7r6vt",
      "pos": 60917,
      "end": 61274,
      "text": "catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm7qb3gh"
      ],
      "name": "catch",
      "type": [
        "type",
        159
      ]
    },
    "01m4wluttyqs": {
      "id": "01m4wluttyqs",
      "pos": 950,
      "end": 1358,
      "text": "finally(onfinally?: (() => void) | undefined | null): Promise<T>",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmyvm22v"
      ],
      "name": "finally",
      "type": [
        "type",
        165
      ]
    },
    "01m4wn87b04o": {
      "id": "01m4wn87b04o",
      "pos": 5441,
      "end": 6075,
      "text": "interface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wns4nne7"
      ]
    },
    "01m4wns4nne7": {
      "id": "01m4wns4nne7",
      "pos": 0,
      "end": 14551,
      "text": "interface SymbolConstructor {\n    /**\n     * A method that returns the default iterator for an object. Called by the semantics of the\n     * for-of statement.\n     */\n    readonly iterator: symbol;\n}\n\ninterface IteratorResult<T> {\n    done: boolean;\n    value: T;\n}\n\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}\n\ninterface Iterable<T> {\n    [Symbol.iterator](): Iterator<T>;\n}\n\ninterface IterableIterator<T> extends Iterator<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n}\n\ninterface Array<T> {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     */\n    from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n}\n\ninterface ReadonlyArray<T> {\n    /** Iterator of values in the array. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface IArguments {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<any>;\n}\n\ninterface Map<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface ReadonlyMap<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface MapConstructor {\n    new <K, V>(iterable: Iterable<[K, V]>): Map<K, V>;\n}\n\ninterface WeakMap<K extends object, V> { }\n\ninterface WeakMapConstructor {\n    new <K extends object = object, V = any>(iterable: Iterable<[K, V]>): WeakMap<K, V>;\n}\n\ninterface Set<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ReadonlySet<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface SetConstructor {\n    new <T>(iterable: Iterable<T>): Set<T>;\n}\n\ninterface WeakSet<T extends object> { }\n\ninterface WeakSetConstructor {\n    new <T extends object = object>(iterable: Iterable<T>): WeakSet<T>;\n}\n\ninterface Promise<T> { }\n\ninterface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\n}\n\ndeclare namespace Reflect {\n    function enumerate(target: object): IterableIterator<any>;\n}\n\ninterface String {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\ninterface Int8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int8ArrayConstructor {\n    new (elements: Iterable<number>): Int8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int8Array;\n}\n\ninterface Uint8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ArrayConstructor {\n    new (elements: Iterable<number>): Uint8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8Array;\n}\n\ninterface Uint8ClampedArray {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    new (elements: Iterable<number>): Uint8ClampedArray;\n\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\n\ninterface Int16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int16ArrayConstructor {\n    new (elements: Iterable<number>): Int16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int16Array;\n}\n\ninterface Uint16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint16ArrayConstructor {\n    new (elements: Iterable<number>): Uint16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint16Array;\n}\n\ninterface Int32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int32ArrayConstructor {\n    new (elements: Iterable<number>): Int32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int32Array;\n}\n\ninterface Uint32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint32ArrayConstructor {\n    new (elements: Iterable<number>): Uint32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint32Array;\n}\n\ninterface Float32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float32ArrayConstructor {\n    new (elements: Iterable<number>): Float32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float32Array;\n}\n\ninterface Float64Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float64ArrayConstructor {\n    new (elements: Iterable<number>): Float64Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float64Array;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wmkebklh": {
      "id": "01m4wmkebklh",
      "pos": 58475,
      "end": 58794,
      "text": "interface ArrayConstructor {\n    new(arrayLength?: number): any[];\n    new <T>(arrayLength: number): T[];\n    new <T>(...items: T[]): T[];\n    (arrayLength?: number): any[];\n    <T>(arrayLength: number): T[];\n    <T>(...items: T[]): T[];\n    isArray(arg: any): arg is Array<any>;\n    readonly prototype: Array<any>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlpn69il"
      ]
    },
    "01m4wnpwsg3p": {
      "id": "01m4wnpwsg3p",
      "pos": 1320,
      "end": 1385,
      "text": "interface Iterable<T> {\n    [Symbol.iterator](): Iterator<T>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wns4nne7"
      ]
    },
    "01m4wmsyrx8q": {
      "id": "01m4wmsyrx8q",
      "pos": 48188,
      "end": 58475,
      "text": "interface Array<T> {\n    /**\n      * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Removes the last element from an array and returns it.\n      */\n    pop(): T | undefined;\n    /**\n      * Appends new elements to an array, and returns the new length of the array.\n      * @param items New elements of the Array.\n      */\n    push(...items: T[]): number;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): T[];\n    /**\n      * Removes the first element from an array and returns it.\n      */\n    shift(): T | undefined;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: T, b: T) => number): this;\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      */\n    splice(start: number, deleteCount?: number): T[];\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      * @param items Elements to insert into the array in place of the deleted elements.\n      */\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    /**\n      * Inserts new elements at the start of an array.\n      * @param items  Elements to insert at the start of the Array.\n      */\n    unshift(...items: T[]): number;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    [n: number]: T;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": [
        "ContainsThis",
        "Ambient"
      ],
      "parent": [
        "node",
        "01m4wlpn69il"
      ]
    },
    "01m4wnenows0": {
      "id": "01m4wnenows0",
      "pos": 0,
      "end": 3400,
      "text": "interface Array<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;\n\n    /**\n     * Returns the this object after filling the section identified by start and end with value\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: T, start?: number, end?: number): this;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": [
        "ContainsThis",
        "Ambient"
      ],
      "parent": [
        "node",
        "01m4wmyyev1l"
      ]
    },
    "01m4wmsp0ijk": {
      "id": "01m4wmsp0ijk",
      "pos": 1486,
      "end": 1920,
      "text": "interface Array<T> {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wns4nne7"
      ]
    },
    "01m4wm6f6ypg": {
      "id": "01m4wm6f6ypg",
      "pos": 2951,
      "end": 3334,
      "text": "interface Array<T> {\n    /**\n     * Returns an object whose properties have the value 'true'\n     * when they will be absent when used in a 'with' statement.\n     */\n    [Symbol.unscopables](): {\n        copyWithin: boolean;\n        entries: boolean;\n        fill: boolean;\n        find: boolean;\n        findIndex: boolean;\n        keys: boolean;\n        values: boolean;\n    };\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wncw7qaf"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wncw7qaf"
      ]
    },
    "01m4wm0ux22r": {
      "id": "01m4wm0ux22r",
      "pos": 0,
      "end": 1217,
      "text": "interface Array<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wn4ej8td"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn4ej8td"
      ]
    },
    "01m4wng5eqr5": {
      "id": "01m4wng5eqr5",
      "pos": 4750,
      "end": 7685,
      "text": "interface Array<T> {\n\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined> (\n        callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>,\n        thisArg?: This\n    ): U[]\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][][][], depth: 7): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][][], depth: 6): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][], depth: 5): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][], depth: 4): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][], depth: 3): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][], depth: 2): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][], depth?: 1): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[], depth: 0): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth. If no depth is provided, flat method defaults to the depth of 1.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(depth?: number): any[];\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmyc29un"
      ]
    },
    "01m4wnf89p5u": {
      "id": "01m4wnf89p5u",
      "pos": 50223,
      "end": 50257,
      "text": "compareFn?: (a: T, b: T) => number",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn1sovgj"
      ],
      "name": "compareFn",
      "type": [
        "type",
        832
      ]
    },
    "01m4wmwncwjd": {
      "id": "01m4wmwncwjd",
      "pos": 53032,
      "end": 53092,
      "text": "callbackfn: (value: T, index: number, array: T[]) => boolean",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm4tafsm"
      ],
      "name": "callbackfn",
      "type": [
        "type",
        834
      ]
    },
    "01m4wmkv3j0q": {
      "id": "01m4wmkv3j0q",
      "pos": 53526,
      "end": 53583,
      "text": "callbackfn: (value: T, index: number, array: T[]) => void",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmcc145k"
      ],
      "name": "callbackfn",
      "type": [
        "type",
        835
      ]
    },
    "01m4wn7h5jvg": {
      "id": "01m4wn7h5jvg",
      "pos": 54069,
      "end": 54123,
      "text": "callbackfn: (value: T, index: number, array: T[]) => U",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm2s0ug3"
      ],
      "name": "callbackfn",
      "type": [
        "type",
        836
      ]
    },
    "01m4wn98mq38": {
      "id": "01m4wn98mq38",
      "pos": 54600,
      "end": 54663,
      "text": "callbackfn: (value: T, index: number, array: T[]) => value is S",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmaubbpx"
      ],
      "name": "callbackfn",
      "type": [
        "type",
        837
      ]
    },
    "01m4wn4aci1t": {
      "id": "01m4wn4aci1t",
      "pos": 55131,
      "end": 55187,
      "text": "callbackfn: (value: T, index: number, array: T[]) => any",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlr7nuuj"
      ],
      "name": "callbackfn",
      "type": [
        "type",
        838
      ]
    },
    "01m4wmo1hnx1": {
      "id": "01m4wmo1hnx1",
      "pos": 57569,
      "end": 57655,
      "text": "callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wm813hhm"
      ],
      "name": "callbackfn",
      "type": [
        "type",
        843
      ]
    },
    "01m4wmqb5pou": {
      "id": "01m4wmqb5pou",
      "pos": 58344,
      "end": 58430,
      "text": "callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlur24yf"
      ],
      "name": "callbackfn",
      "type": [
        "type",
        844
      ]
    },
    "01m4wna76n1n": {
      "id": "01m4wna76n1n",
      "pos": 1470,
      "end": 1542,
      "text": "predicate: (this: void, value: T, index: number, obj: T[]) => value is S",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlw4k75i"
      ],
      "name": "predicate",
      "type": [
        "type",
        845
      ]
    },
    "01m4wmi4niuq": {
      "id": "01m4wmi4niuq",
      "pos": 2250,
      "end": 2307,
      "text": "predicate: (value: T, index: number, obj: T[]) => boolean",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlndi7wb"
      ],
      "name": "predicate",
      "type": [
        "type",
        847
      ]
    },
    "01m4wmwvqe8j": {
      "id": "01m4wmwvqe8j",
      "pos": 5342,
      "end": 5432,
      "text": "callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmq4664d"
      ],
      "name": "callback",
      "type": [
        "type",
        848
      ]
    },
    "01m4wmyyev1l": {
      "id": "01m4wmyyev1l",
      "pos": 0,
      "end": 19588,
      "text": "interface Array<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;\n\n    /**\n     * Returns the this object after filling the section identified by start and end with value\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: T, start?: number, end?: number): this;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an array-like object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from<T>(arrayLike: ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of<T>(...items: T[]): T[];\n}\n\ninterface DateConstructor {\n    new (value: number | string | Date): Date;\n}\n\ninterface Function {\n    /**\n     * Returns the name of the function. Function names are read-only and can not be changed.\n     */\n    readonly name: string;\n}\n\ninterface Math {\n    /**\n     * Returns the number of leading zero bits in the 32-bit binary representation of a number.\n     * @param x A numeric expression.\n     */\n    clz32(x: number): number;\n\n    /**\n     * Returns the result of 32-bit multiplication of two numbers.\n     * @param x First number\n     * @param y Second number\n     */\n    imul(x: number, y: number): number;\n\n    /**\n     * Returns the sign of the x, indicating whether x is positive, negative or zero.\n     * @param x The numeric expression to test\n     */\n    sign(x: number): number;\n\n    /**\n     * Returns the base 10 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log10(x: number): number;\n\n    /**\n     * Returns the base 2 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log2(x: number): number;\n\n    /**\n     * Returns the natural logarithm of 1 + x.\n     * @param x A numeric expression.\n     */\n    log1p(x: number): number;\n\n    /**\n     * Returns the result of (e^x - 1), which is an implementation-dependent approximation to\n     * subtracting 1 from the exponential function of x (e raised to the power of x, where e\n     * is the base of the natural logarithms).\n     * @param x A numeric expression.\n     */\n    expm1(x: number): number;\n\n    /**\n     * Returns the hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    cosh(x: number): number;\n\n    /**\n     * Returns the hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    sinh(x: number): number;\n\n    /**\n     * Returns the hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    tanh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    acosh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    asinh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    atanh(x: number): number;\n\n    /**\n     * Returns the square root of the sum of squares of its arguments.\n     * @param values Values to compute the square root for.\n     *     If no arguments are passed, the result is +0.\n     *     If there is only one argument, the result is the absolute value.\n     *     If any argument is +Infinity or -Infinity, the result is +Infinity.\n     *     If any argument is NaN, the result is NaN.\n     *     If all arguments are either +0 or −0, the result is +0.\n     */\n    hypot(...values: number[]): number;\n\n    /**\n     * Returns the integral part of the a numeric expression, x, removing any fractional digits.\n     * If x is already an integer, the result is x.\n     * @param x A numeric expression.\n     */\n    trunc(x: number): number;\n\n    /**\n     * Returns the nearest single precision float representation of a number.\n     * @param x A numeric expression.\n     */\n    fround(x: number): number;\n\n    /**\n     * Returns an implementation-dependent approximation to the cube root of number.\n     * @param x A numeric expression.\n     */\n    cbrt(x: number): number;\n}\n\ninterface NumberConstructor {\n    /**\n     * The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1\n     * that is representable as a Number value, which is approximately:\n     * 2.2204460492503130808472633361816 x 10‍−‍16.\n     */\n    readonly EPSILON: number;\n\n    /**\n     * Returns true if passed value is finite.\n     * Unlike the global isFinite, Number.isFinite doesn't forcibly convert the parameter to a\n     * number. Only finite values of the type number, result in true.\n     * @param number A numeric value.\n     */\n    isFinite(number: number): boolean;\n\n    /**\n     * Returns true if the value passed is an integer, false otherwise.\n     * @param number A numeric value.\n     */\n    isInteger(number: number): boolean;\n\n    /**\n     * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a\n     * number). Unlike the global isNaN(), Number.isNaN() doesn't forcefully convert the parameter\n     * to a number. Only values of the type number, that are also NaN, result in true.\n     * @param number A numeric value.\n     */\n    isNaN(number: number): boolean;\n\n    /**\n     * Returns true if the value passed is a safe integer.\n     * @param number A numeric value.\n     */\n    isSafeInteger(number: number): boolean;\n\n    /**\n     * The value of the largest integer n such that n and n + 1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 − 1.\n     */\n    readonly MAX_SAFE_INTEGER: number;\n\n    /**\n     * The value of the smallest integer n such that n and n − 1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MIN_SAFE_INTEGER is −9007199254740991 (−(2^53 − 1)).\n     */\n    readonly MIN_SAFE_INTEGER: number;\n\n    /**\n     * Converts a string to a floating-point number.\n     * @param string A string that contains a floating-point number.\n     */\n    parseFloat(string: string): number;\n\n    /**\n     * Converts A string to an integer.\n     * @param s A string to convert into a number.\n     * @param radix A value between 2 and 36 that specifies the base of the number in numString.\n     * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n     * All other strings are considered decimal.\n     */\n    parseInt(string: string, radix?: number): number;\n}\n\ninterface ObjectConstructor {\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source The source object from which to copy properties.\n     */\n    assign<T, U>(target: T, source: U): T & U;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     */\n    assign<T, U, V>(target: T, source1: U, source2: V): T & U & V;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     * @param source3 The third source object from which to copy properties.\n     */\n    assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param sources One or more source objects from which to copy properties\n     */\n    assign(target: object, ...sources: any[]): any;\n\n    /**\n     * Returns an array of all symbol properties found directly on object o.\n     * @param o Object to retrieve the symbols from.\n     */\n    getOwnPropertySymbols(o: any): symbol[];\n\n    /**\n     * Returns true if the values are the same value, false otherwise.\n     * @param value1 The first value.\n     * @param value2 The second value.\n     */\n    is(value1: any, value2: any): boolean;\n\n    /**\n     * Sets the prototype of a specified object o to  object proto or null. Returns the object o.\n     * @param o The object to change its prototype.\n     * @param proto The value of the new prototype or null.\n     */\n    setPrototypeOf(o: any, proto: object | null): any;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (this: void, value: T, index: number, obj: ReadonlyArray<T>) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: ReadonlyArray<T>) => boolean, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: ReadonlyArray<T>) => boolean, thisArg?: any): number;\n}\n\ninterface RegExp {\n    /**\n     * Returns a string indicating the flags of the regular expression in question. This field is read-only.\n     * The characters in this string are sequenced and concatenated in the following order:\n     *\n     *    - \"g\" for global\n     *    - \"i\" for ignoreCase\n     *    - \"m\" for multiline\n     *    - \"u\" for unicode\n     *    - \"y\" for sticky\n     *\n     * If no flags are set, the value is the empty string.\n     */\n    readonly flags: string;\n\n    /**\n     * Returns a Boolean value indicating the state of the sticky flag (y) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly sticky: boolean;\n\n    /**\n     * Returns a Boolean value indicating the state of the Unicode flag (u) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly unicode: boolean;\n}\n\ninterface RegExpConstructor {\n    new (pattern: RegExp, flags?: string): RegExp;\n    (pattern: RegExp, flags?: string): RegExp;\n}\n\ninterface String {\n    /**\n     * Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\n     * value of the UTF-16 encoded code point starting at the string element at position pos in\n     * the String resulting from converting this object to a String.\n     * If there is no element at that position, the result is undefined.\n     * If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.\n     */\n    codePointAt(pos: number): number | undefined;\n\n    /**\n     * Returns true if searchString appears as a substring of the result of converting this\n     * object to a String, at one or more positions that are\n     * greater than or equal to position; otherwise, returns false.\n     * @param searchString search string\n     * @param position If position is undefined, 0 is assumed, so as to search all of the String.\n     */\n    includes(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * endPosition – length(this). Otherwise returns false.\n     */\n    endsWith(searchString: string, endPosition?: number): boolean;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    normalize(form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    normalize(form?: string): string;\n\n    /**\n     * Returns a String value that is made from count copies appended together. If count is 0,\n     * the empty string is returned.\n     * @param count number of copies to append\n     */\n    repeat(count: number): string;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * position. Otherwise returns false.\n     */\n    startsWith(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns an <a> HTML anchor element and sets the name attribute to the text value\n     * @param name\n     */\n    anchor(name: string): string;\n\n    /** Returns a <big> HTML element */\n    big(): string;\n\n    /** Returns a <blink> HTML element */\n    blink(): string;\n\n    /** Returns a <b> HTML element */\n    bold(): string;\n\n    /** Returns a <tt> HTML element */\n    fixed(): string;\n\n    /** Returns a <font> HTML element and sets the color attribute value */\n    fontcolor(color: string): string;\n\n    /** Returns a <font> HTML element and sets the size attribute value */\n    fontsize(size: number): string;\n\n    /** Returns a <font> HTML element and sets the size attribute value */\n    fontsize(size: string): string;\n\n    /** Returns an <i> HTML element */\n    italics(): string;\n\n    /** Returns an <a> HTML element and sets the href attribute value */\n    link(url: string): string;\n\n    /** Returns a <small> HTML element */\n    small(): string;\n\n    /** Returns a <strike> HTML element */\n    strike(): string;\n\n    /** Returns a <sub> HTML element */\n    sub(): string;\n\n    /** Returns a <sup> HTML element */\n    sup(): string;\n}\n\ninterface StringConstructor {\n    /**\n     * Return the String value whose elements are, in order, the elements in the List elements.\n     * If length is 0, the empty string is returned.\n     */\n    fromCodePoint(...codePoints: number[]): string;\n\n    /**\n     * String.raw is intended for use as a tag function of a Tagged Template String. When called\n     * as such the first argument will be a well formed template call site object and the rest\n     * parameter will contain the substitution values.\n     * @param template A well-formed template string call site representation.\n     * @param substitutions A set of substitution values.\n     */\n    raw(template: TemplateStringsArray, ...substitutions: any[]): string;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wncw7qaf": {
      "id": "01m4wncw7qaf",
      "pos": 0,
      "end": 10288,
      "text": "interface SymbolConstructor {\n    /**\n     * A method that determines if a constructor object recognizes an object as one of the\n     * constructor’s instances. Called by the semantics of the instanceof operator.\n     */\n    readonly hasInstance: symbol;\n\n    /**\n     * A Boolean value that if true indicates that an object should flatten to its array elements\n     * by Array.prototype.concat.\n     */\n    readonly isConcatSpreadable: symbol;\n\n    /**\n     * A regular expression method that matches the regular expression against a string. Called\n     * by the String.prototype.match method.\n     */\n    readonly match: symbol;\n\n    /**\n     * A regular expression method that replaces matched substrings of a string. Called by the\n     * String.prototype.replace method.\n     */\n    readonly replace: symbol;\n\n    /**\n     * A regular expression method that returns the index within a string that matches the\n     * regular expression. Called by the String.prototype.search method.\n     */\n    readonly search: symbol;\n\n    /**\n     * A function valued property that is the constructor function that is used to create\n     * derived objects.\n     */\n    readonly species: symbol;\n\n    /**\n     * A regular expression method that splits a string at the indices that match the regular\n     * expression. Called by the String.prototype.split method.\n     */\n    readonly split: symbol;\n\n    /**\n     * A method that converts an object to a corresponding primitive value.\n     * Called by the ToPrimitive abstract operation.\n     */\n    readonly toPrimitive: symbol;\n\n    /**\n     * A String value that is used in the creation of the default string description of an object.\n     * Called by the built-in method Object.prototype.toString.\n     */\n    readonly toStringTag: symbol;\n\n    /**\n     * An Object whose own property names are property names that are excluded from the 'with'\n     * environment bindings of the associated objects.\n     */\n    readonly unscopables: symbol;\n}\n\ninterface Symbol {\n    readonly [Symbol.toStringTag]: \"Symbol\";\n}\n\ninterface Array<T> {\n    /**\n     * Returns an object whose properties have the value 'true'\n     * when they will be absent when used in a 'with' statement.\n     */\n    [Symbol.unscopables](): {\n        copyWithin: boolean;\n        entries: boolean;\n        fill: boolean;\n        find: boolean;\n        findIndex: boolean;\n        keys: boolean;\n        values: boolean;\n    };\n}\n\ninterface Date {\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"default\"): string;\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"string\"): string;\n    /**\n     * Converts a Date object to a number.\n     */\n    [Symbol.toPrimitive](hint: \"number\"): number;\n    /**\n     * Converts a Date object to a string or number.\n     *\n     * @param hint The strings \"number\", \"string\", or \"default\" to specify what primitive to return.\n     *\n     * @throws {TypeError} If 'hint' was given something other than \"number\", \"string\", or \"default\".\n     * @returns A number if 'hint' was \"number\", a string if 'hint' was \"string\" or \"default\".\n     */\n    [Symbol.toPrimitive](hint: string): string | number;\n}\n\ninterface Map<K, V> {\n    readonly [Symbol.toStringTag]: \"Map\";\n}\n\ninterface WeakMap<K extends object, V> {\n    readonly [Symbol.toStringTag]: \"WeakMap\";\n}\n\ninterface Set<T> {\n    readonly [Symbol.toStringTag]: \"Set\";\n}\n\ninterface WeakSet<T extends object> {\n    readonly [Symbol.toStringTag]: \"WeakSet\";\n}\n\ninterface JSON {\n    readonly [Symbol.toStringTag]: \"JSON\";\n}\n\ninterface Function {\n    /**\n     * Determines whether the given value inherits from this function if this function was used\n     * as a constructor function.\n     *\n     * A constructor function can control which objects are recognized as its instances by\n     * 'instanceof' by overriding this method.\n     */\n    [Symbol.hasInstance](value: any): boolean;\n}\n\ninterface GeneratorFunction {\n    readonly [Symbol.toStringTag]: \"GeneratorFunction\";\n}\n\ninterface Math {\n    readonly [Symbol.toStringTag]: \"Math\";\n}\n\ninterface Promise<T> {\n    readonly [Symbol.toStringTag]: \"Promise\";\n}\n\ninterface PromiseConstructor {\n    readonly [Symbol.species]: PromiseConstructor;\n}\n\ninterface RegExp {\n    /**\n     * Matches a string with this regular expression, and returns an array containing the results of\n     * that search.\n     * @param string A string to search within.\n     */\n    [Symbol.match](string: string): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replaceValue A String object or string literal containing the text to replace for every\n     *                     successful match of this regular expression.\n     */\n    [Symbol.replace](string: string, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replacer A function that returns the replacement text.\n     */\n    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the position beginning first substring match in a regular expression search\n     * using this regular expression.\n     *\n     * @param string The string to search within.\n     */\n    [Symbol.search](string: string): number;\n\n    /**\n     * Returns an array of substrings that were delimited by strings in the original input that\n     * match against this regular expression.\n     *\n     * If the regular expression contains capturing parentheses, then each time this\n     * regular expression matches, the results (including any undefined results) of the\n     * capturing parentheses are spliced.\n     *\n     * @param string string value to split\n     * @param limit if not undefined, the output array is truncated so that it contains no more\n     * than 'limit' elements.\n     */\n    [Symbol.split](string: string, limit?: number): string[];\n}\n\ninterface RegExpConstructor {\n    readonly [Symbol.species]: RegExpConstructor;\n}\n\ninterface String {\n    /**\n     * Matches a string an object that supports being matched against, and returns an array containing the results of that search.\n     * @param matcher An object that supports being matched against.\n     */\n    match(matcher: { [Symbol.match](string: string): RegExpMatchArray | null; }): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replacer A function that returns the replacement text.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the first substring match in a regular expression search.\n     * @param searcher An object which supports searching within a string.\n     */\n    search(searcher: { [Symbol.search](string: string): number; }): number;\n\n    /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * @param splitter An object that can split a string.\n     * @param limit A value used to limit the number of elements returned in the array.\n     */\n    split(splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[];\n}\n\ninterface ArrayBuffer {\n    readonly [Symbol.toStringTag]: \"ArrayBuffer\";\n}\n\ninterface DataView {\n    readonly [Symbol.toStringTag]: \"DataView\";\n}\n\ninterface Int8Array {\n    readonly [Symbol.toStringTag]: \"Int8Array\";\n}\n\ninterface Uint8Array {\n    readonly [Symbol.toStringTag]: \"UInt8Array\";\n}\n\ninterface Uint8ClampedArray {\n    readonly [Symbol.toStringTag]: \"Uint8ClampedArray\";\n}\n\ninterface Int16Array {\n    readonly [Symbol.toStringTag]: \"Int16Array\";\n}\n\ninterface Uint16Array {\n    readonly [Symbol.toStringTag]: \"Uint16Array\";\n}\n\ninterface Int32Array {\n    readonly [Symbol.toStringTag]: \"Int32Array\";\n}\n\ninterface Uint32Array {\n    readonly [Symbol.toStringTag]: \"Uint32Array\";\n}\n\ninterface Float32Array {\n    readonly [Symbol.toStringTag]: \"Float32Array\";\n}\n\ninterface Float64Array {\n    readonly [Symbol.toStringTag]: \"Float64Array\";\n}\n\ninterface ArrayConstructor {\n    readonly [Symbol.species]: ArrayConstructor;\n}\ninterface MapConstructor {\n    readonly [Symbol.species]: MapConstructor;\n}\ninterface SetConstructor {\n    readonly [Symbol.species]: SetConstructor;\n}\ninterface ArrayBufferConstructor {\n    readonly [Symbol.species]: ArrayBufferConstructor;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wncw7qaf"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wn4ej8td": {
      "id": "01m4wn4ej8td",
      "pos": 0,
      "end": 4870,
      "text": "interface Array<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface Int8Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8ClampedArray {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int16Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint16Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float64Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wn4ej8td"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wmyc29un": {
      "id": "01m4wmyc29un",
      "pos": 0,
      "end": 7686,
      "text": "interface ReadonlyArray<T> {\n\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined> (\n        callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>,\n        thisArg?: This\n    ): U[]\n\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[][][][]> |\n\n        ReadonlyArray<ReadonlyArray<U[][][]>> |\n        ReadonlyArray<ReadonlyArray<U[][]>[]> |\n        ReadonlyArray<ReadonlyArray<U[]>[][]> |\n        ReadonlyArray<ReadonlyArray<U>[][][]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[][]>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[][]>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[][]> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>[]> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>[]> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>[]>> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[]>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>[]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>>>,\n        depth: 4): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[][][]> |\n\n        ReadonlyArray<ReadonlyArray<U>[][]> |\n        ReadonlyArray<ReadonlyArray<U[]>[]> |\n        ReadonlyArray<ReadonlyArray<U[][]>> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>>,\n        depth: 3): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[][]> |\n\n        ReadonlyArray<ReadonlyArray<U[]>> |\n        ReadonlyArray<ReadonlyArray<U>[]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>,\n        depth: 2): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[]> |\n        ReadonlyArray<ReadonlyArray<U>>,\n        depth?: 1\n    ): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U>,\n        depth: 0\n    ): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth. If no depth is provided, flat method defaults to the depth of 1.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(depth?: number): any[];\n  }\n\ninterface Array<T> {\n\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined> (\n        callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>,\n        thisArg?: This\n    ): U[]\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][][][], depth: 7): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][][], depth: 6): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][], depth: 5): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][], depth: 4): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][], depth: 3): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][], depth: 2): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][], depth?: 1): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[], depth: 0): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth. If no depth is provided, flat method defaults to the depth of 1.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(depth?: number): any[];\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wn1sovgj": {
      "id": "01m4wn1sovgj",
      "pos": 50004,
      "end": 50265,
      "text": "sort(compareFn?: (a: T, b: T) => number): this;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "sort",
      "type": [
        "type",
        766
      ]
    },
    "01m4wm4dwd82": {
      "id": "01m4wm4dwd82",
      "pos": 51967,
      "end": 52535,
      "text": "every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "every",
      "type": [
        "type",
        771
      ]
    },
    "01m4wm4tafsm": {
      "id": "01m4wm4tafsm",
      "pos": 52535,
      "end": 53118,
      "text": "some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "some",
      "type": [
        "type",
        772
      ]
    },
    "01m4wmcc145k": {
      "id": "01m4wmcc145k",
      "pos": 53118,
      "end": 53606,
      "text": "forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "forEach",
      "type": [
        "type",
        773
      ]
    },
    "01m4wm2s0ug3": {
      "id": "01m4wm2s0ug3",
      "pos": 53606,
      "end": 54145,
      "text": "map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "map",
      "type": [
        "type",
        774
      ]
    },
    "01m4wmaubbpx": {
      "id": "01m4wmaubbpx",
      "pos": 54145,
      "end": 54685,
      "text": "filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "filter",
      "type": [
        "type",
        777
      ]
    },
    "01m4wlr7nuuj": {
      "id": "01m4wlr7nuuj",
      "pos": 54685,
      "end": 55209,
      "text": "filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "filter",
      "type": [
        "type",
        777
      ]
    },
    "01m4wnndd0ac": {
      "id": "01m4wnndd0ac",
      "pos": 55209,
      "end": 55933,
      "text": "reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduce",
      "type": [
        "type",
        780
      ]
    },
    "01m4wne1cbav": {
      "id": "01m4wne1cbav",
      "pos": 55933,
      "end": 56053,
      "text": "reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduce",
      "type": [
        "type",
        780
      ]
    },
    "01m4wm9f0g9j": {
      "id": "01m4wm9f0g9j",
      "pos": 56053,
      "end": 56797,
      "text": "reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduce",
      "type": [
        "type",
        780
      ]
    },
    "01m4wmo4ah7v": {
      "id": "01m4wmo4ah7v",
      "pos": 56797,
      "end": 57552,
      "text": "reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduceRight",
      "type": [
        "type",
        782
      ]
    },
    "01m4wm813hhm": {
      "id": "01m4wm813hhm",
      "pos": 57552,
      "end": 57677,
      "text": "reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduceRight",
      "type": [
        "type",
        782
      ]
    },
    "01m4wlur24yf": {
      "id": "01m4wlur24yf",
      "pos": 57677,
      "end": 58452,
      "text": "reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmsyrx8q"
      ],
      "name": "reduceRight",
      "type": [
        "type",
        782
      ]
    },
    "01m4wlw4k75i": {
      "id": "01m4wlw4k75i",
      "pos": 882,
      "end": 1574,
      "text": "find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "find",
      "type": [
        "type",
        784
      ]
    },
    "01m4wnjgehwi": {
      "id": "01m4wnjgehwi",
      "pos": 1574,
      "end": 1673,
      "text": "find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "find",
      "type": [
        "type",
        784
      ]
    },
    "01m4wlndi7wb": {
      "id": "01m4wlndi7wb",
      "pos": 1673,
      "end": 2332,
      "text": "findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnenows0"
      ],
      "name": "findIndex",
      "type": [
        "type",
        786
      ]
    },
    "01m4wmq4664d": {
      "id": "01m4wmq4664d",
      "pos": 4772,
      "end": 5467,
      "text": "flatMap<U, This = undefined> (\n        callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>,\n        thisArg?: This\n    ): U[]",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wng5eqr5"
      ],
      "name": "flatMap",
      "type": [
        "type",
        803
      ]
    },
    "01m4wnspmc95": {
      "id": "01m4wnspmc95",
      "pos": 3400,
      "end": 4153,
      "text": "interface ArrayConstructor {\n    /**\n     * Creates an array from an array-like object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from<T>(arrayLike: ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of<T>(...items: T[]): T[];\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmyyev1l"
      ]
    },
    "01m4wnfrthog": {
      "id": "01m4wnfrthog",
      "pos": 1920,
      "end": 2518,
      "text": "interface ArrayConstructor {\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     */\n    from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wns4nne7"
      ]
    },
    "01m4wnujwd5o": {
      "id": "01m4wnujwd5o",
      "pos": 1166,
      "end": 1320,
      "text": "interface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wns4nne7"
      ]
    },
    "01m4wm1mhe44": {
      "id": "01m4wm1mhe44",
      "pos": 7404,
      "end": 7472,
      "text": "interface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wmbdh7dp"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wmbdh7dp"
      ]
    },
    "01m4wnenox55": {
      "id": "01m4wnenox55",
      "pos": 1385,
      "end": 1486,
      "text": "interface IterableIterator<T> extends Iterator<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wns4nne7"
      ]
    },
    "01m4wntpk74k": {
      "id": "01m4wntpk74k",
      "pos": 48016,
      "end": 48188,
      "text": "interface ConcatArray<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n    join(separator?: string): string;\n    slice(start?: number, end?: number): T[];\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "node",
      "kind": "InterfaceDeclaration",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wlpn69il"
      ]
    },
    "01m4wmebvrlc": {
      "id": "01m4wmebvrlc",
      "pos": 2464,
      "end": 2494,
      "text": "mapfn: (v: T, k: number) => U",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "Parameter",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wn9099ak"
      ],
      "name": "mapfn",
      "type": [
        "type",
        932
      ]
    },
    "01m4wmbdh7dp": {
      "id": "01m4wmbdh7dp",
      "pos": 0,
      "end": 413672,
      "text": "interface Console {\n    Console: NodeJS.ConsoleConstructor;\n    /**\n     * A simple assertion test that verifies whether `value` is truthy.\n     * If it is not, an `AssertionError` is thrown.\n     * If provided, the error `message` is formatted using `util.format()` and used as the error message.\n     */\n    assert(value: any, message?: string, ...optionalParams: any[]): void;\n    /**\n     * When `stdout` is a TTY, calling `console.clear()` will attempt to clear the TTY.\n     * When `stdout` is not a TTY, this method does nothing.\n     */\n    clear(): void;\n    /**\n     * Maintains an internal counter specific to `label` and outputs to `stdout` the number of times `console.count()` has been called with the given `label`.\n     */\n    count(label?: string): void;\n    /**\n     * Resets the internal counter specific to `label`.\n     */\n    countReset(label?: string): void;\n    /**\n     * The `console.debug()` function is an alias for {@link console.log()}.\n     */\n    debug(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Uses {@link util.inspect()} on `obj` and prints the resulting string to `stdout`.\n     * This function bypasses any custom `inspect()` function defined on `obj`.\n     */\n    dir(obj: any, options?: NodeJS.InspectOptions): void;\n    /**\n     * This method calls {@link console.log()} passing it the arguments received. Please note that this method does not produce any XML formatting\n     */\n    dirxml(...data: any[]): void;\n    /**\n     * Prints to `stderr` with newline.\n     */\n    error(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Increases indentation of subsequent lines by two spaces.\n     * If one or more `label`s are provided, those are printed first without the additional indentation.\n     */\n    group(...label: any[]): void;\n    /**\n     * The `console.groupCollapsed()` function is an alias for {@link console.group()}.\n     */\n    groupCollapsed(): void;\n    /**\n     * Decreases indentation of subsequent lines by two spaces.\n     */\n    groupEnd(): void;\n    /**\n     * The {@link console.info()} function is an alias for {@link console.log()}.\n     */\n    info(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Prints to `stdout` with newline.\n     */\n    log(message?: any, ...optionalParams: any[]): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Prints to `stdout` the array `array` formatted as a table.\n     */\n    table(tabularData: any, properties?: string[]): void;\n    /**\n     * Starts a timer that can be used to compute the duration of an operation. Timers are identified by a unique `label`.\n     */\n    time(label?: string): void;\n    /**\n     * Stops a timer that was previously started by calling {@link console.time()} and prints the result to `stdout`.\n     */\n    timeEnd(label?: string): void;\n    /**\n     * For a timer that was previously started by calling {@link console.time()}, prints the elapsed time and other `data` arguments to `stdout`.\n     */\n    timeLog(label: string, ...data: any[]): void;\n    /**\n     * Prints to `stderr` the string 'Trace :', followed by the {@link util.format()} formatted message and stack trace to the current position in the code.\n     */\n    trace(message?: any, ...optionalParams: any[]): void;\n    /**\n     * The {@link console.warn()} function is an alias for {@link console.error()}.\n     */\n    warn(message?: any, ...optionalParams: any[]): void;\n\n    // --- Inspector mode only ---\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Starts a JavaScript CPU profile with an optional label.\n     */\n    profile(label?: string): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Stops the current JavaScript CPU profiling session if one has been started and prints the report to the Profiles panel of the inspector.\n     */\n    profileEnd(): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Adds an event with the label `label` to the Timeline panel of the inspector.\n     */\n    timeStamp(label?: string): void;\n}\n\ninterface Error {\n    stack?: string;\n}\n\n// Declare \"static\" methods in Error\ninterface ErrorConstructor {\n    /** Create .stack property on a target object */\n    captureStackTrace(targetObject: Object, constructorOpt?: Function): void;\n\n    /**\n     * Optional override for formatting stack traces\n     *\n     * @see https://github.com/v8/v8/wiki/Stack%20Trace%20API#customizing-stack-traces\n     */\n    prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;\n\n    stackTraceLimit: number;\n}\n\n// compat for TypeScript 1.8 and default es5 target\n// if you use with --target es3 or --target es5 and use below definitions,\n// use the lib.es6.d.ts that is bundled with TypeScript 1.8.\ninterface MapConstructor { }\ninterface WeakMapConstructor { }\ninterface SetConstructor { }\ninterface WeakSetConstructor { }\n\ninterface Set<T> {}\ninterface ReadonlySet<T> {}\n\n// Forward-declare needed types from lib.es2015.d.ts (in case users are using `--lib es5`)\ninterface Iterable<T> { }\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n}\ninterface IteratorResult<T> { }\ninterface AsyncIterableIterator<T> {}\ninterface SymbolConstructor {\n    readonly observable: symbol;\n    readonly iterator: symbol;\n    readonly asyncIterator: symbol;\n}\ndeclare var Symbol: SymbolConstructor;\ninterface SharedArrayBuffer {\n    readonly byteLength: number;\n    slice(begin?: number, end?: number): SharedArrayBuffer;\n}\n\n// Node.js ESNEXT support\ninterface String {\n    /** Removes whitespace from the left end of a string. */\n    trimLeft(): string;\n    /** Removes whitespace from the right end of a string. */\n    trimRight(): string;\n}\n\n/*-----------------------------------------------*\n *                                               *\n *                   GLOBAL                      *\n *                                               *\n ------------------------------------------------*/\ndeclare var process: NodeJS.Process;\ndeclare var global: NodeJS.Global;\ndeclare var console: Console;\n\ndeclare var __filename: string;\ndeclare var __dirname: string;\n\ndeclare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare namespace setTimeout {\n    function __promisify__(ms: number): Promise<void>;\n    function __promisify__<T>(ms: number, value: T): Promise<T>;\n}\ndeclare function clearTimeout(timeoutId: NodeJS.Timeout): void;\ndeclare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare function clearInterval(intervalId: NodeJS.Timeout): void;\ndeclare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\ndeclare namespace setImmediate {\n    function __promisify__(): Promise<void>;\n    function __promisify__<T>(value: T): Promise<T>;\n}\ndeclare function clearImmediate(immediateId: NodeJS.Immediate): void;\n\n// TODO: change to `type NodeRequireFunction = (id: string) => any;` in next mayor version.\ninterface NodeRequireFunction {\n    /* tslint:disable-next-line:callable-types */\n    (id: string): any;\n}\n\ninterface NodeRequire extends NodeRequireFunction {\n    resolve: RequireResolve;\n    cache: any;\n    extensions: NodeExtensions;\n    main: NodeModule | undefined;\n}\n\ninterface RequireResolve {\n    (id: string, options?: { paths?: string[]; }): string;\n    paths(request: string): string[] | null;\n}\n\ninterface NodeExtensions {\n    '.js': (m: NodeModule, filename: string) => any;\n    '.json': (m: NodeModule, filename: string) => any;\n    '.node': (m: NodeModule, filename: string) => any;\n    [ext: string]: (m: NodeModule, filename: string) => any;\n}\n\ndeclare var require: NodeRequire;\n\ninterface NodeModule {\n    exports: any;\n    require: NodeRequireFunction;\n    id: string;\n    filename: string;\n    loaded: boolean;\n    parent: NodeModule | null;\n    children: NodeModule[];\n    paths: string[];\n}\n\ndeclare var module: NodeModule;\n\n// Same as module.exports\ndeclare var exports: any;\ndeclare const SlowBuffer: {\n    new(str: string, encoding?: string): Buffer;\n    new(size: number): Buffer;\n    new(size: Uint8Array): Buffer;\n    new(array: any[]): Buffer;\n    prototype: Buffer;\n    isBuffer(obj: any): boolean;\n    byteLength(string: string, encoding?: string): number;\n    concat(list: Buffer[], totalLength?: number): Buffer;\n};\n\n// Buffer class\ntype BufferEncoding = \"ascii\" | \"utf8\" | \"utf16le\" | \"ucs2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\";\ninterface Buffer extends Uint8Array {\n    constructor: typeof Buffer;\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\n    toString(encoding?: string, start?: number, end?: number): string;\n    toJSON(): { type: 'Buffer', data: any[] };\n    equals(otherBuffer: Uint8Array): boolean;\n    compare(otherBuffer: Uint8Array, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\n    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n    slice(start?: number, end?: number): Buffer;\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUInt8(offset: number, noAssert?: boolean): number;\n    readUInt16LE(offset: number, noAssert?: boolean): number;\n    readUInt16BE(offset: number, noAssert?: boolean): number;\n    readUInt32LE(offset: number, noAssert?: boolean): number;\n    readUInt32BE(offset: number, noAssert?: boolean): number;\n    readInt8(offset: number, noAssert?: boolean): number;\n    readInt16LE(offset: number, noAssert?: boolean): number;\n    readInt16BE(offset: number, noAssert?: boolean): number;\n    readInt32LE(offset: number, noAssert?: boolean): number;\n    readInt32BE(offset: number, noAssert?: boolean): number;\n    readFloatLE(offset: number, noAssert?: boolean): number;\n    readFloatBE(offset: number, noAssert?: boolean): number;\n    readDoubleLE(offset: number, noAssert?: boolean): number;\n    readDoubleBE(offset: number, noAssert?: boolean): number;\n    swap16(): Buffer;\n    swap32(): Buffer;\n    swap64(): Buffer;\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\n    fill(value: any, offset?: number, end?: number): this;\n    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;\n    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;\n    entries(): IterableIterator<[number, number]>;\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\n    keys(): IterableIterator<number>;\n    values(): IterableIterator<number>;\n}\n\n/**\n * Raw data is stored in instances of the Buffer class.\n * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\n * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n */\ndeclare const Buffer: {\n    /**\n     * Allocates a new buffer containing the given {str}.\n     *\n     * @param str String to store in buffer.\n     * @param encoding encoding to use, optional.  Default is 'utf8'\n     * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.\n     */\n    new(str: string, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).\n     */\n    new(size: number): Buffer;\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    new(array: Uint8Array): Buffer;\n    /**\n     * Produces a Buffer backed by the same allocated memory as\n     * the given {ArrayBuffer}/{SharedArrayBuffer}.\n     *\n     *\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\n     * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.\n     */\n    new(arrayBuffer: ArrayBuffer | SharedArrayBuffer): Buffer;\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    new(array: any[]): Buffer;\n    /**\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\n     *\n     * @param buffer The buffer to copy.\n     * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.\n     */\n    new(buffer: Buffer): Buffer;\n    prototype: Buffer;\n    /**\n     * When passed a reference to the .buffer property of a TypedArray instance,\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\n     * The optional {byteOffset} and {length} arguments specify a memory range\n     * within the {arrayBuffer} that will be shared by the Buffer.\n     *\n     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()\n     */\n    from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param data data to create a new Buffer\n     */\n    from(data: any[]): Buffer;\n    from(data: Uint8Array): Buffer;\n    /**\n     * Creates a new Buffer containing the given JavaScript string {str}.\n     * If provided, the {encoding} parameter identifies the character encoding.\n     * If not provided, {encoding} defaults to 'utf8'.\n     */\n    from(str: string, encoding?: string): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param values to create a new Buffer\n     */\n    of(...items: number[]): Buffer;\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    isBuffer(obj: any): obj is Buffer;\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n     *\n     * @param encoding string to test.\n     */\n    isEncoding(encoding: string): boolean | undefined;\n    /**\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\n     *\n     * @param string string to test.\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\n     */\n    byteLength(string: string | NodeJS.TypedArray | DataView | ArrayBuffer | SharedArrayBuffer, encoding?: string): number;\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    concat(list: Uint8Array[], totalLength?: number): Buffer;\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    compare(buf1: Uint8Array, buf2: Uint8Array): number;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initalizing\n     */\n    alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    allocUnsafe(size: number): Buffer;\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    allocUnsafeSlow(size: number): Buffer;\n    /**\n     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.\n     */\n    poolSize: number;\n};\n\n/*----------------------------------------------*\n*                                               *\n*               GLOBAL INTERFACES               *\n*                                               *\n*-----------------------------------------------*/\ndeclare namespace NodeJS {\n    interface InspectOptions {\n        showHidden?: boolean;\n        depth?: number | null;\n        colors?: boolean;\n        customInspect?: boolean;\n        showProxy?: boolean;\n        maxArrayLength?: number | null;\n        breakLength?: number;\n        compact?: boolean;\n    }\n\n    interface ConsoleConstructor {\n        prototype: Console;\n        new(stdout: WritableStream, stderr?: WritableStream): Console;\n    }\n\n    interface CallSite {\n        /**\n         * Value of \"this\"\n         */\n        getThis(): any;\n\n        /**\n         * Type of \"this\" as a string.\n         * This is the name of the function stored in the constructor field of\n         * \"this\", if available.  Otherwise the object's [[Class]] internal\n         * property.\n         */\n        getTypeName(): string | null;\n\n        /**\n         * Current function\n         */\n        getFunction(): Function | undefined;\n\n        /**\n         * Name of the current function, typically its name property.\n         * If a name property is not available an attempt will be made to try\n         * to infer a name from the function's context.\n         */\n        getFunctionName(): string | null;\n\n        /**\n         * Name of the property [of \"this\" or one of its prototypes] that holds\n         * the current function\n         */\n        getMethodName(): string | null;\n\n        /**\n         * Name of the script [if this function was defined in a script]\n         */\n        getFileName(): string | null;\n\n        /**\n         * Current line number [if this function was defined in a script]\n         */\n        getLineNumber(): number | null;\n\n        /**\n         * Current column number [if this function was defined in a script]\n         */\n        getColumnNumber(): number | null;\n\n        /**\n         * A call site object representing the location where eval was called\n         * [if this function was created using a call to eval]\n         */\n        getEvalOrigin(): string | undefined;\n\n        /**\n         * Is this a toplevel invocation, that is, is \"this\" the global object?\n         */\n        isToplevel(): boolean;\n\n        /**\n         * Does this call take place in code defined by a call to eval?\n         */\n        isEval(): boolean;\n\n        /**\n         * Is this call in native V8 code?\n         */\n        isNative(): boolean;\n\n        /**\n         * Is this a constructor call?\n         */\n        isConstructor(): boolean;\n    }\n\n    interface ErrnoException extends Error {\n        errno?: number;\n        code?: string;\n        path?: string;\n        syscall?: string;\n        stack?: string;\n    }\n\n    class EventEmitter {\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string | symbol): this;\n        setMaxListeners(n: number): this;\n        getMaxListeners(): number;\n        listeners(event: string | symbol): Function[];\n        rawListeners(event: string | symbol): Function[];\n        emit(event: string | symbol, ...args: any[]): boolean;\n        listenerCount(type: string | symbol): number;\n        // Added in Node 6...\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        eventNames(): Array<string | symbol>;\n    }\n\n    interface ReadableStream extends EventEmitter {\n        readable: boolean;\n        read(size?: number): string | Buffer;\n        setEncoding(encoding: string): this;\n        pause(): this;\n        resume(): this;\n        isPaused(): boolean;\n        pipe<T extends WritableStream>(destination: T, options?: { end?: boolean; }): T;\n        unpipe(destination?: WritableStream): this;\n        unshift(chunk: string): void;\n        unshift(chunk: Buffer): void;\n        wrap(oldStream: ReadableStream): this;\n        [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;\n    }\n\n    interface WritableStream extends EventEmitter {\n        writable: boolean;\n        write(buffer: Buffer | string, cb?: Function): boolean;\n        write(str: string, encoding?: string, cb?: Function): boolean;\n        end(cb?: Function): void;\n        end(buffer: Buffer, cb?: Function): void;\n        end(str: string, cb?: Function): void;\n        end(str: string, encoding?: string, cb?: Function): void;\n    }\n\n    interface ReadWriteStream extends ReadableStream, WritableStream { }\n\n    interface Events extends EventEmitter { }\n\n    interface Domain extends Events {\n        run(fn: Function): void;\n        add(emitter: Events): void;\n        remove(emitter: Events): void;\n        bind(cb: (err: Error, data: any) => any): any;\n        intercept(cb: (data: any) => any): any;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        on(event: string, listener: (...args: any[]) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        removeListener(event: string, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string): this;\n    }\n\n    interface MemoryUsage {\n        rss: number;\n        heapTotal: number;\n        heapUsed: number;\n        external: number;\n    }\n\n    interface CpuUsage {\n        user: number;\n        system: number;\n    }\n\n    interface ProcessRelease {\n        name: string;\n        sourceUrl?: string;\n        headersUrl?: string;\n        libUrl?: string;\n        lts?: string;\n    }\n\n    interface ProcessVersions {\n        http_parser: string;\n        node: string;\n        v8: string;\n        ares: string;\n        uv: string;\n        zlib: string;\n        modules: string;\n        openssl: string;\n    }\n\n    type Platform = 'aix'\n        | 'android'\n        | 'darwin'\n        | 'freebsd'\n        | 'linux'\n        | 'openbsd'\n        | 'sunos'\n        | 'win32'\n        | 'cygwin';\n\n    type Signals =\n        \"SIGABRT\" | \"SIGALRM\" | \"SIGBUS\" | \"SIGCHLD\" | \"SIGCONT\" | \"SIGFPE\" | \"SIGHUP\" | \"SIGILL\" | \"SIGINT\" | \"SIGIO\" |\n        \"SIGIOT\" | \"SIGKILL\" | \"SIGPIPE\" | \"SIGPOLL\" | \"SIGPROF\" | \"SIGPWR\" | \"SIGQUIT\" | \"SIGSEGV\" | \"SIGSTKFLT\" |\n        \"SIGSTOP\" | \"SIGSYS\" | \"SIGTERM\" | \"SIGTRAP\" | \"SIGTSTP\" | \"SIGTTIN\" | \"SIGTTOU\" | \"SIGUNUSED\" | \"SIGURG\" |\n        \"SIGUSR1\" | \"SIGUSR2\" | \"SIGVTALRM\" | \"SIGWINCH\" | \"SIGXCPU\" | \"SIGXFSZ\" | \"SIGBREAK\" | \"SIGLOST\" | \"SIGINFO\";\n\n    type BeforeExitListener = (code: number) => void;\n    type DisconnectListener = () => void;\n    type ExitListener = (code: number) => void;\n    type RejectionHandledListener = (promise: Promise<any>) => void;\n    type UncaughtExceptionListener = (error: Error) => void;\n    type UnhandledRejectionListener = (reason: any, promise: Promise<any>) => void;\n    type WarningListener = (warning: Error) => void;\n    type MessageListener = (message: any, sendHandle: any) => void;\n    type SignalsListener = (signal: Signals) => void;\n    type NewListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n    type RemoveListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n\n    interface Socket extends ReadWriteStream {\n        isTTY?: true;\n    }\n\n    interface ProcessEnv {\n        [key: string]: string | undefined;\n    }\n\n    interface WriteStream extends Socket {\n        readonly writableHighWaterMark: number;\n        readonly writableLength: number;\n        columns?: number;\n        rows?: number;\n        _write(chunk: any, encoding: string, callback: Function): void;\n        _destroy(err: Error | null, callback: Function): void;\n        _final(callback: Function): void;\n        setDefaultEncoding(encoding: string): this;\n        cork(): void;\n        uncork(): void;\n        destroy(error?: Error): void;\n    }\n    interface ReadStream extends Socket {\n        readonly readableHighWaterMark: number;\n        readonly readableLength: number;\n        isRaw?: boolean;\n        setRawMode?(mode: boolean): void;\n        _read(size: number): void;\n        _destroy(err: Error | null, callback: Function): void;\n        push(chunk: any, encoding?: string): boolean;\n        destroy(error?: Error): void;\n    }\n\n    interface Process extends EventEmitter {\n        stdout: WriteStream;\n        stderr: WriteStream;\n        stdin: ReadStream;\n        openStdin(): Socket;\n        argv: string[];\n        argv0: string;\n        execArgv: string[];\n        execPath: string;\n        abort(): void;\n        chdir(directory: string): void;\n        cwd(): string;\n        debugPort: number;\n        emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\n        env: ProcessEnv;\n        exit(code?: number): never;\n        exitCode: number;\n        getgid(): number;\n        setgid(id: number | string): void;\n        getuid(): number;\n        setuid(id: number | string): void;\n        geteuid(): number;\n        seteuid(id: number | string): void;\n        getegid(): number;\n        setegid(id: number | string): void;\n        getgroups(): number[];\n        setgroups(groups: Array<string | number>): void;\n        setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;\n        hasUncaughtExceptionCaptureCallback(): boolean;\n        version: string;\n        versions: ProcessVersions;\n        config: {\n            target_defaults: {\n                cflags: any[];\n                default_configuration: string;\n                defines: string[];\n                include_dirs: string[];\n                libraries: string[];\n            };\n            variables: {\n                clang: number;\n                host_arch: string;\n                node_install_npm: boolean;\n                node_install_waf: boolean;\n                node_prefix: string;\n                node_shared_openssl: boolean;\n                node_shared_v8: boolean;\n                node_shared_zlib: boolean;\n                node_use_dtrace: boolean;\n                node_use_etw: boolean;\n                node_use_openssl: boolean;\n                target_arch: string;\n                v8_no_strict_aliasing: number;\n                v8_use_snapshot: boolean;\n                visibility: string;\n            };\n        };\n        kill(pid: number, signal?: string | number): void;\n        pid: number;\n        ppid: number;\n        title: string;\n        arch: string;\n        platform: Platform;\n        mainModule?: NodeModule;\n        memoryUsage(): MemoryUsage;\n        cpuUsage(previousValue?: CpuUsage): CpuUsage;\n        nextTick(callback: Function, ...args: any[]): void;\n        release: ProcessRelease;\n        umask(mask?: number): number;\n        uptime(): number;\n        hrtime(time?: [number, number]): [number, number];\n        domain: Domain;\n\n        // Worker\n        send?(message: any, sendHandle?: any): void;\n        disconnect(): void;\n        connected: boolean;\n\n        /**\n         * The `process.allowedNodeEnvironmentFlags` property is a special,\n         * read-only `Set` of flags allowable within the [`NODE_OPTIONS`][]\n         * environment variable.\n         */\n        allowedNodeEnvironmentFlags: ReadonlySet<string>;\n\n        /**\n         * EventEmitter\n         *   1. beforeExit\n         *   2. disconnect\n         *   3. exit\n         *   4. message\n         *   5. rejectionHandled\n         *   6. uncaughtException\n         *   7. unhandledRejection\n         *   8. warning\n         *   9. message\n         *  10. <All OS Signals>\n         *  11. newListener/removeListener inherited from EventEmitter\n         */\n        addListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        addListener(event: \"disconnect\", listener: DisconnectListener): this;\n        addListener(event: \"exit\", listener: ExitListener): this;\n        addListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        addListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        addListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        addListener(event: \"warning\", listener: WarningListener): this;\n        addListener(event: \"message\", listener: MessageListener): this;\n        addListener(event: Signals, listener: SignalsListener): this;\n        addListener(event: \"newListener\", listener: NewListenerListener): this;\n        addListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        emit(event: \"beforeExit\", code: number): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"exit\", code: number): boolean;\n        emit(event: \"rejectionHandled\", promise: Promise<any>): boolean;\n        emit(event: \"uncaughtException\", error: Error): boolean;\n        emit(event: \"unhandledRejection\", reason: any, promise: Promise<any>): boolean;\n        emit(event: \"warning\", warning: Error): boolean;\n        emit(event: \"message\", message: any, sendHandle: any): this;\n        emit(event: Signals, signal: Signals): boolean;\n        emit(event: \"newListener\", eventName: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"removeListener\", eventName: string, listener: (...args: any[]) => void): this;\n\n        on(event: \"beforeExit\", listener: BeforeExitListener): this;\n        on(event: \"disconnect\", listener: DisconnectListener): this;\n        on(event: \"exit\", listener: ExitListener): this;\n        on(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        on(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        on(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        on(event: \"warning\", listener: WarningListener): this;\n        on(event: \"message\", listener: MessageListener): this;\n        on(event: Signals, listener: SignalsListener): this;\n        on(event: \"newListener\", listener: NewListenerListener): this;\n        on(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        once(event: \"beforeExit\", listener: BeforeExitListener): this;\n        once(event: \"disconnect\", listener: DisconnectListener): this;\n        once(event: \"exit\", listener: ExitListener): this;\n        once(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        once(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        once(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        once(event: \"warning\", listener: WarningListener): this;\n        once(event: \"message\", listener: MessageListener): this;\n        once(event: Signals, listener: SignalsListener): this;\n        once(event: \"newListener\", listener: NewListenerListener): this;\n        once(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        prependListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        prependListener(event: \"disconnect\", listener: DisconnectListener): this;\n        prependListener(event: \"exit\", listener: ExitListener): this;\n        prependListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        prependListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        prependListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        prependListener(event: \"warning\", listener: WarningListener): this;\n        prependListener(event: \"message\", listener: MessageListener): this;\n        prependListener(event: Signals, listener: SignalsListener): this;\n        prependListener(event: \"newListener\", listener: NewListenerListener): this;\n        prependListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        prependOnceListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        prependOnceListener(event: \"disconnect\", listener: DisconnectListener): this;\n        prependOnceListener(event: \"exit\", listener: ExitListener): this;\n        prependOnceListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        prependOnceListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        prependOnceListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        prependOnceListener(event: \"warning\", listener: WarningListener): this;\n        prependOnceListener(event: \"message\", listener: MessageListener): this;\n        prependOnceListener(event: Signals, listener: SignalsListener): this;\n        prependOnceListener(event: \"newListener\", listener: NewListenerListener): this;\n        prependOnceListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        listeners(event: \"beforeExit\"): BeforeExitListener[];\n        listeners(event: \"disconnect\"): DisconnectListener[];\n        listeners(event: \"exit\"): ExitListener[];\n        listeners(event: \"rejectionHandled\"): RejectionHandledListener[];\n        listeners(event: \"uncaughtException\"): UncaughtExceptionListener[];\n        listeners(event: \"unhandledRejection\"): UnhandledRejectionListener[];\n        listeners(event: \"warning\"): WarningListener[];\n        listeners(event: \"message\"): MessageListener[];\n        listeners(event: Signals): SignalsListener[];\n        listeners(event: \"newListener\"): NewListenerListener[];\n        listeners(event: \"removeListener\"): RemoveListenerListener[];\n    }\n\n    interface Global {\n        Array: typeof Array;\n        ArrayBuffer: typeof ArrayBuffer;\n        Boolean: typeof Boolean;\n        Buffer: typeof Buffer;\n        DataView: typeof DataView;\n        Date: typeof Date;\n        Error: typeof Error;\n        EvalError: typeof EvalError;\n        Float32Array: typeof Float32Array;\n        Float64Array: typeof Float64Array;\n        Function: typeof Function;\n        GLOBAL: Global;\n        Infinity: typeof Infinity;\n        Int16Array: typeof Int16Array;\n        Int32Array: typeof Int32Array;\n        Int8Array: typeof Int8Array;\n        Intl: typeof Intl;\n        JSON: typeof JSON;\n        Map: MapConstructor;\n        Math: typeof Math;\n        NaN: typeof NaN;\n        Number: typeof Number;\n        Object: typeof Object;\n        Promise: Function;\n        RangeError: typeof RangeError;\n        ReferenceError: typeof ReferenceError;\n        RegExp: typeof RegExp;\n        Set: SetConstructor;\n        String: typeof String;\n        Symbol: Function;\n        SyntaxError: typeof SyntaxError;\n        TypeError: typeof TypeError;\n        URIError: typeof URIError;\n        Uint16Array: typeof Uint16Array;\n        Uint32Array: typeof Uint32Array;\n        Uint8Array: typeof Uint8Array;\n        Uint8ClampedArray: Function;\n        WeakMap: WeakMapConstructor;\n        WeakSet: WeakSetConstructor;\n        clearImmediate: (immediateId: Immediate) => void;\n        clearInterval: (intervalId: Timeout) => void;\n        clearTimeout: (timeoutId: Timeout) => void;\n        console: typeof console;\n        decodeURI: typeof decodeURI;\n        decodeURIComponent: typeof decodeURIComponent;\n        encodeURI: typeof encodeURI;\n        encodeURIComponent: typeof encodeURIComponent;\n        escape: (str: string) => string;\n        eval: typeof eval;\n        global: Global;\n        isFinite: typeof isFinite;\n        isNaN: typeof isNaN;\n        parseFloat: typeof parseFloat;\n        parseInt: typeof parseInt;\n        process: Process;\n        root: Global;\n        setImmediate: (callback: (...args: any[]) => void, ...args: any[]) => Immediate;\n        setInterval: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        setTimeout: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        undefined: typeof undefined;\n        unescape: (str: string) => string;\n        gc: () => void;\n        v8debug?: any;\n    }\n\n    interface Timer {\n        ref(): void;\n        refresh(): void;\n        unref(): void;\n    }\n\n    class Immediate {\n        ref(): void;\n        unref(): void;\n        _onImmediate: Function; // to distinguish it from the Timeout class\n    }\n\n    class Timeout implements Timer {\n        ref(): void;\n        refresh(): void;\n        unref(): void;\n    }\n\n    class Module {\n        static runMain(): void;\n        static wrap(code: string): string;\n        static builtinModules: string[];\n\n        static Module: typeof Module;\n\n        exports: any;\n        require: NodeRequireFunction;\n        id: string;\n        filename: string;\n        loaded: boolean;\n        parent: Module | null;\n        children: Module[];\n        paths: string[];\n\n        constructor(id: string, parent?: Module);\n    }\n\n    type TypedArray = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n}\n\ninterface IterableIterator<T> { }\n\n/*----------------------------------------------*\n*                                               *\n*                   MODULES                     *\n*                                               *\n*-----------------------------------------------*/\ndeclare module \"buffer\" {\n    export const INSPECT_MAX_BYTES: number;\n    const BuffType: typeof Buffer;\n    const SlowBuffType: typeof SlowBuffer;\n    export { BuffType as Buffer, SlowBuffType as SlowBuffer };\n}\n\ndeclare module \"querystring\" {\n    interface StringifyOptions {\n        encodeURIComponent?: Function;\n    }\n\n    interface ParseOptions {\n        maxKeys?: number;\n        decodeURIComponent?: Function;\n    }\n\n    interface ParsedUrlQuery { [key: string]: string | string[]; }\n\n    function stringify(obj?: {}, sep?: string, eq?: string, options?: StringifyOptions): string;\n    function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;\n    function escape(str: string): string;\n    function unescape(str: string): string;\n}\n\ndeclare module \"events\" {\n    class internal extends NodeJS.EventEmitter { }\n\n    namespace internal {\n         class EventEmitter extends internal {\n            /** @deprecated since v4.0.0 */\n            static listenerCount(emitter: EventEmitter, event: string | symbol): number;\n            static defaultMaxListeners: number;\n\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            off(event: string | symbol, listener: (...args: any[]) => void): this;\n            removeAllListeners(event?: string | symbol): this;\n            setMaxListeners(n: number): this;\n            getMaxListeners(): number;\n            listeners(event: string | symbol): Function[];\n            rawListeners(event: string | symbol): Function[];\n            emit(event: string | symbol, ...args: any[]): boolean;\n            eventNames(): Array<string | symbol>;\n            listenerCount(type: string | symbol): number;\n        }\n    }\n\n    export = internal;\n}\n\ndeclare module \"http\" {\n    import * as events from \"events\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n    import { URL } from \"url\";\n\n    // incoming headers will never contain number\n    interface IncomingHttpHeaders {\n        'accept'?: string;\n        'access-control-allow-origin'?: string;\n        'access-control-allow-credentials'?: string;\n        'access-control-expose-headers'?: string;\n        'access-control-max-age'?: string;\n        'access-control-allow-methods'?: string;\n        'access-control-allow-headers'?: string;\n        'accept-patch'?: string;\n        'accept-ranges'?: string;\n        'authorization'?: string;\n        'age'?: string;\n        'allow'?: string;\n        'alt-svc'?: string;\n        'cache-control'?: string;\n        'connection'?: string;\n        'content-disposition'?: string;\n        'content-encoding'?: string;\n        'content-language'?: string;\n        'content-length'?: string;\n        'content-location'?: string;\n        'content-range'?: string;\n        'content-type'?: string;\n        'date'?: string;\n        'expires'?: string;\n        'host'?: string;\n        'last-modified'?: string;\n        'location'?: string;\n        'pragma'?: string;\n        'proxy-authenticate'?: string;\n        'public-key-pins'?: string;\n        'referer'?: string;\n        'retry-after'?: string;\n        'set-cookie'?: string[];\n        'strict-transport-security'?: string;\n        'trailer'?: string;\n        'transfer-encoding'?: string;\n        'tk'?: string;\n        'upgrade'?: string;\n        'user-agent'?: string;\n        'vary'?: string;\n        'via'?: string;\n        'warning'?: string;\n        'www-authenticate'?: string;\n        [header: string]: string | string[] | undefined;\n    }\n\n    // outgoing headers allows numbers (as they are converted internally to strings)\n    interface OutgoingHttpHeaders {\n        [header: string]: number | string | string[] | undefined;\n    }\n\n    interface ClientRequestArgs {\n        protocol?: string;\n        host?: string;\n        hostname?: string;\n        family?: number;\n        port?: number | string;\n        defaultPort?: number | string;\n        localAddress?: string;\n        socketPath?: string;\n        method?: string;\n        path?: string;\n        headers?: OutgoingHttpHeaders;\n        auth?: string;\n        agent?: Agent | boolean;\n        _defaultAgent?: Agent;\n        timeout?: number;\n        // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L278\n        createConnection?: (options: ClientRequestArgs, oncreate: (err: Error, socket: net.Socket) => void) => net.Socket;\n    }\n\n    class Server extends net.Server {\n        constructor(requestListener?: (req: IncomingMessage, res: ServerResponse) => void);\n\n        setTimeout(msecs?: number, callback?: () => void): this;\n        setTimeout(callback: () => void): this;\n        maxHeadersCount: number;\n        timeout: number;\n        keepAliveTimeout: number;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js\n    class OutgoingMessage extends stream.Writable {\n        upgrading: boolean;\n        chunkedEncoding: boolean;\n        shouldKeepAlive: boolean;\n        useChunkedEncodingByDefault: boolean;\n        sendDate: boolean;\n        finished: boolean;\n        headersSent: boolean;\n        connection: net.Socket;\n\n        constructor();\n\n        setTimeout(msecs: number, callback?: () => void): this;\n        setHeader(name: string, value: number | string | string[]): void;\n        getHeader(name: string): number | string | string[] | undefined;\n        getHeaders(): OutgoingHttpHeaders;\n        getHeaderNames(): string[];\n        hasHeader(name: string): boolean;\n        removeHeader(name: string): void;\n        addTrailers(headers: OutgoingHttpHeaders | Array<[string, string]>): void;\n        flushHeaders(): void;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_server.js#L108-L256\n    class ServerResponse extends OutgoingMessage {\n        statusCode: number;\n        statusMessage: string;\n\n        constructor(req: IncomingMessage);\n\n        assignSocket(socket: net.Socket): void;\n        detachSocket(socket: net.Socket): void;\n        // https://github.com/nodejs/node/blob/master/test/parallel/test-http-write-callbacks.js#L53\n        // no args in writeContinue callback\n        writeContinue(callback?: () => void): void;\n        writeHead(statusCode: number, reasonPhrase?: string, headers?: OutgoingHttpHeaders): void;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L77\n    class ClientRequest extends OutgoingMessage {\n        connection: net.Socket;\n        socket: net.Socket;\n        aborted: number;\n\n        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);\n\n        abort(): void;\n        onSocket(socket: net.Socket): void;\n        setTimeout(timeout: number, callback?: () => void): this;\n        setNoDelay(noDelay?: boolean): void;\n        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;\n    }\n\n    class IncomingMessage extends stream.Readable {\n        constructor(socket: net.Socket);\n\n        httpVersion: string;\n        httpVersionMajor: number;\n        httpVersionMinor: number;\n        connection: net.Socket;\n        headers: IncomingHttpHeaders;\n        rawHeaders: string[];\n        trailers: { [key: string]: string | undefined };\n        rawTrailers: string[];\n        setTimeout(msecs: number, callback: () => void): this;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        method?: string;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        url?: string;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusCode?: number;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusMessage?: string;\n        socket: net.Socket;\n        destroy(error?: Error): void;\n    }\n\n    interface AgentOptions {\n        /**\n         * Keep sockets around in a pool to be used by other requests in the future. Default = false\n         */\n        keepAlive?: boolean;\n        /**\n         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.\n         * Only relevant if keepAlive is set to true.\n         */\n        keepAliveMsecs?: number;\n        /**\n         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity\n         */\n        maxSockets?: number;\n        /**\n         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.\n         */\n        maxFreeSockets?: number;\n        /**\n         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.\n         */\n        timeout?: number;\n    }\n\n    class Agent {\n        maxFreeSockets: number;\n        maxSockets: number;\n        sockets: any;\n        requests: any;\n\n        constructor(opts?: AgentOptions);\n\n        /**\n         * Destroy any sockets that are currently in use by the agent.\n         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,\n         * then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,\n         * sockets may hang open for quite a long time before the server terminates them.\n         */\n        destroy(): void;\n    }\n\n    const METHODS: string[];\n\n    const STATUS_CODES: {\n        [errorCode: number]: string | undefined;\n        [errorCode: string]: string | undefined;\n    };\n\n    function createServer(requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server;\n    function createClient(port?: number, host?: string): any;\n\n    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,\n    // create interface RequestOptions would make the naming more clear to developers\n    interface RequestOptions extends ClientRequestArgs { }\n    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    let globalAgent: Agent;\n}\n\ndeclare module \"cluster\" {\n    import * as child from \"child_process\";\n    import * as events from \"events\";\n    import * as net from \"net\";\n\n    // interfaces\n    interface ClusterSettings {\n        execArgv?: string[]; // default: process.execArgv\n        exec?: string;\n        args?: string[];\n        silent?: boolean;\n        stdio?: any[];\n        uid?: number;\n        gid?: number;\n        inspectPort?: number | (() => number);\n    }\n\n    interface Address {\n        address: string;\n        port: number;\n        addressType: number | \"udp4\" | \"udp6\";  // 4, 6, -1, \"udp4\", \"udp6\"\n    }\n\n    class Worker extends events.EventEmitter {\n        id: number;\n        process: child.ChildProcess;\n        suicide: boolean;\n        send(message: any, sendHandle?: any, callback?: (error: Error) => void): boolean;\n        kill(signal?: string): void;\n        destroy(signal?: string): void;\n        disconnect(): void;\n        isConnected(): boolean;\n        isDead(): boolean;\n        exitedAfterDisconnect: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. error\n         *   3. exit\n         *   4. listening\n         *   5. message\n         *   6. online\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"listening\", listener: (address: Address) => void): this;\n        addListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"exit\", code: number, signal: string): boolean;\n        emit(event: \"listening\", address: Address): boolean;\n        emit(event: \"message\", message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        on(event: \"listening\", listener: (address: Address) => void): this;\n        on(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        once(event: \"listening\", listener: (address: Address) => void): this;\n        once(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: \"online\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependOnceListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: \"online\", listener: () => void): this;\n    }\n\n    interface Cluster extends events.EventEmitter {\n        Worker: Worker;\n        disconnect(callback?: Function): void;\n        fork(env?: any): Worker;\n        isMaster: boolean;\n        isWorker: boolean;\n        // TODO: cluster.schedulingPolicy\n        settings: ClusterSettings;\n        setupMaster(settings?: ClusterSettings): void;\n        worker?: Worker;\n        workers?: {\n            [index: string]: Worker | undefined\n        };\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. exit\n         *   3. fork\n         *   4. listening\n         *   5. message\n         *   6. online\n         *   7. setup\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        addListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: (worker: Worker) => void): this;\n        addListener(event: \"setup\", listener: (settings: any) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\", worker: Worker): boolean;\n        emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\n        emit(event: \"fork\", worker: Worker): boolean;\n        emit(event: \"listening\", worker: Worker, address: Address): boolean;\n        emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\", worker: Worker): boolean;\n        emit(event: \"setup\", settings: any): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        on(event: \"fork\", listener: (worker: Worker) => void): this;\n        on(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: (worker: Worker) => void): this;\n        on(event: \"setup\", listener: (settings: any) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        once(event: \"fork\", listener: (worker: Worker) => void): this;\n        once(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: (worker: Worker) => void): this;\n        once(event: \"setup\", listener: (settings: any) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"setup\", listener: (settings: any) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;\n        prependOnceListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"setup\", listener: (settings: any) => void): this;\n    }\n\n    function disconnect(callback?: Function): void;\n    function fork(env?: any): Worker;\n    const isMaster: boolean;\n    const isWorker: boolean;\n    // TODO: cluster.schedulingPolicy\n    const settings: ClusterSettings;\n    function setupMaster(settings?: ClusterSettings): void;\n    const worker: Worker;\n    const workers: {\n        [index: string]: Worker | undefined\n    };\n\n    /**\n     * events.EventEmitter\n     *   1. disconnect\n     *   2. exit\n     *   3. fork\n     *   4. listening\n     *   5. message\n     *   6. online\n     *   7. setup\n     */\n    function addListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function addListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function addListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function addListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function emit(event: string | symbol, ...args: any[]): boolean;\n    function emit(event: \"disconnect\", worker: Worker): boolean;\n    function emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\n    function emit(event: \"fork\", worker: Worker): boolean;\n    function emit(event: \"listening\", worker: Worker, address: Address): boolean;\n    function emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n    function emit(event: \"online\", worker: Worker): boolean;\n    function emit(event: \"setup\", settings: any): boolean;\n\n    function on(event: string, listener: (...args: any[]) => void): Cluster;\n    function on(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function on(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n    function on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function on(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function once(event: string, listener: (...args: any[]) => void): Cluster;\n    function once(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function once(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n    function once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function once(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function removeListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function removeAllListeners(event?: string): Cluster;\n    function setMaxListeners(n: number): Cluster;\n    function getMaxListeners(): number;\n    function listeners(event: string): Function[];\n    function listenerCount(type: string): number;\n\n    function prependListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function prependOnceListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependOnceListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function eventNames(): string[];\n}\n\ndeclare module \"zlib\" {\n    import * as stream from \"stream\";\n\n    interface ZlibOptions {\n        flush?: number; // default: zlib.constants.Z_NO_FLUSH\n        finishFlush?: number; // default: zlib.constants.Z_FINISH\n        chunkSize?: number; // default: 16*1024\n        windowBits?: number;\n        level?: number; // compression only\n        memLevel?: number; // compression only\n        strategy?: number; // compression only\n        dictionary?: Buffer | NodeJS.TypedArray | DataView | ArrayBuffer; // deflate/inflate only, empty dictionary by default\n    }\n\n    interface Zlib {\n        readonly bytesRead: number;\n        close(callback?: () => void): void;\n        flush(kind?: number | (() => void), callback?: () => void): void;\n    }\n\n    interface ZlibParams {\n        params(level: number, strategy: number, callback: () => void): void;\n    }\n\n    interface ZlibReset {\n        reset(): void;\n    }\n\n    interface Gzip extends stream.Transform, Zlib { }\n    interface Gunzip extends stream.Transform, Zlib { }\n    interface Deflate extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface Inflate extends stream.Transform, Zlib, ZlibReset { }\n    interface DeflateRaw extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface InflateRaw extends stream.Transform, Zlib, ZlibReset { }\n    interface Unzip extends stream.Transform, Zlib { }\n\n    function createGzip(options?: ZlibOptions): Gzip;\n    function createGunzip(options?: ZlibOptions): Gunzip;\n    function createDeflate(options?: ZlibOptions): Deflate;\n    function createInflate(options?: ZlibOptions): Inflate;\n    function createDeflateRaw(options?: ZlibOptions): DeflateRaw;\n    function createInflateRaw(options?: ZlibOptions): InflateRaw;\n    function createUnzip(options?: ZlibOptions): Unzip;\n\n    type InputType = string | Buffer | DataView | ArrayBuffer | NodeJS.TypedArray;\n    function deflate(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflate(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function deflateRaw(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateRaw(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function gzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function gzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gunzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function gunzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function gunzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflate(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflate(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflateRaw(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateRaw(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function unzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function unzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function unzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n\n    namespace constants {\n        // Allowed flush values.\n\n        const Z_NO_FLUSH: number;\n        const Z_PARTIAL_FLUSH: number;\n        const Z_SYNC_FLUSH: number;\n        const Z_FULL_FLUSH: number;\n        const Z_FINISH: number;\n        const Z_BLOCK: number;\n        const Z_TREES: number;\n\n        // Return codes for the compression/decompression functions. Negative values are errors, positive values are used for special but normal events.\n\n        const Z_OK: number;\n        const Z_STREAM_END: number;\n        const Z_NEED_DICT: number;\n        const Z_ERRNO: number;\n        const Z_STREAM_ERROR: number;\n        const Z_DATA_ERROR: number;\n        const Z_MEM_ERROR: number;\n        const Z_BUF_ERROR: number;\n        const Z_VERSION_ERROR: number;\n\n        // Compression levels.\n\n        const Z_NO_COMPRESSION: number;\n        const Z_BEST_SPEED: number;\n        const Z_BEST_COMPRESSION: number;\n        const Z_DEFAULT_COMPRESSION: number;\n\n        // Compression strategy.\n\n        const Z_FILTERED: number;\n        const Z_HUFFMAN_ONLY: number;\n        const Z_RLE: number;\n        const Z_FIXED: number;\n        const Z_DEFAULT_STRATEGY: number;\n    }\n\n    // Constants\n    const Z_NO_FLUSH: number;\n    const Z_PARTIAL_FLUSH: number;\n    const Z_SYNC_FLUSH: number;\n    const Z_FULL_FLUSH: number;\n    const Z_FINISH: number;\n    const Z_BLOCK: number;\n    const Z_TREES: number;\n    const Z_OK: number;\n    const Z_STREAM_END: number;\n    const Z_NEED_DICT: number;\n    const Z_ERRNO: number;\n    const Z_STREAM_ERROR: number;\n    const Z_DATA_ERROR: number;\n    const Z_MEM_ERROR: number;\n    const Z_BUF_ERROR: number;\n    const Z_VERSION_ERROR: number;\n    const Z_NO_COMPRESSION: number;\n    const Z_BEST_SPEED: number;\n    const Z_BEST_COMPRESSION: number;\n    const Z_DEFAULT_COMPRESSION: number;\n    const Z_FILTERED: number;\n    const Z_HUFFMAN_ONLY: number;\n    const Z_RLE: number;\n    const Z_FIXED: number;\n    const Z_DEFAULT_STRATEGY: number;\n    const Z_BINARY: number;\n    const Z_TEXT: number;\n    const Z_ASCII: number;\n    const Z_UNKNOWN: number;\n    const Z_DEFLATED: number;\n}\n\ndeclare module \"os\" {\n    interface CpuInfo {\n        model: string;\n        speed: number;\n        times: {\n            user: number;\n            nice: number;\n            sys: number;\n            idle: number;\n            irq: number;\n        };\n    }\n\n    interface NetworkInterfaceBase {\n        address: string;\n        netmask: string;\n        mac: string;\n        internal: boolean;\n        cidr: string | null;\n    }\n\n    interface NetworkInterfaceInfoIPv4 extends NetworkInterfaceBase {\n        family: \"IPv4\";\n    }\n\n    interface NetworkInterfaceInfoIPv6 extends NetworkInterfaceBase {\n        family: \"IPv6\";\n        scopeid: number;\n    }\n\n    type NetworkInterfaceInfo = NetworkInterfaceInfoIPv4 | NetworkInterfaceInfoIPv6;\n\n    function hostname(): string;\n    function loadavg(): number[];\n    function uptime(): number;\n    function freemem(): number;\n    function totalmem(): number;\n    function cpus(): CpuInfo[];\n    function type(): string;\n    function release(): string;\n    function networkInterfaces(): { [index: string]: NetworkInterfaceInfo[] };\n    function homedir(): string;\n    function userInfo(options?: { encoding: string }): { username: string, uid: number, gid: number, shell: any, homedir: string };\n    const constants: {\n        UV_UDP_REUSEADDR: number;\n        signals: {\n            SIGHUP: number;\n            SIGINT: number;\n            SIGQUIT: number;\n            SIGILL: number;\n            SIGTRAP: number;\n            SIGABRT: number;\n            SIGIOT: number;\n            SIGBUS: number;\n            SIGFPE: number;\n            SIGKILL: number;\n            SIGUSR1: number;\n            SIGSEGV: number;\n            SIGUSR2: number;\n            SIGPIPE: number;\n            SIGALRM: number;\n            SIGTERM: number;\n            SIGCHLD: number;\n            SIGSTKFLT: number;\n            SIGCONT: number;\n            SIGSTOP: number;\n            SIGTSTP: number;\n            SIGTTIN: number;\n            SIGTTOU: number;\n            SIGURG: number;\n            SIGXCPU: number;\n            SIGXFSZ: number;\n            SIGVTALRM: number;\n            SIGPROF: number;\n            SIGWINCH: number;\n            SIGIO: number;\n            SIGPOLL: number;\n            SIGPWR: number;\n            SIGSYS: number;\n            SIGUNUSED: number;\n        };\n        errno: {\n            E2BIG: number;\n            EACCES: number;\n            EADDRINUSE: number;\n            EADDRNOTAVAIL: number;\n            EAFNOSUPPORT: number;\n            EAGAIN: number;\n            EALREADY: number;\n            EBADF: number;\n            EBADMSG: number;\n            EBUSY: number;\n            ECANCELED: number;\n            ECHILD: number;\n            ECONNABORTED: number;\n            ECONNREFUSED: number;\n            ECONNRESET: number;\n            EDEADLK: number;\n            EDESTADDRREQ: number;\n            EDOM: number;\n            EDQUOT: number;\n            EEXIST: number;\n            EFAULT: number;\n            EFBIG: number;\n            EHOSTUNREACH: number;\n            EIDRM: number;\n            EILSEQ: number;\n            EINPROGRESS: number;\n            EINTR: number;\n            EINVAL: number;\n            EIO: number;\n            EISCONN: number;\n            EISDIR: number;\n            ELOOP: number;\n            EMFILE: number;\n            EMLINK: number;\n            EMSGSIZE: number;\n            EMULTIHOP: number;\n            ENAMETOOLONG: number;\n            ENETDOWN: number;\n            ENETRESET: number;\n            ENETUNREACH: number;\n            ENFILE: number;\n            ENOBUFS: number;\n            ENODATA: number;\n            ENODEV: number;\n            ENOENT: number;\n            ENOEXEC: number;\n            ENOLCK: number;\n            ENOLINK: number;\n            ENOMEM: number;\n            ENOMSG: number;\n            ENOPROTOOPT: number;\n            ENOSPC: number;\n            ENOSR: number;\n            ENOSTR: number;\n            ENOSYS: number;\n            ENOTCONN: number;\n            ENOTDIR: number;\n            ENOTEMPTY: number;\n            ENOTSOCK: number;\n            ENOTSUP: number;\n            ENOTTY: number;\n            ENXIO: number;\n            EOPNOTSUPP: number;\n            EOVERFLOW: number;\n            EPERM: number;\n            EPIPE: number;\n            EPROTO: number;\n            EPROTONOSUPPORT: number;\n            EPROTOTYPE: number;\n            ERANGE: number;\n            EROFS: number;\n            ESPIPE: number;\n            ESRCH: number;\n            ESTALE: number;\n            ETIME: number;\n            ETIMEDOUT: number;\n            ETXTBSY: number;\n            EWOULDBLOCK: number;\n            EXDEV: number;\n        };\n        priority: {\n            PRIORITY_LOW: number;\n            PRIORITY_BELOW_NORMAL: number;\n            PRIORITY_NORMAL: number;\n            PRIORITY_ABOVE_NORMAL: number;\n            PRIORITY_HIGH: number;\n            PRIORITY_HIGHEST: number;\n        }\n    };\n    function arch(): string;\n    function platform(): NodeJS.Platform;\n    function tmpdir(): string;\n    const EOL: string;\n    function endianness(): \"BE\" | \"LE\";\n    /**\n     * Gets the priority of a process.\n     * Defaults to current process.\n     */\n    function getPriority(pid?: number): number;\n    /**\n     * Sets the priority of the current process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(priority: number): void;\n    /**\n     * Sets the priority of the process specified process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(pid: number, priority: number): void;\n}\n\ndeclare module \"https\" {\n    import * as tls from \"tls\";\n    import * as events from \"events\";\n    import * as http from \"http\";\n    import { URL } from \"url\";\n\n    type ServerOptions = tls.SecureContextOptions & tls.TlsOptions;\n\n    type RequestOptions = http.RequestOptions & tls.SecureContextOptions & {\n        rejectUnauthorized?: boolean; // Defaults to true\n        servername?: string; // SNI TLS Extension\n    };\n\n    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {\n        rejectUnauthorized?: boolean;\n        maxCachedSessions?: number;\n    }\n\n    class Agent extends http.Agent {\n        constructor(options?: AgentOptions);\n        options: AgentOptions;\n    }\n\n    class Server extends tls.Server {\n        setTimeout(callback: () => void): this;\n        setTimeout(msecs?: number, callback?: () => void): this;\n        timeout: number;\n        keepAliveTimeout: number;\n    }\n\n    function createServer(options: ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): Server;\n    function request(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    let globalAgent: Agent;\n}\n\ndeclare module \"punycode\" {\n    function decode(string: string): string;\n    function encode(string: string): string;\n    function toUnicode(domain: string): string;\n    function toASCII(domain: string): string;\n    const ucs2: ucs2;\n    interface ucs2 {\n        decode(string: string): number[];\n        encode(codePoints: number[]): string;\n    }\n    const version: any;\n}\n\ndeclare module \"repl\" {\n    import * as stream from \"stream\";\n    import * as readline from \"readline\";\n\n    interface ReplOptions {\n        prompt?: string;\n        input?: NodeJS.ReadableStream;\n        output?: NodeJS.WritableStream;\n        terminal?: boolean;\n        eval?: Function;\n        useColors?: boolean;\n        useGlobal?: boolean;\n        ignoreUndefined?: boolean;\n        writer?: Function;\n        completer?: Function;\n        replMode?: any;\n        breakEvalOnSigint?: any;\n    }\n\n    interface REPLServer extends readline.ReadLine {\n        context: any;\n        inputStream: NodeJS.ReadableStream;\n        outputStream: NodeJS.WritableStream;\n\n        defineCommand(keyword: string, cmd: Function | { help: string, action: Function }): void;\n        displayPrompt(preserveCursor?: boolean): void;\n\n        /**\n         * events.EventEmitter\n         * 1. exit\n         * 2. reset\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"exit\", listener: () => void): this;\n        addListener(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"exit\"): boolean;\n        emit(event: \"reset\", context: any): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"exit\", listener: () => void): this;\n        on(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"exit\", listener: () => void): this;\n        once(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"exit\", listener: () => void): this;\n        prependListener(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"exit\", listener: () => void): this;\n        prependOnceListener(event: \"reset\", listener: (...args: any[]) => void): this;\n    }\n\n    function start(options?: string | ReplOptions): REPLServer;\n\n    class Recoverable extends SyntaxError {\n        err: Error;\n\n        constructor(err: Error);\n    }\n}\n\ndeclare module \"readline\" {\n    import * as events from \"events\";\n    import * as stream from \"stream\";\n\n    interface Key {\n        sequence?: string;\n        name?: string;\n        ctrl?: boolean;\n        meta?: boolean;\n        shift?: boolean;\n    }\n\n    interface ReadLine extends events.EventEmitter {\n        setPrompt(prompt: string): void;\n        prompt(preserveCursor?: boolean): void;\n        question(query: string, callback: (answer: string) => void): void;\n        pause(): ReadLine;\n        resume(): ReadLine;\n        close(): void;\n        write(data: string | Buffer, key?: Key): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. line\n         * 3. pause\n         * 4. resume\n         * 5. SIGCONT\n         * 6. SIGINT\n         * 7. SIGTSTP\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"line\", listener: (input: any) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: \"SIGCONT\", listener: () => void): this;\n        addListener(event: \"SIGINT\", listener: () => void): this;\n        addListener(event: \"SIGTSTP\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"line\", input: any): boolean;\n        emit(event: \"pause\"): boolean;\n        emit(event: \"resume\"): boolean;\n        emit(event: \"SIGCONT\"): boolean;\n        emit(event: \"SIGINT\"): boolean;\n        emit(event: \"SIGTSTP\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"line\", listener: (input: any) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: \"SIGCONT\", listener: () => void): this;\n        on(event: \"SIGINT\", listener: () => void): this;\n        on(event: \"SIGTSTP\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"line\", listener: (input: any) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: \"SIGCONT\", listener: () => void): this;\n        once(event: \"SIGINT\", listener: () => void): this;\n        once(event: \"SIGTSTP\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"line\", listener: (input: any) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: \"SIGCONT\", listener: () => void): this;\n        prependListener(event: \"SIGINT\", listener: () => void): this;\n        prependListener(event: \"SIGTSTP\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"line\", listener: (input: any) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: \"SIGCONT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGINT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGTSTP\", listener: () => void): this;\n    }\n\n    type Completer = (line: string) => CompleterResult;\n    type AsyncCompleter = (line: string, callback: (err: any, result: CompleterResult) => void) => any;\n\n    type CompleterResult = [string[], string];\n\n    interface ReadLineOptions {\n        input: NodeJS.ReadableStream;\n        output?: NodeJS.WritableStream;\n        completer?: Completer | AsyncCompleter;\n        terminal?: boolean;\n        historySize?: number;\n        prompt?: string;\n        crlfDelay?: number;\n        removeHistoryDuplicates?: boolean;\n    }\n\n    function createInterface(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean): ReadLine;\n    function createInterface(options: ReadLineOptions): ReadLine;\n\n    function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number): void;\n    function emitKeypressEvents(stream: NodeJS.ReadableStream, interface?: ReadLine): void;\n    function moveCursor(stream: NodeJS.WritableStream, dx: number | string, dy: number | string): void;\n    function clearLine(stream: NodeJS.WritableStream, dir: number): void;\n    function clearScreenDown(stream: NodeJS.WritableStream): void;\n}\n\ndeclare module \"vm\" {\n    interface Context { }\n    interface BaseOptions {\n        /**\n         * Specifies the filename used in stack traces produced by this script.\n         * Default: `''`.\n         */\n        filename?: string;\n        /**\n         * Specifies the line number offset that is displayed in stack traces produced by this script.\n         * Default: `0`.\n         */\n        lineOffset?: number;\n        /**\n         * Specifies the column number offset that is displayed in stack traces produced by this script.\n         * Default: `0`\n         */\n        columnOffset?: number;\n    }\n    interface ScriptOptions extends BaseOptions {\n        displayErrors?: boolean;\n        timeout?: number;\n        cachedData?: Buffer;\n        produceCachedData?: boolean;\n    }\n    interface RunningScriptOptions extends BaseOptions {\n        displayErrors?: boolean;\n        timeout?: number;\n    }\n    interface CompileFunctionOptions extends BaseOptions {\n        /**\n         * Provides an optional data with V8's code cache data for the supplied source.\n         */\n        cachedData?: Buffer;\n        /**\n         * Specifies whether to produce new cache data.\n         * Default: `false`,\n         */\n        produceCachedData?: boolean;\n        /**\n         * The sandbox/context in which the said function should be compiled in.\n         */\n        parsingContext?: Context;\n\n        /**\n         * An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling\n         */\n        contextExtensions?: Object[];\n    }\n    class Script {\n        constructor(code: string, options?: ScriptOptions);\n        runInContext(contextifiedSandbox: Context, options?: RunningScriptOptions): any;\n        runInNewContext(sandbox?: Context, options?: RunningScriptOptions): any;\n        runInThisContext(options?: RunningScriptOptions): any;\n    }\n    function createContext(sandbox?: Context): Context;\n    function isContext(sandbox: Context): boolean;\n    function runInContext(code: string, contextifiedSandbox: Context, options?: RunningScriptOptions | string): any;\n    function runInNewContext(code: string, sandbox?: Context, options?: RunningScriptOptions | string): any;\n    function runInThisContext(code: string, options?: RunningScriptOptions | string): any;\n    function compileFunction(code: string, params: string[], options: CompileFunctionOptions): Function;\n}\n\ndeclare module \"child_process\" {\n    import * as events from \"events\";\n    import * as stream from \"stream\";\n    import * as net from \"net\";\n\n    interface ChildProcess extends events.EventEmitter {\n        stdin: stream.Writable;\n        stdout: stream.Readable;\n        stderr: stream.Readable;\n        stdio: [stream.Writable, stream.Readable, stream.Readable];\n        killed: boolean;\n        pid: number;\n        kill(signal?: string): void;\n        send(message: any, callback?: (error: Error) => void): boolean;\n        send(message: any, sendHandle?: net.Socket | net.Server, callback?: (error: Error) => void): boolean;\n        send(message: any, sendHandle?: net.Socket | net.Server, options?: MessageOptions, callback?: (error: Error) => void): boolean;\n        connected: boolean;\n        disconnect(): void;\n        unref(): void;\n        ref(): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. disconnect\n         * 3. error\n         * 4. exit\n         * 5. message\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", code: number, signal: string): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"exit\", code: number, signal: string): boolean;\n        emit(event: \"message\", message: any, sendHandle: net.Socket | net.Server): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (code: number, signal: string) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        on(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (code: number, signal: string) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        once(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n    }\n\n    interface MessageOptions {\n        keepOpen?: boolean;\n    }\n\n    type StdioOptions = \"pipe\" | \"ignore\" | \"inherit\" | Array<(\"pipe\" | \"ipc\" | \"ignore\" | \"inherit\" | stream.Stream | number | null | undefined)>;\n\n    interface SpawnOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        argv0?: string;\n        stdio?: StdioOptions;\n        detached?: boolean;\n        uid?: number;\n        gid?: number;\n        shell?: boolean | string;\n        windowsVerbatimArguments?: boolean;\n        windowsHide?: boolean;\n    }\n\n    function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): ChildProcess;\n\n    interface ExecOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        shell?: string;\n        timeout?: number;\n        maxBuffer?: number;\n        killSignal?: string;\n        uid?: number;\n        gid?: number;\n        windowsHide?: boolean;\n    }\n\n    interface ExecOptionsWithStringEncoding extends ExecOptions {\n        encoding: BufferEncoding;\n    }\n\n    interface ExecOptionsWithBufferEncoding extends ExecOptions {\n        encoding: string | null; // specify `null`.\n    }\n\n    interface ExecException extends Error {\n        cmd?: string;\n        killed?: boolean;\n        code?: number;\n        signal?: string;\n    }\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function exec(command: string, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function exec(command: string, options: { encoding: \"buffer\" | null } & ExecOptions, callback?: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: { encoding: BufferEncoding } & ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function exec(command: string, options: { encoding: string } & ExecOptions, callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function exec(\n        command: string,\n        options: ({ encoding?: string | null } & ExecOptions) | undefined | null,\n        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exec {\n        function __promisify__(command: string): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: { encoding: \"buffer\" | null } & ExecOptions): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(command: string, options: { encoding: BufferEncoding } & ExecOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: ExecOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options?: ({ encoding?: string | null } & ExecOptions) | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ExecFileOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        timeout?: number;\n        maxBuffer?: number;\n        killSignal?: string;\n        uid?: number;\n        gid?: number;\n        windowsHide?: boolean;\n        windowsVerbatimArguments?: boolean;\n    }\n    interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {\n        encoding: 'buffer' | null;\n    }\n    interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {\n        encoding: string;\n    }\n\n    function execFile(file: string): ChildProcess;\n    function execFile(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n    function execFile(file: string, args?: ReadonlyArray<string> | null): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function execFile(file: string, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function execFile(file: string, options: ExecFileOptionsWithBufferEncoding, callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithBufferEncoding,\n        callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void,\n    ): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptionsWithStringEncoding, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithStringEncoding,\n        callback: (error: Error | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function execFile(\n        file: string,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function execFile(\n        file: string,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace execFile {\n        function __promisify__(file: string): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(\n            file: string,\n            args: string[] | undefined | null,\n            options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        ): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ForkOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        execPath?: string;\n        execArgv?: string[];\n        silent?: boolean;\n        stdio?: StdioOptions;\n        windowsVerbatimArguments?: boolean;\n        uid?: number;\n        gid?: number;\n    }\n    function fork(modulePath: string, args?: ReadonlyArray<string>, options?: ForkOptions): ChildProcess;\n\n    interface SpawnSyncOptions {\n        argv0?: string; // Not specified in the docs\n        cwd?: string;\n        input?: string | Buffer | NodeJS.TypedArray | DataView;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        shell?: boolean | string;\n        windowsVerbatimArguments?: boolean;\n        windowsHide?: boolean;\n    }\n    interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    interface SpawnSyncReturns<T> {\n        pid: number;\n        output: string[];\n        stdout: T;\n        stderr: T;\n        status: number;\n        signal: string;\n        error: Error;\n    }\n    function spawnSync(command: string): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n\n    interface ExecSyncOptions {\n        cwd?: string;\n        input?: string | Buffer | Uint8Array;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        shell?: string;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        windowsHide?: boolean;\n    }\n    interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execSync(command: string): Buffer;\n    function execSync(command: string, options?: ExecSyncOptionsWithStringEncoding): string;\n    function execSync(command: string, options?: ExecSyncOptionsWithBufferEncoding): Buffer;\n    function execSync(command: string, options?: ExecSyncOptions): Buffer;\n\n    interface ExecFileSyncOptions {\n        cwd?: string;\n        input?: string | Buffer | NodeJS.TypedArray | DataView;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        windowsHide?: boolean;\n        shell?: boolean | string;\n    }\n    interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execFileSync(command: string): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptions): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptions): Buffer;\n}\n\ndeclare module \"url\" {\n    import { ParsedUrlQuery } from 'querystring';\n\n    interface UrlObjectCommon {\n        auth?: string;\n        hash?: string;\n        host?: string;\n        hostname?: string;\n        href?: string;\n        path?: string;\n        pathname?: string;\n        protocol?: string;\n        search?: string;\n        slashes?: boolean;\n    }\n\n    // Input to `url.format`\n    interface UrlObject extends UrlObjectCommon {\n        port?: string | number;\n        query?: string | null | { [key: string]: any };\n    }\n\n    // Output of `url.parse`\n    interface Url extends UrlObjectCommon {\n        port?: string;\n        query?: string | null | ParsedUrlQuery;\n    }\n\n    interface UrlWithParsedQuery extends Url {\n        query: ParsedUrlQuery;\n    }\n\n    interface UrlWithStringQuery extends Url {\n        query: string | null;\n    }\n\n    function parse(urlStr: string): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: false | undefined, slashesDenoteHost?: boolean): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: true, slashesDenoteHost?: boolean): UrlWithParsedQuery;\n    function parse(urlStr: string, parseQueryString: boolean, slashesDenoteHost?: boolean): Url;\n\n    function format(URL: URL, options?: URLFormatOptions): string;\n    function format(urlObject: UrlObject | string): string;\n    function resolve(from: string, to: string): string;\n\n    function domainToASCII(domain: string): string;\n    function domainToUnicode(domain: string): string;\n\n    interface URLFormatOptions {\n        auth?: boolean;\n        fragment?: boolean;\n        search?: boolean;\n        unicode?: boolean;\n    }\n\n    class URL {\n        constructor(input: string, base?: string | URL);\n        hash: string;\n        host: string;\n        hostname: string;\n        href: string;\n        readonly origin: string;\n        password: string;\n        pathname: string;\n        port: string;\n        protocol: string;\n        search: string;\n        readonly searchParams: URLSearchParams;\n        username: string;\n        toString(): string;\n        toJSON(): string;\n    }\n\n    class URLSearchParams implements Iterable<[string, string]> {\n        constructor(init?: URLSearchParams | string | { [key: string]: string | string[] | undefined } | Iterable<[string, string]> | Array<[string, string]>);\n        append(name: string, value: string): void;\n        delete(name: string): void;\n        entries(): IterableIterator<[string, string]>;\n        forEach(callback: (value: string, name: string, searchParams: this) => void): void;\n        get(name: string): string | null;\n        getAll(name: string): string[];\n        has(name: string): boolean;\n        keys(): IterableIterator<string>;\n        set(name: string, value: string): void;\n        sort(): void;\n        toString(): string;\n        values(): IterableIterator<string>;\n        [Symbol.iterator](): IterableIterator<[string, string]>;\n    }\n}\n\ndeclare module \"dns\" {\n    // Supported getaddrinfo flags.\n    const ADDRCONFIG: number;\n    const V4MAPPED: number;\n\n    interface LookupOptions {\n        family?: number;\n        hints?: number;\n        all?: boolean;\n        verbatim?: boolean;\n    }\n\n    interface LookupOneOptions extends LookupOptions {\n        all?: false;\n    }\n\n    interface LookupAllOptions extends LookupOptions {\n        all: true;\n    }\n\n    interface LookupAddress {\n        address: string;\n        family: number;\n    }\n\n    function lookup(hostname: string, family: number, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupAllOptions, callback: (err: NodeJS.ErrnoException, addresses: LookupAddress[]) => void): void;\n    function lookup(hostname: string, options: LookupOptions, callback: (err: NodeJS.ErrnoException, address: string | LookupAddress[], family: number) => void): void;\n    function lookup(hostname: string, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lookup {\n        function __promisify__(hostname: string, options: LookupAllOptions): Promise<{ address: LookupAddress[] }>;\n        function __promisify__(hostname: string, options?: LookupOneOptions | number): Promise<{ address: string, family: number }>;\n        function __promisify__(hostname: string, options?: LookupOptions | number): Promise<{ address: string | LookupAddress[], family?: number }>;\n    }\n\n    function lookupService(address: string, port: number, callback: (err: NodeJS.ErrnoException, hostname: string, service: string) => void): void;\n\n    namespace lookupService {\n        function __promisify__(address: string, port: number): Promise<{ hostname: string, service: string }>;\n    }\n\n    interface ResolveOptions {\n        ttl: boolean;\n    }\n\n    interface ResolveWithTtlOptions extends ResolveOptions {\n        ttl: true;\n    }\n\n    interface RecordWithTtl {\n        address: string;\n        ttl: number;\n    }\n\n    /** @deprecated Use AnyARecord or AnyAaaaRecord instead. */\n    type AnyRecordWithTtl = AnyARecord | AnyAaaaRecord;\n\n    interface AnyARecord extends RecordWithTtl {\n        type: \"A\";\n    }\n\n    interface AnyAaaaRecord extends RecordWithTtl {\n        type: \"AAAA\";\n    }\n\n    interface MxRecord {\n        priority: number;\n        exchange: string;\n    }\n\n    interface AnyMxRecord extends MxRecord {\n        type: \"MX\";\n    }\n\n    interface NaptrRecord {\n        flags: string;\n        service: string;\n        regexp: string;\n        replacement: string;\n        order: number;\n        preference: number;\n    }\n\n    interface AnyNaptrRecord extends NaptrRecord {\n        type: \"NAPTR\";\n    }\n\n    interface SoaRecord {\n        nsname: string;\n        hostmaster: string;\n        serial: number;\n        refresh: number;\n        retry: number;\n        expire: number;\n        minttl: number;\n    }\n\n    interface AnySoaRecord extends SoaRecord {\n        type: \"SOA\";\n    }\n\n    interface SrvRecord {\n        priority: number;\n        weight: number;\n        port: number;\n        name: string;\n    }\n\n    interface AnySrvRecord extends SrvRecord {\n        type: \"SRV\";\n    }\n\n    interface AnyTxtRecord {\n        type: \"TXT\";\n        entries: string[];\n    }\n\n    interface AnyNsRecord {\n        type: \"NS\";\n        value: string;\n    }\n\n    interface AnyPtrRecord {\n        type: \"PTR\";\n        value: string;\n    }\n\n    interface AnyCnameRecord {\n        type: \"CNAME\";\n        value: string;\n    }\n\n    type AnyRecord = AnyARecord |\n        AnyAaaaRecord |\n        AnyCnameRecord |\n        AnyMxRecord |\n        AnyNaptrRecord |\n        AnyNsRecord |\n        AnyPtrRecord |\n        AnySoaRecord |\n        AnySrvRecord |\n        AnyTxtRecord;\n\n    function resolve(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"A\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"AAAA\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"ANY\", callback: (err: NodeJS.ErrnoException, addresses: AnyRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"CNAME\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"MX\", callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"NAPTR\", callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"NS\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"PTR\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"SOA\", callback: (err: NodeJS.ErrnoException, addresses: SoaRecord) => void): void;\n    function resolve(hostname: string, rrtype: \"SRV\", callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"TXT\", callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\n    function resolve(\n        hostname: string,\n        rrtype: string,\n        callback: (err: NodeJS.ErrnoException, addresses: string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve {\n        function __promisify__(hostname: string, rrtype?: \"A\" | \"AAAA\" | \"CNAME\" | \"NS\" | \"PTR\"): Promise<string[]>;\n        function __promisify__(hostname: string, rrtype: \"ANY\"): Promise<AnyRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"MX\"): Promise<MxRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"NAPTR\"): Promise<NaptrRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"SOA\"): Promise<SoaRecord>;\n        function __promisify__(hostname: string, rrtype: \"SRV\"): Promise<SrvRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"TXT\"): Promise<string[][]>;\n        function __promisify__(hostname: string, rrtype: string): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]>;\n    }\n\n    function resolve4(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve4(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\n    function resolve4(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve4 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolve6(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve6(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\n    function resolve6(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve6 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolveCname(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolveCname {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveMx(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\n    namespace resolveMx {\n        function __promisify__(hostname: string): Promise<MxRecord[]>;\n    }\n\n    function resolveNaptr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\n    namespace resolveNaptr {\n        function __promisify__(hostname: string): Promise<NaptrRecord[]>;\n    }\n\n    function resolveNs(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolveNs {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolvePtr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolvePtr {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveSoa(hostname: string, callback: (err: NodeJS.ErrnoException, address: SoaRecord) => void): void;\n    namespace resolveSoa {\n        function __promisify__(hostname: string): Promise<SoaRecord>;\n    }\n\n    function resolveSrv(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\n    namespace resolveSrv {\n        function __promisify__(hostname: string): Promise<SrvRecord[]>;\n    }\n\n    function resolveTxt(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\n    namespace resolveTxt {\n        function __promisify__(hostname: string): Promise<string[][]>;\n    }\n\n    function resolveAny(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: AnyRecord[]) => void): void;\n    namespace resolveAny {\n        function __promisify__(hostname: string): Promise<AnyRecord[]>;\n    }\n\n    function reverse(ip: string, callback: (err: NodeJS.ErrnoException, hostnames: string[]) => void): void;\n    function setServers(servers: string[]): void;\n    function getServers(): string[];\n\n    // Error codes\n    const NODATA: string;\n    const FORMERR: string;\n    const SERVFAIL: string;\n    const NOTFOUND: string;\n    const NOTIMP: string;\n    const REFUSED: string;\n    const BADQUERY: string;\n    const BADNAME: string;\n    const BADFAMILY: string;\n    const BADRESP: string;\n    const CONNREFUSED: string;\n    const TIMEOUT: string;\n    const EOF: string;\n    const FILE: string;\n    const NOMEM: string;\n    const DESTRUCTION: string;\n    const BADSTR: string;\n    const BADFLAGS: string;\n    const NONAME: string;\n    const BADHINTS: string;\n    const NOTINITIALIZED: string;\n    const LOADIPHLPAPI: string;\n    const ADDRGETNETWORKPARAMS: string;\n    const CANCELLED: string;\n\n    class Resolver {\n        getServers: typeof getServers;\n        setServers: typeof setServers;\n        resolve: typeof resolve;\n        resolve4: typeof resolve4;\n        resolve6: typeof resolve6;\n        resolveAny: typeof resolveAny;\n        resolveCname: typeof resolveCname;\n        resolveMx: typeof resolveMx;\n        resolveNaptr: typeof resolveNaptr;\n        resolveNs: typeof resolveNs;\n        resolvePtr: typeof resolvePtr;\n        resolveSoa: typeof resolveSoa;\n        resolveSrv: typeof resolveSrv;\n        resolveTxt: typeof resolveTxt;\n        reverse: typeof reverse;\n        cancel(): void;\n    }\n}\n\ndeclare module \"net\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import * as dns from \"dns\";\n\n    type LookupFunction = (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void) => void;\n\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface SocketConstructorOpts {\n        fd?: number;\n        allowHalfOpen?: boolean;\n        readable?: boolean;\n        writable?: boolean;\n    }\n\n    interface TcpSocketConnectOpts {\n        port: number;\n        host?: string;\n        localAddress?: string;\n        localPort?: number;\n        hints?: number;\n        family?: number;\n        lookup?: LookupFunction;\n    }\n\n    interface IpcSocketConnectOpts {\n        path: string;\n    }\n\n    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\n\n    class Socket extends stream.Duplex {\n        constructor(options?: SocketConstructorOpts);\n\n        // Extended base methods\n        write(buffer: Buffer): boolean;\n        write(buffer: Buffer, cb?: Function): boolean;\n        write(str: string, cb?: Function): boolean;\n        write(str: string, encoding?: string, cb?: Function): boolean;\n        write(str: string, encoding?: string, fd?: string): boolean;\n        write(data: any, encoding?: string, callback?: Function): void;\n\n        connect(options: SocketConnectOpts, connectionListener?: Function): this;\n        connect(port: number, host: string, connectionListener?: Function): this;\n        connect(port: number, connectionListener?: Function): this;\n        connect(path: string, connectionListener?: Function): this;\n\n        setEncoding(encoding?: string): this;\n        pause(): this;\n        resume(): this;\n        setTimeout(timeout: number, callback?: Function): this;\n        setNoDelay(noDelay?: boolean): this;\n        setKeepAlive(enable?: boolean, initialDelay?: number): this;\n        address(): AddressInfo | string;\n        unref(): void;\n        ref(): void;\n\n        readonly bufferSize: number;\n        readonly bytesRead: number;\n        readonly bytesWritten: number;\n        readonly connecting: boolean;\n        readonly destroyed: boolean;\n        readonly localAddress: string;\n        readonly localPort: number;\n        readonly remoteAddress?: string;\n        readonly remoteFamily?: string;\n        readonly remotePort?: number;\n\n        // Extended base methods\n        end(): void;\n        end(buffer: Buffer, cb?: Function): void;\n        end(str: string, cb?: Function): void;\n        end(str: string, encoding?: string, cb?: Function): void;\n        end(data?: any, encoding?: string): void;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connect\n         *   3. data\n         *   4. drain\n         *   5. end\n         *   6. error\n         *   7. lookup\n         *   8. timeout\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        addListener(event: \"connect\", listener: () => void): this;\n        addListener(event: \"data\", listener: (data: Buffer) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", had_error: boolean): boolean;\n        emit(event: \"connect\"): boolean;\n        emit(event: \"data\", data: Buffer): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"lookup\", err: Error, address: string, family: string | number, host: string): boolean;\n        emit(event: \"timeout\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (had_error: boolean) => void): this;\n        on(event: \"connect\", listener: () => void): this;\n        on(event: \"data\", listener: (data: Buffer) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (had_error: boolean) => void): this;\n        once(event: \"connect\", listener: () => void): this;\n        once(event: \"data\", listener: (data: Buffer) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        prependListener(event: \"connect\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        prependOnceListener(event: \"connect\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n\n    interface ListenOptions {\n        port?: number;\n        host?: string;\n        backlog?: number;\n        path?: string;\n        exclusive?: boolean;\n        readableAll?: boolean;\n        writableAll?: boolean;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js\n    class Server extends events.EventEmitter {\n        constructor(connectionListener?: (socket: Socket) => void);\n        constructor(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void);\n\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: Function): this;\n        listen(port?: number, hostname?: string, listeningListener?: Function): this;\n        listen(port?: number, backlog?: number, listeningListener?: Function): this;\n        listen(port?: number, listeningListener?: Function): this;\n        listen(path: string, backlog?: number, listeningListener?: Function): this;\n        listen(path: string, listeningListener?: Function): this;\n        listen(options: ListenOptions, listeningListener?: Function): this;\n        listen(handle: any, backlog?: number, listeningListener?: Function): this;\n        listen(handle: any, listeningListener?: Function): this;\n        close(callback?: Function): this;\n        address(): AddressInfo | string;\n        getConnections(cb: (error: Error | null, count: number) => void): void;\n        ref(): this;\n        unref(): this;\n        maxConnections: number;\n        connections: number;\n        listening: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connection\n         *   3. error\n         *   4. listening\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connection\", socket: Socket): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connection\", listener: (socket: Socket) => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connection\", listener: (socket: Socket) => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n    }\n\n    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\n\n    function createServer(connectionListener?: (socket: Socket) => void): Server;\n    function createServer(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void): Server;\n    function connect(options: NetConnectOpts, connectionListener?: Function): Socket;\n    function connect(port: number, host?: string, connectionListener?: Function): Socket;\n    function connect(path: string, connectionListener?: Function): Socket;\n    function createConnection(options: NetConnectOpts, connectionListener?: Function): Socket;\n    function createConnection(port: number, host?: string, connectionListener?: Function): Socket;\n    function createConnection(path: string, connectionListener?: Function): Socket;\n    function isIP(input: string): number;\n    function isIPv4(input: string): boolean;\n    function isIPv6(input: string): boolean;\n}\n\ndeclare module \"dgram\" {\n    import { AddressInfo } from \"net\";\n    import * as dns from \"dns\";\n    import * as events from \"events\";\n\n    interface RemoteInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface BindOptions {\n        port: number;\n        address?: string;\n        exclusive?: boolean;\n    }\n\n    type SocketType = \"udp4\" | \"udp6\";\n\n    interface SocketOptions {\n        type: SocketType;\n        reuseAddr?: boolean;\n        recvBufferSize?: number;\n        sendBufferSize?: number;\n        lookup?: (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void) => void;\n    }\n\n    function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n    function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n\n    class Socket extends events.EventEmitter {\n        send(msg: Buffer | string | Uint8Array | any[], port: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: Buffer | string | Uint8Array, offset: number, length: number, port: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        bind(port?: number, address?: string, callback?: () => void): void;\n        bind(port?: number, callback?: () => void): void;\n        bind(callback?: () => void): void;\n        bind(options: BindOptions, callback?: Function): void;\n        close(callback?: () => void): void;\n        address(): AddressInfo | string;\n        setBroadcast(flag: boolean): void;\n        setTTL(ttl: number): void;\n        setMulticastTTL(ttl: number): void;\n        setMulticastInterface(multicastInterface: string): void;\n        setMulticastLoopback(flag: boolean): void;\n        addMembership(multicastAddress: string, multicastInterface?: string): void;\n        dropMembership(multicastAddress: string, multicastInterface?: string): void;\n        ref(): this;\n        unref(): this;\n        setRecvBufferSize(size: number): void;\n        setSendBufferSize(size: number): void;\n        getRecvBufferSize(): number;\n        getSendBufferSize(): number;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. error\n         * 3. listening\n         * 4. message\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n        addListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n        emit(event: \"message\", msg: Buffer, rinfo: AddressInfo): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n        on(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n        once(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n        prependListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n        prependOnceListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n    }\n}\n\ndeclare module \"fs\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import { URL } from \"url\";\n\n    /**\n     * Valid types for path values in \"fs\".\n     */\n    type PathLike = string | Buffer | URL;\n\n    type BinaryData = Buffer | DataView | NodeJS.TypedArray;\n    class Stats {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        dev: number;\n        ino: number;\n        mode: number;\n        nlink: number;\n        uid: number;\n        gid: number;\n        rdev: number;\n        size: number;\n        blksize: number;\n        blocks: number;\n        atimeMs: number;\n        mtimeMs: number;\n        ctimeMs: number;\n        birthtimeMs: number;\n        atime: Date;\n        mtime: Date;\n        ctime: Date;\n        birthtime: Date;\n    }\n\n    class Dirent {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        name: string;\n    }\n\n    interface FSWatcher extends events.EventEmitter {\n        close(): void;\n\n        /**\n         * events.EventEmitter\n         *   1. change\n         *   2. error\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n    }\n\n    class ReadStream extends stream.Readable {\n        close(): void;\n        bytesRead: number;\n        path: string | Buffer;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n    }\n\n    class WriteStream extends stream.Writable {\n        close(): void;\n        bytesWritten: number;\n        path: string | Buffer;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n    }\n\n    /**\n     * Asynchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function rename(oldPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rename {\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function renameSync(oldPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncate(path: PathLike, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function truncate(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace truncate {\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(path: PathLike, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncateSync(path: PathLike, len?: number | null): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncate(fd: number, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     */\n    function ftruncate(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace ftruncate {\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param fd A file descriptor.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(fd: number, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncateSync(fd: number, len?: number | null): void;\n\n    /**\n     * Asynchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chown {\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchown(fd: number, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchown {\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchownSync(fd: number, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchown {\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chmod {\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmod(fd: number, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchmod {\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param fd A file descriptor.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(fd: number, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmodSync(fd: number, mode: string | number): void;\n\n    /**\n     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchmod {\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function stat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace stat {\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function statSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstat(fd: number, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fstat {\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstatSync(fd: number): Stats;\n\n    /**\n     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lstat {\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstatSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function link(existingPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace link {\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function linkSync(existingPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlink(target: PathLike, path: PathLike, type: symlink.Type | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     */\n    function symlink(target: PathLike, path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace symlink {\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        type Type = \"dir\" | \"file\" | \"junction\";\n    }\n\n    /**\n     * Synchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, linkString: Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readlink {\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, resolvedPath: Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace realpath {\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        function native(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, resolvedPath: Buffer) => void): void;\n        function native(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string | Buffer) => void): void;\n        function native(path: PathLike, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n    }\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    namespace realpathSync {\n        function native(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n        function native(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n    }\n\n    /**\n     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlink(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace unlink {\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlinkSync(path: PathLike): void;\n\n    /**\n     * Asynchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rmdir {\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdirSync(path: PathLike): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(path: PathLike, mode: number | string | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function mkdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdir {\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(path: PathLike, mode?: number | string | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdirSync(path: PathLike, mode?: number | string | null): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: \"buffer\" | { encoding: \"buffer\" }, callback: (err: NodeJS.ErrnoException, folder: Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string | Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     */\n    function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdtemp {\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException, files: string[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\", callback: (err: NodeJS.ErrnoException, files: Buffer[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding?: string | null; withFileTypes?: false } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, files: string[] | Buffer[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException, files: string[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdir(path: PathLike, options: { withFileTypes: true }, callback: (err: NodeJS.ErrnoException, files: Dirent[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readdir {\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: \"buffer\" | { encoding: \"buffer\"; withFileTypes?: false }): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent\n         */\n        function __promisify__(path: PathLike, options: { withFileTypes: true }): Promise<Dirent[]>;\n    }\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): string[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): string[] | Buffer[];\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdirSync(path: PathLike, options: { withFileTypes: true }): Dirent[];\n\n    /**\n     * Asynchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function close(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace close {\n        /**\n         * Asynchronous close(2) - close a file descriptor.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function closeSync(fd: number): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace open {\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n         */\n        function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;\n    }\n\n    /**\n     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace utimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace futimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fsync {\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsyncSync(fd: number): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     */\n    function write<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     */\n    function write<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, offset: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     */\n    function write<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function write(\n        fd: number,\n        string: any,\n        position: number | undefined | null,\n        encoding: string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, str: string) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     */\n    function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace write {\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function __promisify__<TBuffer extends BinaryData>(\n            fd: number,\n            buffer?: TBuffer,\n            offset?: number,\n            length?: number,\n            position?: number | null,\n        ): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n    }\n\n    /**\n     * Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function writeSync(fd: number, buffer: BinaryData, offset?: number | null, length?: number | null, position?: number | null): number;\n\n    /**\n     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;\n\n    /**\n     * Asynchronously reads data from the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function read<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number,\n        length: number,\n        position: number | null,\n        callback?: (err: NodeJS.ErrnoException, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace read {\n        /**\n         * @param fd A file descriptor.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n         */\n        function __promisify__<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, offset: number, length: number, position: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n    }\n\n    /**\n     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function readSync(fd: number, buffer: BinaryData, offset: number, length: number, position: number | null): number;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding?: null; flag?: string; } | undefined | null, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding: string; flag?: string; } | string, callback: (err: NodeJS.ErrnoException, data: string) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(\n        path: PathLike | number,\n        options: { encoding?: string | null; flag?: string; } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, data: string | Buffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     */\n    function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readFile {\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string; } | string): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Buffer;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string; } | string): string;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): string | Buffer;\n\n    type WriteFileOptions = { encoding?: string | null; mode?: number | string; flag?: string; } | string | null;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'w'` is used.\n     */\n    function writeFile(path: PathLike | number, data: any, options: WriteFileOptions, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function writeFile(path: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace writeFile {\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'w'` is used.\n         */\n        function __promisify__(path: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'w'` is used.\n     */\n    function writeFileSync(path: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'a'` is used.\n     */\n    function appendFile(file: PathLike | number, data: any, options: WriteFileOptions, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function appendFile(file: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace appendFile {\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'a'` is used.\n         */\n        function __promisify__(file: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'a'` is used.\n     */\n    function appendFileSync(file: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     */\n    function watchFile(filename: PathLike, options: { persistent?: boolean; interval?: number; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Stop watching for changes on `filename`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: BufferEncoding | null, persistent?: boolean, recursive?: boolean } | BufferEncoding | undefined | null,\n        listener?: (event: string, filename: string) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(filename: PathLike, options: { encoding: \"buffer\", persistent?: boolean, recursive?: boolean } | \"buffer\", listener?: (event: string, filename: Buffer) => void): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: string | null, persistent?: boolean, recursive?: boolean } | string | null,\n        listener?: (event: string, filename: string | Buffer) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;\n\n    /**\n     * Asynchronously tests whether or not the given path exists by checking with the file system.\n     * @deprecated\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function exists(path: PathLike, callback: (exists: boolean) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exists {\n        /**\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike): Promise<boolean>;\n    }\n\n    /**\n     * Synchronously tests whether or not the given path exists by checking with the file system.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function existsSync(path: PathLike): boolean;\n\n    namespace constants {\n        // File Access Constants\n\n        /** Constant for fs.access(). File is visible to the calling process. */\n        const F_OK: number;\n\n        /** Constant for fs.access(). File can be read by the calling process. */\n        const R_OK: number;\n\n        /** Constant for fs.access(). File can be written by the calling process. */\n        const W_OK: number;\n\n        /** Constant for fs.access(). File can be executed by the calling process. */\n        const X_OK: number;\n\n        // File Copy Constants\n\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\n        const COPYFILE_EXCL: number;\n\n        /**\n         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.\n         */\n        const COPYFILE_FICLONE: number;\n\n        /**\n         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.\n         */\n        const COPYFILE_FICLONE_FORCE: number;\n\n        // File Open Constants\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\n        const O_RDONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\n        const O_WRONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\n        const O_RDWR: number;\n\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\n        const O_CREAT: number;\n\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\n        const O_EXCL: number;\n\n        /**\n         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,\n         * opening the path shall not cause that terminal to become the controlling terminal for the process\n         * (if the process does not already have one).\n         */\n        const O_NOCTTY: number;\n\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\n        const O_TRUNC: number;\n\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\n        const O_APPEND: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\n        const O_DIRECTORY: number;\n\n        /**\n         * constant for fs.open().\n         * Flag indicating reading accesses to the file system will no longer result in\n         * an update to the atime information associated with the file.\n         * This flag is available on Linux operating systems only.\n         */\n        const O_NOATIME: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\n        const O_NOFOLLOW: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\n        const O_SYNC: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\n        const O_DSYNC: number;\n\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\n        const O_SYMLINK: number;\n\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\n        const O_DIRECT: number;\n\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\n        const O_NONBLOCK: number;\n\n        // File Type Constants\n\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\n        const S_IFMT: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\n        const S_IFREG: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\n        const S_IFDIR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\n        const S_IFCHR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\n        const S_IFBLK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\n        const S_IFIFO: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\n        const S_IFLNK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\n        const S_IFSOCK: number;\n\n        // File Mode Constants\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\n        const S_IRWXU: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\n        const S_IRUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\n        const S_IWUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\n        const S_IXUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\n        const S_IRWXG: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\n        const S_IRGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\n        const S_IWGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\n        const S_IXGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\n        const S_IRWXO: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\n        const S_IROTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\n        const S_IWOTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\n        const S_IXOTH: number;\n    }\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, mode: number | undefined, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace access {\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike, mode?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function accessSync(path: PathLike, mode?: number): void;\n\n    /**\n     * Returns a new `ReadStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createReadStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        start?: number;\n        end?: number;\n        highWaterMark?: number;\n    }): ReadStream;\n\n    /**\n     * Returns a new `WriteStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createWriteStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        start?: number;\n    }): WriteStream;\n\n    /**\n     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fdatasync {\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasyncSync(fd: number): void;\n\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     */\n    function copyFile(src: PathLike, dest: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFile(src: PathLike, dest: PathLike, flags: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace copyFile {\n        /**\n         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n         * No arguments other than a possible exception are given to the callback function.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation.\n         * The only supported flag is fs.constants.COPYFILE_EXCL,\n         * which causes the copy operation to fail if dest already exists.\n         */\n        function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An optional integer that specifies the behavior of the copy operation.\n     * The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;\n\n    namespace promises {\n        interface FileHandle {\n            /**\n             * Gets the file descriptor for this file handle.\n             */\n            readonly fd: number;\n\n            /**\n             * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for appending.\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `'utf8'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `'a'` is used.\n             */\n            appendFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous fchown(2) - Change ownership of a file.\n             */\n            chown(uid: number, gid: number): Promise<void>;\n\n            /**\n             * Asynchronous fchmod(2) - Change permissions of a file.\n             * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n             */\n            chmod(mode: string | number): Promise<void>;\n\n            /**\n             * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n             */\n            datasync(): Promise<void>;\n\n            /**\n             * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n             */\n            sync(): Promise<void>;\n\n            /**\n             * Asynchronously reads data from the file.\n             * The `FileHandle` must have been opened for reading.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The offset in the buffer at which to start writing.\n             * @param length The number of bytes to read.\n             * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n             */\n            read<TBuffer extends Buffer | Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n            /**\n             * Asynchronous fstat(2) - Get file status.\n             */\n            stat(): Promise<Stats>;\n\n            /**\n             * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n             * @param len If not specified, defaults to `0`.\n             */\n            truncate(len?: number): Promise<void>;\n\n            /**\n             * Asynchronously change file timestamps of the file.\n             * @param atime The last access time. If a string is provided, it will be coerced to number.\n             * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n             */\n            utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n            /**\n             * Asynchronously writes `buffer` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n             * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             */\n            write<TBuffer extends Buffer | Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously writes `string` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`\n             * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n             * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             * @param encoding The expected string encoding.\n             */\n            write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n            /**\n             * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `'utf8'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `'w'` is used.\n             */\n            writeFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous close(2) - close a `FileHandle`.\n             */\n            close(): Promise<void>;\n        }\n\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function access(path: PathLike, mode?: number): Promise<void>;\n\n        /**\n         * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it already exists.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation. The only\n         * supported flag is `fs.constants.COPYFILE_EXCL`, which causes the copy operation to fail if\n         * `dest` already exists.\n         */\n        function copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;\n\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not\n         * supplied, defaults to `0o666`.\n         */\n        function open(path: PathLike, flags: string | number, mode?: string | number): Promise<FileHandle>;\n\n        /**\n         * Asynchronously reads data from the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If\n         * `null`, data will be read from the current position.\n         */\n        function read<TBuffer extends Buffer | Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function write<TBuffer extends Buffer | Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function write(handle: FileHandle, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function truncate(path: PathLike, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param handle A `FileHandle`.\n         * @param len If not specified, defaults to `0`.\n         */\n        function ftruncate(handle: FileHandle, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function rmdir(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fdatasync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fsync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function mkdir(path: PathLike, mode?: string | number): Promise<void>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param handle A `FileHandle`.\n         */\n        function fstat(handle: FileHandle): Promise<Stats>;\n\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lstat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function stat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function unlink(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param handle A `FileHandle`.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function fchmod(handle: FileHandle, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function chmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function lchmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lchown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param handle A `FileHandle`.\n         */\n        function fchown(handle: FileHandle, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function chown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function futimes(handle: FileHandle, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * It is unsafe to call `fsPromises.writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'w'` is used.\n         */\n        function writeFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'a'` is used.\n         */\n        function appendFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n    }\n}\n\ndeclare module \"path\" {\n    /**\n     * A parsed path object generated by path.parse() or consumed by path.format().\n     */\n    interface ParsedPath {\n        /**\n         * The root of the path such as '/' or 'c:\\'\n         */\n        root: string;\n        /**\n         * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n         */\n        dir: string;\n        /**\n         * The file name including extension (if any) such as 'index.html'\n         */\n        base: string;\n        /**\n         * The file extension (if any) such as '.html'\n         */\n        ext: string;\n        /**\n         * The file name without extension (if any) such as 'index'\n         */\n        name: string;\n    }\n    interface FormatInputPathObject {\n        /**\n         * The root of the path such as '/' or 'c:\\'\n         */\n        root?: string;\n        /**\n         * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n         */\n        dir?: string;\n        /**\n         * The file name including extension (if any) such as 'index.html'\n         */\n        base?: string;\n        /**\n         * The file extension (if any) such as '.html'\n         */\n        ext?: string;\n        /**\n         * The file name without extension (if any) such as 'index'\n         */\n        name?: string;\n    }\n\n    /**\n     * Normalize a string path, reducing '..' and '.' parts.\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n     *\n     * @param p string path to normalize.\n     */\n    function normalize(p: string): string;\n    /**\n     * Join all arguments together and normalize the resulting path.\n     * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.\n     *\n     * @param paths paths to join.\n     */\n    function join(...paths: string[]): string;\n    /**\n     * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.\n     *\n     * Starting from leftmost {from} paramter, resolves {to} to an absolute path.\n     *\n     * If {to} isn't already absolute, {from} arguments are prepended in right to left order,\n     * until an absolute path is found. If after using all {from} paths still no absolute path is found,\n     * the current working directory is used as well. The resulting path is normalized,\n     * and trailing slashes are removed unless the path gets resolved to the root directory.\n     *\n     * @param pathSegments string paths to join.  Non-string arguments are ignored.\n     */\n    function resolve(...pathSegments: string[]): string;\n    /**\n     * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\n     *\n     * @param path path to test.\n     */\n    function isAbsolute(path: string): boolean;\n    /**\n     * Solve the relative path from {from} to {to}.\n     * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\n     */\n    function relative(from: string, to: string): string;\n    /**\n     * Return the directory name of a path. Similar to the Unix dirname command.\n     *\n     * @param p the path to evaluate.\n     */\n    function dirname(p: string): string;\n    /**\n     * Return the last portion of a path. Similar to the Unix basename command.\n     * Often used to extract the file name from a fully qualified path.\n     *\n     * @param p the path to evaluate.\n     * @param ext optionally, an extension to remove from the result.\n     */\n    function basename(p: string, ext?: string): string;\n    /**\n     * Return the extension of the path, from the last '.' to end of string in the last portion of the path.\n     * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string\n     *\n     * @param p the path to evaluate.\n     */\n    function extname(p: string): string;\n    /**\n     * The platform-specific file separator. '\\\\' or '/'.\n     */\n    const sep: '\\\\' | '/';\n    /**\n     * The platform-specific file delimiter. ';' or ':'.\n     */\n    const delimiter: ';' | ':';\n    /**\n     * Returns an object from a path string - the opposite of format().\n     *\n     * @param pathString path to evaluate.\n     */\n    function parse(pathString: string): ParsedPath;\n    /**\n     * Returns a path string from an object - the opposite of parse().\n     *\n     * @param pathString path to evaluate.\n     */\n    function format(pathObject: FormatInputPathObject): string;\n\n    namespace posix {\n        function normalize(p: string): string;\n        function join(...paths: any[]): string;\n        function resolve(...pathSegments: any[]): string;\n        function isAbsolute(p: string): boolean;\n        function relative(from: string, to: string): string;\n        function dirname(p: string): string;\n        function basename(p: string, ext?: string): string;\n        function extname(p: string): string;\n        const sep: string;\n        const delimiter: string;\n        function parse(p: string): ParsedPath;\n        function format(pP: FormatInputPathObject): string;\n    }\n\n    namespace win32 {\n        function normalize(p: string): string;\n        function join(...paths: any[]): string;\n        function resolve(...pathSegments: any[]): string;\n        function isAbsolute(p: string): boolean;\n        function relative(from: string, to: string): string;\n        function dirname(p: string): string;\n        function basename(p: string, ext?: string): string;\n        function extname(p: string): string;\n        const sep: string;\n        const delimiter: string;\n        function parse(p: string): ParsedPath;\n        function format(pP: FormatInputPathObject): string;\n    }\n}\n\ndeclare module \"string_decoder\" {\n    interface NodeStringDecoder {\n        write(buffer: Buffer): string;\n        end(buffer?: Buffer): string;\n    }\n    const StringDecoder: {\n        new(encoding?: string): NodeStringDecoder;\n    };\n}\n\ndeclare module \"tls\" {\n    import * as crypto from \"crypto\";\n    import * as dns from \"dns\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n\n    const CLIENT_RENEG_LIMIT: number;\n    const CLIENT_RENEG_WINDOW: number;\n\n    interface Certificate {\n        /**\n         * Country code.\n         */\n        C: string;\n        /**\n         * Street.\n         */\n        ST: string;\n        /**\n         * Locality.\n         */\n        L: string;\n        /**\n         * Organization.\n         */\n        O: string;\n        /**\n         * Organizational unit.\n         */\n        OU: string;\n        /**\n         * Common name.\n         */\n        CN: string;\n    }\n\n    interface PeerCertificate {\n        subject: Certificate;\n        issuer: Certificate;\n        subjectaltname: string;\n        infoAccess: { [index: string]: string[] | undefined };\n        modulus: string;\n        exponent: string;\n        valid_from: string;\n        valid_to: string;\n        fingerprint: string;\n        ext_key_usage: string[];\n        serialNumber: string;\n        raw: Buffer;\n    }\n\n    interface DetailedPeerCertificate extends PeerCertificate {\n        issuerCertificate: DetailedPeerCertificate;\n    }\n\n    interface CipherNameAndProtocol {\n        /**\n         * The cipher name.\n         */\n        name: string;\n        /**\n         * SSL/TLS protocol version.\n         */\n        version: string;\n    }\n\n    class TLSSocket extends net.Socket {\n        /**\n         * Construct a new tls.TLSSocket object from an existing TCP socket.\n         */\n        constructor(socket: net.Socket, options?: {\n            /**\n             * An optional TLS context object from tls.createSecureContext()\n             */\n            secureContext?: SecureContext,\n            /**\n             * If true the TLS socket will be instantiated in server-mode.\n             * Defaults to false.\n             */\n            isServer?: boolean,\n            /**\n             * An optional net.Server instance.\n             */\n            server?: net.Server,\n            /**\n             * If true the server will request a certificate from clients that\n             * connect and attempt to verify that certificate. Defaults to\n             * false.\n             */\n            requestCert?: boolean,\n            /**\n             * If true the server will reject any connection which is not\n             * authorized with the list of supplied CAs. This option only has an\n             * effect if requestCert is true. Defaults to false.\n             */\n            rejectUnauthorized?: boolean,\n            /**\n             * An array of strings or a Buffer naming possible NPN protocols.\n             * (Protocols should be ordered by their priority.)\n             */\n            NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array,\n            /**\n             * An array of strings or a Buffer naming possible ALPN protocols.\n             * (Protocols should be ordered by their priority.) When the server\n             * receives both NPN and ALPN extensions from the client, ALPN takes\n             * precedence over NPN and the server does not send an NPN extension\n             * to the client.\n             */\n            ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array,\n            /**\n             * SNICallback(servername, cb) <Function> A function that will be\n             * called if the client supports SNI TLS extension. Two arguments\n             * will be passed when called: servername and cb. SNICallback should\n             * invoke cb(null, ctx), where ctx is a SecureContext instance.\n             * (tls.createSecureContext(...) can be used to get a proper\n             * SecureContext.) If SNICallback wasn't provided the default callback\n             * with high-level API will be used (see below).\n             */\n            SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void,\n            /**\n             * An optional Buffer instance containing a TLS session.\n             */\n            session?: Buffer,\n            /**\n             * If true, specifies that the OCSP status request extension will be\n             * added to the client hello and an 'OCSPResponse' event will be\n             * emitted on the socket before establishing a secure communication\n             */\n            requestOCSP?: boolean\n        });\n\n        /**\n         * A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false.\n         */\n        authorized: boolean;\n        /**\n         * The reason why the peer's certificate has not been verified.\n         * This property becomes available only when tlsSocket.authorized === false.\n         */\n        authorizationError: Error;\n        /**\n         * Static boolean value, always true.\n         * May be used to distinguish TLS sockets from regular ones.\n         */\n        encrypted: boolean;\n        /**\n         * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.\n         * @returns Returns an object representing the cipher name\n         * and the SSL/TLS protocol version of the current connection.\n         */\n        getCipher(): CipherNameAndProtocol;\n        /**\n         * Returns an object representing the peer's certificate.\n         * The returned object has some properties corresponding to the field of the certificate.\n         * If detailed argument is true the full chain with issuer property will be returned,\n         * if false only the top certificate without issuer property.\n         * If the peer does not provide a certificate, it returns null or an empty object.\n         * @param detailed - If true; the full chain with issuer property will be returned.\n         * @returns An object representing the peer's certificate.\n         */\n        getPeerCertificate(detailed: true): DetailedPeerCertificate;\n        getPeerCertificate(detailed?: false): PeerCertificate;\n        getPeerCertificate(detailed?: boolean): PeerCertificate | DetailedPeerCertificate;\n        /**\n         * Returns a string containing the negotiated SSL/TLS protocol version of the current connection.\n         * The value `'unknown'` will be returned for connected sockets that have not completed the handshaking process.\n         * The value `null` will be returned for server sockets or disconnected client sockets.\n         * See https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html for more information.\n         * @returns negotiated SSL/TLS protocol version of the current connection\n         */\n        getProtocol(): string | null;\n        /**\n         * Could be used to speed up handshake establishment when reconnecting to the server.\n         * @returns ASN.1 encoded TLS session or undefined if none was negotiated.\n         */\n        getSession(): any;\n        /**\n         * NOTE: Works only with client TLS sockets.\n         * Useful only for debugging, for session reuse provide session option to tls.connect().\n         * @returns TLS session ticket or undefined if none was negotiated.\n         */\n        getTLSTicket(): any;\n        /**\n         * Initiate TLS renegotiation process.\n         *\n         * NOTE: Can be used to request peer's certificate after the secure connection has been established.\n         * ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.\n         * @param options - The options may contain the following fields: rejectUnauthorized,\n         * requestCert (See tls.createServer() for details).\n         * @param callback - callback(err) will be executed with null as err, once the renegotiation\n         * is successfully completed.\n         */\n        renegotiate(options: { rejectUnauthorized?: boolean, requestCert?: boolean }, callback: (err: Error | null) => void): any;\n        /**\n         * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by\n         * the TLS layer until the entire fragment is received and its integrity is verified;\n         * large fragments can span multiple roundtrips, and their processing can be delayed due to packet\n         * loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,\n         * which may decrease overall server throughput.\n         * @param size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * @returns Returns true on success, false otherwise.\n         */\n        setMaxSendFragment(size: number): boolean;\n\n        /**\n         * events.EventEmitter\n         * 1. OCSPResponse\n         * 2. secureConnect\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        addListener(event: \"secureConnect\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"OCSPResponse\", response: Buffer): boolean;\n        emit(event: \"secureConnect\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        on(event: \"secureConnect\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        once(event: \"secureConnect\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependListener(event: \"secureConnect\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependOnceListener(event: \"secureConnect\", listener: () => void): this;\n    }\n\n    interface TlsOptions extends SecureContextOptions {\n        handshakeTimeout?: number;\n        requestCert?: boolean;\n        rejectUnauthorized?: boolean;\n        NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void;\n        sessionTimeout?: number;\n        ticketKeys?: Buffer;\n    }\n\n    interface ConnectionOptions extends SecureContextOptions {\n        host?: string;\n        port?: number;\n        path?: string; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.\n        socket?: net.Socket; // Establish secure connection on a given socket rather than creating a new socket\n        rejectUnauthorized?: boolean; // Defaults to true\n        NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        checkServerIdentity?: typeof checkServerIdentity;\n        servername?: string; // SNI TLS Extension\n        session?: Buffer;\n        minDHSize?: number;\n        secureContext?: SecureContext; // If not provided, the entire ConnectionOptions object will be passed to tls.createSecureContext()\n        lookup?: net.LookupFunction;\n    }\n\n    class Server extends net.Server {\n        addContext(hostName: string, credentials: {\n            key: string;\n            cert: string;\n            ca: string;\n        }): void;\n\n        /**\n         * events.EventEmitter\n         * 1. tlsClientError\n         * 2. newSession\n         * 3. OCSPRequest\n         * 4. resumeSession\n         * 5. secureConnection\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        addListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        addListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        addListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        addListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"tlsClientError\", err: Error, tlsSocket: TLSSocket): boolean;\n        emit(event: \"newSession\", sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void): boolean;\n        emit(event: \"OCSPRequest\", certificate: Buffer, issuer: Buffer, callback: Function): boolean;\n        emit(event: \"resumeSession\", sessionId: any, callback: (err: Error, sessionData: any) => void): boolean;\n        emit(event: \"secureConnection\", tlsSocket: TLSSocket): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        on(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        on(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        on(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        on(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        once(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        once(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        once(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        once(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        prependListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        prependListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependOnceListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        prependOnceListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        prependOnceListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n    }\n\n    interface SecurePair {\n        encrypted: any;\n        cleartext: any;\n    }\n\n    interface SecureContextOptions {\n        pfx?: string | Buffer | Array<string | Buffer | Object>;\n        key?: string | Buffer | Array<Buffer | Object>;\n        passphrase?: string;\n        cert?: string | Buffer | Array<string | Buffer>;\n        ca?: string | Buffer | Array<string | Buffer>;\n        ciphers?: string;\n        honorCipherOrder?: boolean;\n        ecdhCurve?: string;\n        clientCertEngine?: string;\n        crl?: string | Buffer | Array<string | Buffer>;\n        dhparam?: string | Buffer;\n        secureOptions?: number; // Value is a numeric bitmask of the `SSL_OP_*` options\n        secureProtocol?: string; // SSL Method, e.g. SSLv23_method\n        sessionIdContext?: string;\n    }\n\n    interface SecureContext {\n        context: any;\n    }\n\n    /*\n     * Verifies the certificate `cert` is issued to host `host`.\n     * @host The hostname to verify the certificate against\n     * @cert PeerCertificate representing the peer's certificate\n     *\n     * Returns Error object, populating it with the reason, host and cert on failure.  On success, returns undefined.\n     */\n    function checkServerIdentity(host: string, cert: PeerCertificate): Error | undefined;\n    function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;\n    function connect(options: ConnectionOptions, secureConnectionListener?: () => void): TLSSocket;\n    function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function createSecurePair(credentials?: crypto.Credentials, isServer?: boolean, requestCert?: boolean, rejectUnauthorized?: boolean): SecurePair;\n    function createSecureContext(details: SecureContextOptions): SecureContext;\n    function getCiphers(): string[];\n\n    const DEFAULT_ECDH_CURVE: string;\n}\n\ndeclare module \"crypto\" {\n    import * as stream from \"stream\";\n\n    interface Certificate {\n        exportChallenge(spkac: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        exportPublicKey(spkac: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        verifySpkac(spkac: Buffer | NodeJS.TypedArray | DataView): boolean;\n    }\n    const Certificate: {\n        new(): Certificate;\n        (): Certificate;\n    };\n\n    /** @deprecated since v10.0.0 */\n    const fips: boolean;\n\n    interface CredentialDetails {\n        pfx: string;\n        key: string;\n        passphrase: string;\n        cert: string;\n        ca: string | string[];\n        crl: string | string[];\n        ciphers: string;\n    }\n    interface Credentials { context?: any; }\n    function createCredentials(details: CredentialDetails): Credentials;\n    function createHash(algorithm: string, options?: stream.TransformOptions): Hash;\n    function createHmac(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Hmac;\n\n    type Utf8AsciiLatin1Encoding = \"utf8\" | \"ascii\" | \"latin1\";\n    type HexBase64Latin1Encoding = \"latin1\" | \"hex\" | \"base64\";\n    type Utf8AsciiBinaryEncoding = \"utf8\" | \"ascii\" | \"binary\";\n    type HexBase64BinaryEncoding = \"binary\" | \"base64\" | \"hex\";\n    type ECDHKeyFormat = \"compressed\" | \"uncompressed\" | \"hybrid\";\n\n    interface Hash extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Hash;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hash;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n    interface Hmac extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Hmac;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hmac;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n    type CipherCCMTypes = 'aes-128-ccm' | 'aes-192-ccm' | 'aes-256-ccm';\n    type CipherGCMTypes = 'aes-128-gcm' | 'aes-192-gcm' | 'aes-256-gcm';\n    interface CipherCCMOptions extends stream.TransformOptions {\n        authTagLength: number;\n    }\n    interface CipherGCMOptions extends stream.TransformOptions {\n        authTagLength?: number;\n    }\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherCCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): CipherCCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherGCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): CipherGCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: string, password: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Cipher;\n\n    function createCipheriv(algorithm: CipherCCMTypes, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): CipherCCM;\n    function createCipheriv(algorithm: CipherGCMTypes, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): CipherGCM;\n    function createCipheriv(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Cipher;\n\n    interface Cipher extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding): Buffer;\n        update(data: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64BinaryEncoding): string;\n        update(data: Buffer | NodeJS.TypedArray | DataView, input_encoding: any, output_encoding: HexBase64BinaryEncoding): string;\n        // second arg ignored\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding, output_encoding: HexBase64BinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // getAuthTag(): Buffer;\n        // setAAD(buffer: Buffer): this; // docs only say buffer\n    }\n    interface CipherCCM extends Cipher {\n        setAAD(buffer: Buffer, options: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    interface CipherGCM extends Cipher {\n        setAAD(buffer: Buffer, options?: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: CipherCCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): DecipherCCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: CipherGCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): DecipherGCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: string, password: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Decipher;\n\n    function createDecipheriv(\n        algorithm: CipherCCMTypes,\n        key: string | Buffer | NodeJS.TypedArray | DataView,\n        iv: string | Buffer | NodeJS.TypedArray | DataView,\n        options: CipherCCMOptions,\n    ): DecipherCCM;\n    function createDecipheriv(\n        algorithm: CipherGCMTypes,\n        key: string | Buffer | NodeJS.TypedArray | DataView,\n        iv: string | Buffer | NodeJS.TypedArray | DataView,\n        options?: CipherGCMOptions,\n    ): DecipherGCM;\n    function createDecipheriv(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Decipher;\n\n    interface Decipher extends NodeJS.ReadWriteStream {\n        update(data: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        update(data: string, input_encoding: HexBase64BinaryEncoding): Buffer;\n        update(data: Buffer | NodeJS.TypedArray | DataView, input_encoding: any, output_encoding: Utf8AsciiBinaryEncoding): string;\n        // second arg is ignored\n        update(data: string, input_encoding: HexBase64BinaryEncoding, output_encoding: Utf8AsciiBinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // setAuthTag(tag: Buffer | NodeJS.TypedArray | DataView): this;\n        // setAAD(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n    }\n    interface DecipherCCM extends Decipher {\n        setAuthTag(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n        setAAD(buffer: Buffer | NodeJS.TypedArray | DataView, options: { plaintextLength: number }): this;\n    }\n    interface DecipherGCM extends Decipher {\n        setAuthTag(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n        setAAD(buffer: Buffer | NodeJS.TypedArray | DataView, options?: { plaintextLength: number }): this;\n    }\n\n    function createSign(algorithm: string, options?: stream.WritableOptions): Signer;\n    interface Signer extends NodeJS.WritableStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Signer;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Signer;\n        sign(private_key: string | { key: string; passphrase: string, padding?: number, saltLength?: number }): Buffer;\n        sign(private_key: string | { key: string; passphrase: string, padding?: number, saltLength?: number }, output_format: HexBase64Latin1Encoding): string;\n    }\n    function createVerify(algorith: string, options?: stream.WritableOptions): Verify;\n    interface Verify extends NodeJS.WritableStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Verify;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Verify;\n        verify(object: string | Object, signature: Buffer | NodeJS.TypedArray | DataView): boolean;\n        verify(object: string | Object, signature: string, signature_format: HexBase64Latin1Encoding): boolean;\n        // https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format\n        // The signature field accepts a TypedArray type, but it is only available starting ES2017\n    }\n    function createDiffieHellman(prime_length: number, generator?: number | Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: number | Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: string, generator_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    interface DiffieHellman {\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrime(): Buffer;\n        getPrime(encoding: HexBase64Latin1Encoding): string;\n        getGenerator(): Buffer;\n        getGenerator(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        setPublicKey(public_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPublicKey(public_key: string, encoding: string): void;\n        setPrivateKey(private_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPrivateKey(private_key: string, encoding: string): void;\n        verifyError: number;\n    }\n    function getDiffieHellman(group_name: string): DiffieHellman;\n    function pbkdf2(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        iterations: number,\n        keylen: number,\n        digest: string,\n        callback: (err: Error | null, derivedKey: Buffer) => any,\n    ): void;\n    function pbkdf2Sync(password: string | Buffer | NodeJS.TypedArray | DataView, salt: string | Buffer | NodeJS.TypedArray | DataView, iterations: number, keylen: number, digest: string): Buffer;\n\n    function randomBytes(size: number): Buffer;\n    function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n    function pseudoRandomBytes(size: number): Buffer;\n    function pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n\n    function randomFillSync<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset?: number, size?: number): T;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset: number, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset: number, size: number, callback: (err: Error | null, buf: T) => void): void;\n\n    interface ScryptOptions {\n        N?: number;\n        r?: number;\n        p?: number;\n        maxmem?: number;\n    }\n    function scrypt(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        keylen: number, callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scrypt(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        keylen: number,\n        options: ScryptOptions,\n        callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scryptSync(password: string | Buffer | NodeJS.TypedArray | DataView, salt: string | Buffer | NodeJS.TypedArray | DataView, keylen: number, options?: ScryptOptions): Buffer;\n\n    interface RsaPublicKey {\n        key: string;\n        padding?: number;\n    }\n    interface RsaPrivateKey {\n        key: string;\n        passphrase?: string;\n        padding?: number;\n    }\n    function publicEncrypt(public_key: string | RsaPublicKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function privateDecrypt(private_key: string | RsaPrivateKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function privateEncrypt(private_key: string | RsaPrivateKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function publicDecrypt(public_key: string | RsaPublicKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function getCiphers(): string[];\n    function getCurves(): string[];\n    function getHashes(): string[];\n    class ECDH {\n        static convertKey(\n            key: string | Buffer | NodeJS.TypedArray | DataView,\n            curve: string,\n            inputEncoding?: HexBase64Latin1Encoding,\n            outputEncoding?: \"latin1\" | \"hex\" | \"base64\",\n            format?: \"uncompressed\" | \"compressed\" | \"hybrid\",\n        ): Buffer | string;\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        setPrivateKey(private_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPrivateKey(private_key: string, encoding: HexBase64Latin1Encoding): void;\n    }\n    function createECDH(curve_name: string): ECDH;\n    function timingSafeEqual(a: Buffer | NodeJS.TypedArray | DataView, b: Buffer | NodeJS.TypedArray | DataView): boolean;\n    /** @deprecated since v10.0.0 */\n    const DEFAULT_ENCODING: string;\n}\n\ndeclare module \"stream\" {\n    import * as events from \"events\";\n\n    class internal extends events.EventEmitter {\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\n    }\n\n    namespace internal {\n        class Stream extends internal { }\n\n        interface ReadableOptions {\n            highWaterMark?: number;\n            encoding?: string;\n            objectMode?: boolean;\n            read?(this: Readable, size: number): void;\n            destroy?(this: Readable, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        class Readable extends Stream implements NodeJS.ReadableStream {\n            readable: boolean;\n            readonly readableHighWaterMark: number;\n            readonly readableLength: number;\n            constructor(opts?: ReadableOptions);\n            _read(size: number): void;\n            read(size?: number): any;\n            setEncoding(encoding: string): this;\n            pause(): this;\n            resume(): this;\n            isPaused(): boolean;\n            unpipe(destination?: NodeJS.WritableStream): this;\n            unshift(chunk: any): void;\n            wrap(oldStream: NodeJS.ReadableStream): this;\n            push(chunk: any, encoding?: string): boolean;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. data\n             * 3. end\n             * 4. readable\n             * 5. error\n             */\n            addListener(event: \"close\", listener: () => void): this;\n            addListener(event: \"data\", listener: (chunk: any) => void): this;\n            addListener(event: \"end\", listener: () => void): this;\n            addListener(event: \"readable\", listener: () => void): this;\n            addListener(event: \"error\", listener: (err: Error) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: \"close\"): boolean;\n            emit(event: \"data\", chunk: any): boolean;\n            emit(event: \"end\"): boolean;\n            emit(event: \"readable\"): boolean;\n            emit(event: \"error\", err: Error): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: \"close\", listener: () => void): this;\n            on(event: \"data\", listener: (chunk: any) => void): this;\n            on(event: \"end\", listener: () => void): this;\n            on(event: \"readable\", listener: () => void): this;\n            on(event: \"error\", listener: (err: Error) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: \"close\", listener: () => void): this;\n            once(event: \"data\", listener: (chunk: any) => void): this;\n            once(event: \"end\", listener: () => void): this;\n            once(event: \"readable\", listener: () => void): this;\n            once(event: \"error\", listener: (err: Error) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: \"close\", listener: () => void): this;\n            prependListener(event: \"data\", listener: (chunk: any) => void): this;\n            prependListener(event: \"end\", listener: () => void): this;\n            prependListener(event: \"readable\", listener: () => void): this;\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: \"close\", listener: () => void): this;\n            prependOnceListener(event: \"data\", listener: (chunk: any) => void): this;\n            prependOnceListener(event: \"end\", listener: () => void): this;\n            prependOnceListener(event: \"readable\", listener: () => void): this;\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: \"close\", listener: () => void): this;\n            removeListener(event: \"data\", listener: (chunk: any) => void): this;\n            removeListener(event: \"end\", listener: () => void): this;\n            removeListener(event: \"readable\", listener: () => void): this;\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n        }\n\n        interface WritableOptions {\n            highWaterMark?: number;\n            decodeStrings?: boolean;\n            objectMode?: boolean;\n            write?(this: Writable, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Writable, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            destroy?(this: Writable, error: Error | null, callback: (error: Error | null) => void): void;\n            final?(this: Writable, callback: (error?: Error | null) => void): void;\n        }\n\n        class Writable extends Stream implements NodeJS.WritableStream {\n            writable: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            constructor(opts?: WritableOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. drain\n             * 3. error\n             * 4. finish\n             * 5. pipe\n             * 6. unpipe\n             */\n            addListener(event: \"close\", listener: () => void): this;\n            addListener(event: \"drain\", listener: () => void): this;\n            addListener(event: \"error\", listener: (err: Error) => void): this;\n            addListener(event: \"finish\", listener: () => void): this;\n            addListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            addListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: \"close\"): boolean;\n            emit(event: \"drain\"): boolean;\n            emit(event: \"error\", err: Error): boolean;\n            emit(event: \"finish\"): boolean;\n            emit(event: \"pipe\", src: Readable): boolean;\n            emit(event: \"unpipe\", src: Readable): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: \"close\", listener: () => void): this;\n            on(event: \"drain\", listener: () => void): this;\n            on(event: \"error\", listener: (err: Error) => void): this;\n            on(event: \"finish\", listener: () => void): this;\n            on(event: \"pipe\", listener: (src: Readable) => void): this;\n            on(event: \"unpipe\", listener: (src: Readable) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: \"close\", listener: () => void): this;\n            once(event: \"drain\", listener: () => void): this;\n            once(event: \"error\", listener: (err: Error) => void): this;\n            once(event: \"finish\", listener: () => void): this;\n            once(event: \"pipe\", listener: (src: Readable) => void): this;\n            once(event: \"unpipe\", listener: (src: Readable) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: \"close\", listener: () => void): this;\n            prependListener(event: \"drain\", listener: () => void): this;\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\n            prependListener(event: \"finish\", listener: () => void): this;\n            prependListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            prependListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: \"close\", listener: () => void): this;\n            prependOnceListener(event: \"drain\", listener: () => void): this;\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n            prependOnceListener(event: \"finish\", listener: () => void): this;\n            prependOnceListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            prependOnceListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: \"close\", listener: () => void): this;\n            removeListener(event: \"drain\", listener: () => void): this;\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\n            removeListener(event: \"finish\", listener: () => void): this;\n            removeListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            removeListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        }\n\n        interface DuplexOptions extends ReadableOptions, WritableOptions {\n            allowHalfOpen?: boolean;\n            readableObjectMode?: boolean;\n            writableObjectMode?: boolean;\n            read?(this: Duplex, size: number): void;\n            write?(this: Duplex, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Duplex, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Duplex, callback: (error?: Error | null) => void): void;\n            destroy?(this: Duplex, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        // Note: Duplex extends both Readable and Writable.\n        class Duplex extends Readable implements Writable {\n            writable: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            constructor(opts?: DuplexOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n        }\n\n        type TransformCallback = (error?: Error, data?: any) => void;\n\n        interface TransformOptions extends DuplexOptions {\n            read?(this: Transform, size: number): void;\n            write?(this: Transform, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Transform, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Transform, callback: (error?: Error | null) => void): void;\n            destroy?(this: Transform, error: Error | null, callback: (error: Error | null) => void): void;\n            transform?(this: Transform, chunk: any, encoding: string, callback: TransformCallback): void;\n            flush?(this: Transform, callback: TransformCallback): void;\n        }\n\n        class Transform extends Duplex {\n            constructor(opts?: TransformOptions);\n            _transform(chunk: any, encoding: string, callback: TransformCallback): void;\n            _flush(callback: TransformCallback): void;\n        }\n\n        class PassThrough extends Transform { }\n\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, callback: (err?: NodeJS.ErrnoException) => void): () => void;\n        namespace finished {\n            function __promisify__(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream): Promise<void>;\n        }\n\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: T, callback?: (err: NodeJS.ErrnoException) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: T, callback?: (err: NodeJS.ErrnoException) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: T,\n            callback?: (err: NodeJS.ErrnoException) => void,\n        ): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: NodeJS.ReadWriteStream,\n            stream5: T,\n            callback?: (err: NodeJS.ErrnoException) => void,\n        ): T;\n        function pipeline(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>, callback?: (err: NodeJS.ErrnoException) => void): NodeJS.WritableStream;\n        function pipeline(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n            ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException) => void)>,\n        ): NodeJS.WritableStream;\n        namespace pipeline {\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.ReadWriteStream, stream4: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream,\n                stream3: NodeJS.ReadWriteStream,\n                stream4: NodeJS.ReadWriteStream,\n                stream5: NodeJS.WritableStream,\n            ): Promise<void>;\n            function __promisify__(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream>,\n            ): Promise<void>;\n        }\n    }\n\n    export = internal;\n}\n\ndeclare module \"util\" {\n    interface InspectOptions extends NodeJS.InspectOptions { }\n    function format(format: any, ...param: any[]): string;\n    function formatWithOptions(inspectOptions: InspectOptions, format: string, ...param: any[]): string;\n    /** @deprecated since v0.11.3 - use `console.error()` instead. */\n    function debug(string: string): void;\n    /** @deprecated since v0.11.3 - use `console.error()` instead. */\n    function error(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use `console.log()` instead. */\n    function puts(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use `console.log()` instead. */\n    function print(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use a third party module instead. */\n    function log(string: string): void;\n    const inspect: {\n        (object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\n        (object: any, options: InspectOptions): string;\n        colors: {\n            [color: string]: [number, number] | undefined\n        }\n        styles: {\n            [style: string]: string | undefined\n        }\n        defaultOptions: InspectOptions;\n        custom: symbol;\n    };\n    /** @deprecated since v4.0.0 - use `Array.isArray()` instead. */\n    function isArray(object: any): object is any[];\n    /** @deprecated since v4.0.0 - use `util.types.isRegExp()` instead. */\n    function isRegExp(object: any): object is RegExp;\n    /** @deprecated since v4.0.0 - use `util.types.isDate()` instead. */\n    function isDate(object: any): object is Date;\n    /** @deprecated since v4.0.0 - use `util.types.isNativeError()` instead. */\n    function isError(object: any): object is Error;\n    function inherits(constructor: any, superConstructor: any): void;\n    function debuglog(key: string): (msg: string, ...param: any[]) => void;\n    /** @deprecated since v4.0.0 - use `typeof value === 'boolean'` instead. */\n    function isBoolean(object: any): object is boolean;\n    /** @deprecated since v4.0.0 - use `Buffer.isBuffer()` instead. */\n    function isBuffer(object: any): object is Buffer;\n    /** @deprecated since v4.0.0 - use `typeof value === 'function'` instead. */\n    function isFunction(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `value === null` instead. */\n    function isNull(object: any): object is null;\n    /** @deprecated since v4.0.0 - use `value === null || value === undefined` instead. */\n    function isNullOrUndefined(object: any): object is null | undefined;\n    /** @deprecated since v4.0.0 - use `typeof value === 'number'` instead. */\n    function isNumber(object: any): object is number;\n    /** @deprecated since v4.0.0 - use `value !== null && typeof value === 'object'` instead. */\n    function isObject(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `(typeof value !== 'object' && typeof value !== 'function') || value === null` instead. */\n    function isPrimitive(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `typeof value === 'string'` instead. */\n    function isString(object: any): object is string;\n    /** @deprecated since v4.0.0 - use `typeof value === 'symbol'` instead. */\n    function isSymbol(object: any): object is symbol;\n    /** @deprecated since v4.0.0 - use `value === undefined` instead. */\n    function isUndefined(object: any): object is undefined;\n    function deprecate<T extends Function>(fn: T, message: string): T;\n    function isDeepStrictEqual(val1: any, val2: any): boolean;\n\n    interface CustomPromisify<TCustom extends Function> extends Function {\n        __promisify__: TCustom;\n    }\n\n    function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<TResult>(fn: () => Promise<TResult>): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1>(fn: (arg1: T1) => Promise<void>): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, TResult>(fn: (arg1: T1) => Promise<TResult>): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2>(fn: (arg1: T1, arg2: T2) => Promise<void>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2) => Promise<TResult>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n\n    function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;\n    function promisify<TResult>(fn: (callback: (err: Error | null, result: TResult) => void) => void): () => Promise<TResult>;\n    function promisify(fn: (callback: (err?: Error | null) => void) => void): () => Promise<void>;\n    function promisify<T1, TResult>(fn: (arg1: T1, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1) => Promise<TResult>;\n    function promisify<T1>(fn: (arg1: T1, callback: (err?: Error | null) => void) => void): (arg1: T1) => Promise<void>;\n    function promisify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1, arg2: T2) => Promise<TResult>;\n    function promisify<T1, T2>(fn: (arg1: T1, arg2: T2, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2) => Promise<void>;\n    function promisify<T1, T2, T3, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;\n    function promisify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;\n    function promisify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: Error | null, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;\n    function promisify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: Error | null, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: Error | null) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;\n    function promisify(fn: Function): Function;\n    namespace promisify {\n        const custom: symbol;\n    }\n\n    namespace types {\n        function isAnyArrayBuffer(object: any): boolean;\n        function isArgumentsObject(object: any): object is IArguments;\n        function isArrayBuffer(object: any): object is ArrayBuffer;\n        function isAsyncFunction(object: any): boolean;\n        function isBooleanObject(object: any): object is Boolean;\n        function isBoxedPrimitive(object: any): object is (Number | Boolean | String | Symbol /* BigInt */);\n        function isDataView(object: any): object is DataView;\n        function isDate(object: any): object is Date;\n        function isExternal(object: any): boolean;\n        function isFloat32Array(object: any): object is Float32Array;\n        function isFloat64Array(object: any): object is Float64Array;\n        function isGeneratorFunction(object: any): boolean;\n        function isGeneratorObject(object: any): boolean;\n        function isInt8Array(object: any): object is Int8Array;\n        function isInt16Array(object: any): object is Int16Array;\n        function isInt32Array(object: any): object is Int32Array;\n        function isMap(object: any): boolean;\n        function isMapIterator(object: any): boolean;\n        function isNativeError(object: any): object is Error;\n        function isNumberObject(object: any): object is Number;\n        function isPromise(object: any): boolean;\n        function isProxy(object: any): boolean;\n        function isRegExp(object: any): object is RegExp;\n        function isSet(object: any): boolean;\n        function isSetIterator(object: any): boolean;\n        function isSharedArrayBuffer(object: any): boolean;\n        function isStringObject(object: any): boolean;\n        function isSymbolObject(object: any): boolean;\n        function isTypedArray(object: any): object is NodeJS.TypedArray;\n        function isUint8Array(object: any): object is Uint8Array;\n        function isUint8ClampedArray(object: any): object is Uint8ClampedArray;\n        function isUint16Array(object: any): object is Uint16Array;\n        function isUint32Array(object: any): object is Uint32Array;\n        function isWeakMap(object: any): boolean;\n        function isWeakSet(object: any): boolean;\n        function isWebAssemblyCompiledModule(object: any): boolean;\n    }\n\n    class TextDecoder {\n        readonly encoding: string;\n        readonly fatal: boolean;\n        readonly ignoreBOM: boolean;\n        constructor(\n          encoding?: string,\n          options?: { fatal?: boolean; ignoreBOM?: boolean }\n        );\n        decode(\n          input?: NodeJS.TypedArray | DataView | ArrayBuffer | null,\n          options?: { stream?: boolean }\n        ): string;\n    }\n\n    class TextEncoder {\n        readonly encoding: string;\n        constructor();\n        encode(input?: string): Uint8Array;\n    }\n}\n\ndeclare module \"assert\" {\n    function internal(value: any, message?: string | Error): void;\n    namespace internal {\n        class AssertionError implements Error {\n            name: string;\n            message: string;\n            actual: any;\n            expected: any;\n            operator: string;\n            generatedMessage: boolean;\n            code: 'ERR_ASSERTION';\n\n            constructor(options?: {\n                message?: string; actual?: any; expected?: any;\n                operator?: string; stackStartFn?: Function\n            });\n        }\n\n        function fail(message?: string | Error): never;\n        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */\n        function fail(actual: any, expected: any, message?: string | Error, operator?: string, stackStartFn?: Function): never;\n        function ok(value: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use strictEqual() instead. */\n        function equal(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use notStrictEqual() instead. */\n        function notEqual(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use deepStrictEqual() instead. */\n        function deepEqual(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use notDeepStrictEqual() instead. */\n        function notDeepEqual(actual: any, expected: any, message?: string | Error): void;\n        function strictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function deepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notDeepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n\n        function throws(block: Function, message?: string | Error): void;\n        function throws(block: Function, error: RegExp | Function | Object | Error, message?: string | Error): void;\n        function doesNotThrow(block: Function, message?: string | Error): void;\n        function doesNotThrow(block: Function, error: RegExp | Function, message?: string | Error): void;\n\n        function ifError(value: any): void;\n\n        function rejects(block: Function | Promise<any>, message?: string | Error): Promise<void>;\n        function rejects(block: Function | Promise<any>, error: RegExp | Function | Object | Error, message?: string | Error): Promise<void>;\n        function doesNotReject(block: Function | Promise<any>, message?: string | Error): Promise<void>;\n        function doesNotReject(block: Function | Promise<any>, error: RegExp | Function, message?: string | Error): Promise<void>;\n\n        const strict: typeof internal;\n    }\n\n    export = internal;\n}\n\ndeclare module \"tty\" {\n    import * as net from \"net\";\n\n    function isatty(fd: number): boolean;\n    class ReadStream extends net.Socket {\n        isRaw: boolean;\n        setRawMode(mode: boolean): void;\n        isTTY: boolean;\n    }\n    class WriteStream extends net.Socket {\n        columns: number;\n        rows: number;\n        isTTY: boolean;\n    }\n}\n\ndeclare module \"domain\" {\n    import * as events from \"events\";\n\n    class Domain extends events.EventEmitter implements NodeJS.Domain {\n        run(fn: Function): void;\n        add(emitter: events.EventEmitter): void;\n        remove(emitter: events.EventEmitter): void;\n        bind(cb: (err: Error, data: any) => any): any;\n        intercept(cb: (data: any) => any): any;\n        members: any[];\n        enter(): void;\n        exit(): void;\n    }\n\n    function create(): Domain;\n}\n\ndeclare module \"constants\" {\n    const E2BIG: number;\n    const EACCES: number;\n    const EADDRINUSE: number;\n    const EADDRNOTAVAIL: number;\n    const EAFNOSUPPORT: number;\n    const EAGAIN: number;\n    const EALREADY: number;\n    const EBADF: number;\n    const EBADMSG: number;\n    const EBUSY: number;\n    const ECANCELED: number;\n    const ECHILD: number;\n    const ECONNABORTED: number;\n    const ECONNREFUSED: number;\n    const ECONNRESET: number;\n    const EDEADLK: number;\n    const EDESTADDRREQ: number;\n    const EDOM: number;\n    const EEXIST: number;\n    const EFAULT: number;\n    const EFBIG: number;\n    const EHOSTUNREACH: number;\n    const EIDRM: number;\n    const EILSEQ: number;\n    const EINPROGRESS: number;\n    const EINTR: number;\n    const EINVAL: number;\n    const EIO: number;\n    const EISCONN: number;\n    const EISDIR: number;\n    const ELOOP: number;\n    const EMFILE: number;\n    const EMLINK: number;\n    const EMSGSIZE: number;\n    const ENAMETOOLONG: number;\n    const ENETDOWN: number;\n    const ENETRESET: number;\n    const ENETUNREACH: number;\n    const ENFILE: number;\n    const ENOBUFS: number;\n    const ENODATA: number;\n    const ENODEV: number;\n    const ENOENT: number;\n    const ENOEXEC: number;\n    const ENOLCK: number;\n    const ENOLINK: number;\n    const ENOMEM: number;\n    const ENOMSG: number;\n    const ENOPROTOOPT: number;\n    const ENOSPC: number;\n    const ENOSR: number;\n    const ENOSTR: number;\n    const ENOSYS: number;\n    const ENOTCONN: number;\n    const ENOTDIR: number;\n    const ENOTEMPTY: number;\n    const ENOTSOCK: number;\n    const ENOTSUP: number;\n    const ENOTTY: number;\n    const ENXIO: number;\n    const EOPNOTSUPP: number;\n    const EOVERFLOW: number;\n    const EPERM: number;\n    const EPIPE: number;\n    const EPROTO: number;\n    const EPROTONOSUPPORT: number;\n    const EPROTOTYPE: number;\n    const ERANGE: number;\n    const EROFS: number;\n    const ESPIPE: number;\n    const ESRCH: number;\n    const ETIME: number;\n    const ETIMEDOUT: number;\n    const ETXTBSY: number;\n    const EWOULDBLOCK: number;\n    const EXDEV: number;\n    const WSAEINTR: number;\n    const WSAEBADF: number;\n    const WSAEACCES: number;\n    const WSAEFAULT: number;\n    const WSAEINVAL: number;\n    const WSAEMFILE: number;\n    const WSAEWOULDBLOCK: number;\n    const WSAEINPROGRESS: number;\n    const WSAEALREADY: number;\n    const WSAENOTSOCK: number;\n    const WSAEDESTADDRREQ: number;\n    const WSAEMSGSIZE: number;\n    const WSAEPROTOTYPE: number;\n    const WSAENOPROTOOPT: number;\n    const WSAEPROTONOSUPPORT: number;\n    const WSAESOCKTNOSUPPORT: number;\n    const WSAEOPNOTSUPP: number;\n    const WSAEPFNOSUPPORT: number;\n    const WSAEAFNOSUPPORT: number;\n    const WSAEADDRINUSE: number;\n    const WSAEADDRNOTAVAIL: number;\n    const WSAENETDOWN: number;\n    const WSAENETUNREACH: number;\n    const WSAENETRESET: number;\n    const WSAECONNABORTED: number;\n    const WSAECONNRESET: number;\n    const WSAENOBUFS: number;\n    const WSAEISCONN: number;\n    const WSAENOTCONN: number;\n    const WSAESHUTDOWN: number;\n    const WSAETOOMANYREFS: number;\n    const WSAETIMEDOUT: number;\n    const WSAECONNREFUSED: number;\n    const WSAELOOP: number;\n    const WSAENAMETOOLONG: number;\n    const WSAEHOSTDOWN: number;\n    const WSAEHOSTUNREACH: number;\n    const WSAENOTEMPTY: number;\n    const WSAEPROCLIM: number;\n    const WSAEUSERS: number;\n    const WSAEDQUOT: number;\n    const WSAESTALE: number;\n    const WSAEREMOTE: number;\n    const WSASYSNOTREADY: number;\n    const WSAVERNOTSUPPORTED: number;\n    const WSANOTINITIALISED: number;\n    const WSAEDISCON: number;\n    const WSAENOMORE: number;\n    const WSAECANCELLED: number;\n    const WSAEINVALIDPROCTABLE: number;\n    const WSAEINVALIDPROVIDER: number;\n    const WSAEPROVIDERFAILEDINIT: number;\n    const WSASYSCALLFAILURE: number;\n    const WSASERVICE_NOT_FOUND: number;\n    const WSATYPE_NOT_FOUND: number;\n    const WSA_E_NO_MORE: number;\n    const WSA_E_CANCELLED: number;\n    const WSAEREFUSED: number;\n    const SIGHUP: number;\n    const SIGINT: number;\n    const SIGILL: number;\n    const SIGABRT: number;\n    const SIGFPE: number;\n    const SIGKILL: number;\n    const SIGSEGV: number;\n    const SIGTERM: number;\n    const SIGBREAK: number;\n    const SIGWINCH: number;\n    const SSL_OP_ALL: number;\n    const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;\n    const SSL_OP_CIPHER_SERVER_PREFERENCE: number;\n    const SSL_OP_CISCO_ANYCONNECT: number;\n    const SSL_OP_COOKIE_EXCHANGE: number;\n    const SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;\n    const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;\n    const SSL_OP_EPHEMERAL_RSA: number;\n    const SSL_OP_LEGACY_SERVER_CONNECT: number;\n    const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;\n    const SSL_OP_MICROSOFT_SESS_ID_BUG: number;\n    const SSL_OP_MSIE_SSLV2_RSA_PADDING: number;\n    const SSL_OP_NETSCAPE_CA_DN_BUG: number;\n    const SSL_OP_NETSCAPE_CHALLENGE_BUG: number;\n    const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;\n    const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;\n    const SSL_OP_NO_COMPRESSION: number;\n    const SSL_OP_NO_QUERY_MTU: number;\n    const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;\n    const SSL_OP_NO_SSLv2: number;\n    const SSL_OP_NO_SSLv3: number;\n    const SSL_OP_NO_TICKET: number;\n    const SSL_OP_NO_TLSv1: number;\n    const SSL_OP_NO_TLSv1_1: number;\n    const SSL_OP_NO_TLSv1_2: number;\n    const SSL_OP_PKCS1_CHECK_1: number;\n    const SSL_OP_PKCS1_CHECK_2: number;\n    const SSL_OP_SINGLE_DH_USE: number;\n    const SSL_OP_SINGLE_ECDH_USE: number;\n    const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;\n    const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;\n    const SSL_OP_TLS_BLOCK_PADDING_BUG: number;\n    const SSL_OP_TLS_D5_BUG: number;\n    const SSL_OP_TLS_ROLLBACK_BUG: number;\n    const ENGINE_METHOD_DSA: number;\n    const ENGINE_METHOD_DH: number;\n    const ENGINE_METHOD_RAND: number;\n    const ENGINE_METHOD_ECDH: number;\n    const ENGINE_METHOD_ECDSA: number;\n    const ENGINE_METHOD_CIPHERS: number;\n    const ENGINE_METHOD_DIGESTS: number;\n    const ENGINE_METHOD_STORE: number;\n    const ENGINE_METHOD_PKEY_METHS: number;\n    const ENGINE_METHOD_PKEY_ASN1_METHS: number;\n    const ENGINE_METHOD_ALL: number;\n    const ENGINE_METHOD_NONE: number;\n    const DH_CHECK_P_NOT_SAFE_PRIME: number;\n    const DH_CHECK_P_NOT_PRIME: number;\n    const DH_UNABLE_TO_CHECK_GENERATOR: number;\n    const DH_NOT_SUITABLE_GENERATOR: number;\n    const NPN_ENABLED: number;\n    const RSA_PKCS1_PADDING: number;\n    const RSA_SSLV23_PADDING: number;\n    const RSA_NO_PADDING: number;\n    const RSA_PKCS1_OAEP_PADDING: number;\n    const RSA_X931_PADDING: number;\n    const RSA_PKCS1_PSS_PADDING: number;\n    const POINT_CONVERSION_COMPRESSED: number;\n    const POINT_CONVERSION_UNCOMPRESSED: number;\n    const POINT_CONVERSION_HYBRID: number;\n    const O_RDONLY: number;\n    const O_WRONLY: number;\n    const O_RDWR: number;\n    const S_IFMT: number;\n    const S_IFREG: number;\n    const S_IFDIR: number;\n    const S_IFCHR: number;\n    const S_IFBLK: number;\n    const S_IFIFO: number;\n    const S_IFSOCK: number;\n    const S_IRWXU: number;\n    const S_IRUSR: number;\n    const S_IWUSR: number;\n    const S_IXUSR: number;\n    const S_IRWXG: number;\n    const S_IRGRP: number;\n    const S_IWGRP: number;\n    const S_IXGRP: number;\n    const S_IRWXO: number;\n    const S_IROTH: number;\n    const S_IWOTH: number;\n    const S_IXOTH: number;\n    const S_IFLNK: number;\n    const O_CREAT: number;\n    const O_EXCL: number;\n    const O_NOCTTY: number;\n    const O_DIRECTORY: number;\n    const O_NOATIME: number;\n    const O_NOFOLLOW: number;\n    const O_SYNC: number;\n    const O_DSYNC: number;\n    const O_SYMLINK: number;\n    const O_DIRECT: number;\n    const O_NONBLOCK: number;\n    const O_TRUNC: number;\n    const O_APPEND: number;\n    const F_OK: number;\n    const R_OK: number;\n    const W_OK: number;\n    const X_OK: number;\n    const COPYFILE_EXCL: number;\n    const COPYFILE_FICLONE: number;\n    const COPYFILE_FICLONE_FORCE: number;\n    const UV_UDP_REUSEADDR: number;\n    const SIGQUIT: number;\n    const SIGTRAP: number;\n    const SIGIOT: number;\n    const SIGBUS: number;\n    const SIGUSR1: number;\n    const SIGUSR2: number;\n    const SIGPIPE: number;\n    const SIGALRM: number;\n    const SIGCHLD: number;\n    const SIGSTKFLT: number;\n    const SIGCONT: number;\n    const SIGSTOP: number;\n    const SIGTSTP: number;\n    const SIGTTIN: number;\n    const SIGTTOU: number;\n    const SIGURG: number;\n    const SIGXCPU: number;\n    const SIGXFSZ: number;\n    const SIGVTALRM: number;\n    const SIGPROF: number;\n    const SIGIO: number;\n    const SIGPOLL: number;\n    const SIGPWR: number;\n    const SIGSYS: number;\n    const SIGUNUSED: number;\n    const defaultCoreCipherList: string;\n    const defaultCipherList: string;\n    const ENGINE_METHOD_RSA: number;\n    const ALPN_ENABLED: number;\n}\n\ndeclare module \"module\" {\n    export = NodeJS.Module;\n}\n\ndeclare module \"process\" {\n    export = process;\n}\n\ndeclare module \"v8\" {\n    interface HeapSpaceInfo {\n        space_name: string;\n        space_size: number;\n        space_used_size: number;\n        space_available_size: number;\n        physical_space_size: number;\n    }\n\n    // ** Signifies if the --zap_code_space option is enabled or not.  1 == enabled, 0 == disabled. */\n    type DoesZapCodeSpaceFlag = 0 | 1;\n\n    interface HeapInfo {\n        total_heap_size: number;\n        total_heap_size_executable: number;\n        total_physical_size: number;\n        total_available_size: number;\n        used_heap_size: number;\n        heap_size_limit: number;\n        malloced_memory: number;\n        peak_malloced_memory: number;\n        does_zap_garbage: DoesZapCodeSpaceFlag;\n    }\n\n    function getHeapStatistics(): HeapInfo;\n    function getHeapSpaceStatistics(): HeapSpaceInfo[];\n    function setFlagsFromString(flags: string): void;\n}\n\ndeclare module \"timers\" {\n    function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    namespace setTimeout {\n        function __promisify__(ms: number): Promise<void>;\n        function __promisify__<T>(ms: number, value: T): Promise<T>;\n    }\n    function clearTimeout(timeoutId: NodeJS.Timeout): void;\n    function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    function clearInterval(intervalId: NodeJS.Timeout): void;\n    function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\n    namespace setImmediate {\n        function __promisify__(): Promise<void>;\n        function __promisify__<T>(value: T): Promise<T>;\n    }\n    function clearImmediate(immediateId: NodeJS.Immediate): void;\n}\n\ndeclare module \"console\" {\n    export = console;\n}\n\n/**\n * Async Hooks module: https://nodejs.org/api/async_hooks.html\n */\ndeclare module \"async_hooks\" {\n    /**\n     * Returns the asyncId of the current execution context.\n     */\n    function executionAsyncId(): number;\n\n    /**\n     * Returns the ID of the resource responsible for calling the callback that is currently being executed.\n     */\n    function triggerAsyncId(): number;\n\n    interface HookCallbacks {\n        /**\n         * Called when a class is constructed that has the possibility to emit an asynchronous event.\n         * @param asyncId a unique ID for the async resource\n         * @param type the type of the async resource\n         * @param triggerAsyncId the unique ID of the async resource in whose execution context this async resource was created\n         * @param resource reference to the resource representing the async operation, needs to be released during destroy\n         */\n        init?(asyncId: number, type: string, triggerAsyncId: number, resource: Object): void;\n\n        /**\n         * When an asynchronous operation is initiated or completes a callback is called to notify the user.\n         * The before callback is called just before said callback is executed.\n         * @param asyncId the unique identifier assigned to the resource about to execute the callback.\n         */\n        before?(asyncId: number): void;\n\n        /**\n         * Called immediately after the callback specified in before is completed.\n         * @param asyncId the unique identifier assigned to the resource which has executed the callback.\n         */\n        after?(asyncId: number): void;\n\n        /**\n         * Called when a promise has resolve() called. This may not be in the same execution id\n         * as the promise itself.\n         * @param asyncId the unique id for the promise that was resolve()d.\n         */\n        promiseResolve?(asyncId: number): void;\n\n        /**\n         * Called after the resource corresponding to asyncId is destroyed\n         * @param asyncId a unique ID for the async resource\n         */\n        destroy?(asyncId: number): void;\n    }\n\n    interface AsyncHook {\n        /**\n         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.\n         */\n        enable(): this;\n\n        /**\n         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.\n         */\n        disable(): this;\n    }\n\n    /**\n     * Registers functions to be called for different lifetime events of each async operation.\n     * @param options the callbacks to register\n     * @return an AsyncHooks instance used for disabling and enabling hooks\n     */\n    function createHook(options: HookCallbacks): AsyncHook;\n\n    interface AsyncResourceOptions {\n      /**\n       * The ID of the execution context that created this async event.\n       * Default: `executionAsyncId()`\n       */\n      triggerAsyncId?: number;\n\n      /**\n       * Disables automatic `emitDestroy` when the object is garbage collected.\n       * This usually does not need to be set (even if `emitDestroy` is called\n       * manually), unless the resource's `asyncId` is retrieved and the\n       * sensitive API's `emitDestroy` is called with it.\n       * Default: `false`\n       */\n      requireManualDestroy?: boolean;\n    }\n\n    /**\n     * The class AsyncResource was designed to be extended by the embedder's async resources.\n     * Using this users can easily trigger the lifetime events of their own resources.\n     */\n    class AsyncResource {\n        /**\n         * AsyncResource() is meant to be extended. Instantiating a\n         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n         * async_hook.executionAsyncId() is used.\n         * @param type The type of async event.\n         * @param triggerAsyncId The ID of the execution context that created\n         *   this async event (default: `executionAsyncId()`), or an\n         *   AsyncResourceOptions object (since 9.3)\n         */\n        constructor(type: string, triggerAsyncId?: number|AsyncResourceOptions);\n\n        /**\n         * Call AsyncHooks before callbacks.\n         * @deprecated since 9.6 - Use asyncResource.runInAsyncScope() instead.\n         */\n        emitBefore(): void;\n\n        /**\n         * Call AsyncHooks after callbacks.\n         * @deprecated since 9.6 - Use asyncResource.runInAsyncScope() instead.\n         */\n        emitAfter(): void;\n\n        /**\n         * Call the provided function with the provided arguments in the\n         * execution context of the async resource. This will establish the\n         * context, trigger the AsyncHooks before callbacks, call the function,\n         * trigger the AsyncHooks after callbacks, and then restore the original\n         * execution context.\n         * @param fn The function to call in the execution context of this\n         *   async resource.\n         * @param thisArg The receiver to be used for the function call.\n         * @param args Optional arguments to pass to the function.\n         */\n        runInAsyncScope<This, Result>(fn: (this: This, ...args: any[]) => Result, thisArg?: This, ...args: any[]): Result;\n\n        /**\n         * Call AsyncHooks destroy callbacks.\n         */\n        emitDestroy(): void;\n\n        /**\n         * @return the unique ID assigned to this AsyncResource instance.\n         */\n        asyncId(): number;\n\n        /**\n         * @return the trigger ID for this AsyncResource instance.\n         */\n        triggerAsyncId(): number;\n    }\n}\n\ndeclare module \"http2\" {\n    import * as events from \"events\";\n    import * as fs from \"fs\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n    import * as tls from \"tls\";\n    import * as url from \"url\";\n\n    import { IncomingHttpHeaders as Http1IncomingHttpHeaders, OutgoingHttpHeaders } from \"http\";\n    export { OutgoingHttpHeaders } from \"http\";\n\n    export interface IncomingHttpStatusHeader {\n        \":status\"?: number;\n    }\n\n    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {\n        \":path\"?: string;\n        \":method\"?: string;\n        \":authority\"?: string;\n        \":scheme\"?: string;\n    }\n\n    // Http2Stream\n\n    export interface StreamPriorityOptions {\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        silent?: boolean;\n    }\n\n    export interface StreamState {\n        localWindowSize?: number;\n        state?: number;\n        streamLocalClose?: number;\n        streamRemoteClose?: number;\n        sumDependencyWeight?: number;\n        weight?: number;\n    }\n\n    export interface ServerStreamResponseOptions {\n        endStream?: boolean;\n        getTrailers?: (trailers: OutgoingHttpHeaders) => void;\n    }\n\n    export interface StatOptions {\n        offset: number;\n        length: number;\n    }\n\n    export interface ServerStreamFileResponseOptions {\n        statCheck?: (stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions) => void | boolean;\n        getTrailers?: (trailers: OutgoingHttpHeaders) => void;\n        offset?: number;\n        length?: number;\n    }\n\n    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {\n        onError?: (err: NodeJS.ErrnoException) => void;\n    }\n\n    export interface Http2Stream extends stream.Duplex {\n        readonly aborted: boolean;\n        readonly closed: boolean;\n        readonly destroyed: boolean;\n        readonly pending: boolean;\n        readonly rstCode: number;\n        readonly session: Http2Session;\n        readonly state: StreamState;\n        /**\n         * Set the true if the END_STREAM flag was set in the request or response HEADERS frame received,\n         * indicating that no additional data should be received and the readable side of the Http2Stream will be closed.\n         */\n        readonly endAfterHeaders: boolean;\n        close(code?: number, callback?: () => void): void;\n        priority(options: StreamPriorityOptions): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"aborted\", listener: () => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"aborted\"): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"data\", chunk: Buffer | string): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"finish\"): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number): boolean;\n        emit(event: \"pipe\", src: stream.Readable): boolean;\n        emit(event: \"unpipe\", src: stream.Readable): boolean;\n        emit(event: \"streamClosed\", code: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"trailers\", trailers: IncomingHttpHeaders, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"aborted\", listener: () => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"streamClosed\", listener: (code: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: () => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"streamClosed\", listener: (code: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: () => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: () => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n    }\n\n    export interface ClientHttp2Stream extends Http2Stream {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        addListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"headers\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: \"push\", headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"response\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        on(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        once(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependOnceListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n    }\n\n    export interface ServerHttp2Stream extends Http2Stream {\n        additionalHeaders(headers: OutgoingHttpHeaders): void;\n        readonly headersSent: boolean;\n        readonly pushAllowed: boolean;\n        pushStream(headers: OutgoingHttpHeaders, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        pushStream(headers: OutgoingHttpHeaders, options?: StreamPriorityOptions, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;\n        respondWithFD(fd: number, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptions): void;\n        respondWithFile(path: string, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptionsWithError): void;\n    }\n\n    // Http2Session\n\n    export interface Settings {\n        headerTableSize?: number;\n        enablePush?: boolean;\n        initialWindowSize?: number;\n        maxFrameSize?: number;\n        maxConcurrentStreams?: number;\n        maxHeaderListSize?: number;\n    }\n\n    export interface ClientSessionRequestOptions {\n        endStream?: boolean;\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        getTrailers?: (trailers: OutgoingHttpHeaders, flags: number) => void;\n    }\n\n    export interface SessionState {\n        effectiveLocalWindowSize?: number;\n        effectiveRecvDataLength?: number;\n        nextStreamID?: number;\n        localWindowSize?: number;\n        lastProcStreamID?: number;\n        remoteWindowSize?: number;\n        outboundQueueSize?: number;\n        deflateDynamicTableSize?: number;\n        inflateDynamicTableSize?: number;\n    }\n\n    export interface Http2Session extends events.EventEmitter {\n        readonly alpnProtocol?: string;\n        close(callback?: () => void): void;\n        readonly closed: boolean;\n        readonly connecting: boolean;\n        destroy(error?: Error, code?: number): void;\n        readonly destroyed: boolean;\n        readonly encrypted?: boolean;\n        goaway(code?: number, lastStreamID?: number, opaqueData?: Buffer | DataView | NodeJS.TypedArray): void;\n        readonly localSettings: Settings;\n        readonly originSet?: string[];\n        readonly pendingSettingsAck: boolean;\n        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ping(payload: Buffer | DataView | NodeJS.TypedArray , callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ref(): void;\n        readonly remoteSettings: Settings;\n        rstStream(stream: Http2Stream, code?: number): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        readonly socket: net.Socket | tls.TLSSocket;\n        readonly state: SessionState;\n        priority(stream: Http2Stream, options: StreamPriorityOptions): void;\n        settings(settings: Settings): void;\n        readonly type: number;\n        unref(): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        addListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        addListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number, streamID: number): boolean;\n        emit(event: \"goaway\", errorCode: number, lastStreamID: number, opaqueData: Buffer): boolean;\n        emit(event: \"localSettings\", settings: Settings): boolean;\n        emit(event: \"remoteSettings\", settings: Settings): boolean;\n        emit(event: \"timeout\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        on(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        on(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        once(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        once(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependOnceListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependOnceListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n\n    export interface ClientHttp2Session extends Http2Session {\n        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        addListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"altsvc\", alt: string, origin: string, stream: number): boolean;\n        emit(event: \"connect\", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: \"stream\", stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        on(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        once(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependOnceListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n    }\n\n    export interface AlternativeServiceOptions {\n        origin: number | string | url.URL;\n    }\n\n    export interface ServerHttp2Session extends Http2Session {\n        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;\n        readonly server: Http2Server | Http2SecureServer;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"connect\", session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n    }\n\n    // Http2Server\n\n    export interface SessionOptions {\n        maxDeflateDynamicTableSize?: number;\n        maxReservedRemoteStreams?: number;\n        maxSendHeaderBlockLength?: number;\n        paddingStrategy?: number;\n        peerMaxConcurrentStreams?: number;\n        selectPadding?: (frameLen: number, maxFrameLen: number) => number;\n        settings?: Settings;\n    }\n\n    export type ClientSessionOptions = SessionOptions;\n    export type ServerSessionOptions = SessionOptions;\n\n    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions { }\n    export interface SecureServerSessionOptions extends ServerSessionOptions, tls.TlsOptions { }\n\n    export interface ServerOptions extends ServerSessionOptions {\n        allowHTTP1?: boolean;\n    }\n\n    export interface SecureServerOptions extends SecureServerSessionOptions {\n        allowHTTP1?: boolean;\n    }\n\n    export interface Http2Server extends net.Server {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"checkContinue\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n\n    export interface Http2SecureServer extends tls.Server {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"checkContinue\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"unknownProtocol\", socket: tls.TLSSocket): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n    }\n\n    export class Http2ServerRequest extends stream.Readable {\n        private constructor();\n        headers: IncomingHttpHeaders;\n        httpVersion: string;\n        method: string;\n        rawHeaders: string[];\n        rawTrailers: string[];\n        setTimeout(msecs: number, callback?: () => void): void;\n        socket: net.Socket | tls.TLSSocket;\n        stream: ServerHttp2Stream;\n        trailers: IncomingHttpHeaders;\n        url: string;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n    }\n\n    export class Http2ServerResponse extends events.EventEmitter {\n        private constructor();\n        addTrailers(trailers: OutgoingHttpHeaders): void;\n        connection: net.Socket | tls.TLSSocket;\n        end(callback?: () => void): void;\n        end(data?: string | Buffer, callback?: () => void): void;\n        end(data?: string | Buffer, encoding?: string, callback?: () => void): void;\n        readonly finished: boolean;\n        getHeader(name: string): string;\n        getHeaderNames(): string[];\n        getHeaders(): OutgoingHttpHeaders;\n        hasHeader(name: string): boolean;\n        readonly headersSent: boolean;\n        removeHeader(name: string): void;\n        sendDate: boolean;\n        setHeader(name: string, value: number | string | string[]): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        socket: net.Socket | tls.TLSSocket;\n        statusCode: number;\n        statusMessage: '';\n        stream: ServerHttp2Stream;\n        write(chunk: string | Buffer, callback?: (err: Error) => void): boolean;\n        write(chunk: string | Buffer, encoding?: string, callback?: (err: Error) => void): boolean;\n        writeContinue(): void;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\n        writeHead(statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders): void;\n        createPushResponse(headers: OutgoingHttpHeaders, callback: (err: Error | null, res: Http2ServerResponse) => void): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"finish\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n    }\n\n    // Public API\n\n    export namespace constants {\n        const NGHTTP2_SESSION_SERVER: number;\n        const NGHTTP2_SESSION_CLIENT: number;\n        const NGHTTP2_STREAM_STATE_IDLE: number;\n        const NGHTTP2_STREAM_STATE_OPEN: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_CLOSED: number;\n        const NGHTTP2_NO_ERROR: number;\n        const NGHTTP2_PROTOCOL_ERROR: number;\n        const NGHTTP2_INTERNAL_ERROR: number;\n        const NGHTTP2_FLOW_CONTROL_ERROR: number;\n        const NGHTTP2_SETTINGS_TIMEOUT: number;\n        const NGHTTP2_STREAM_CLOSED: number;\n        const NGHTTP2_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_REFUSED_STREAM: number;\n        const NGHTTP2_CANCEL: number;\n        const NGHTTP2_COMPRESSION_ERROR: number;\n        const NGHTTP2_CONNECT_ERROR: number;\n        const NGHTTP2_ENHANCE_YOUR_CALM: number;\n        const NGHTTP2_INADEQUATE_SECURITY: number;\n        const NGHTTP2_HTTP_1_1_REQUIRED: number;\n        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_FLAG_NONE: number;\n        const NGHTTP2_FLAG_END_STREAM: number;\n        const NGHTTP2_FLAG_END_HEADERS: number;\n        const NGHTTP2_FLAG_ACK: number;\n        const NGHTTP2_FLAG_PADDED: number;\n        const NGHTTP2_FLAG_PRIORITY: number;\n        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;\n        const DEFAULT_SETTINGS_ENABLE_PUSH: number;\n        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;\n        const MAX_MAX_FRAME_SIZE: number;\n        const MIN_MAX_FRAME_SIZE: number;\n        const MAX_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_DEFAULT_WEIGHT: number;\n        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;\n        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;\n        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;\n        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;\n        const PADDING_STRATEGY_NONE: number;\n        const PADDING_STRATEGY_MAX: number;\n        const PADDING_STRATEGY_CALLBACK: number;\n        const HTTP2_HEADER_STATUS: string;\n        const HTTP2_HEADER_METHOD: string;\n        const HTTP2_HEADER_AUTHORITY: string;\n        const HTTP2_HEADER_SCHEME: string;\n        const HTTP2_HEADER_PATH: string;\n        const HTTP2_HEADER_ACCEPT_CHARSET: string;\n        const HTTP2_HEADER_ACCEPT_ENCODING: string;\n        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;\n        const HTTP2_HEADER_ACCEPT_RANGES: string;\n        const HTTP2_HEADER_ACCEPT: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;\n        const HTTP2_HEADER_AGE: string;\n        const HTTP2_HEADER_ALLOW: string;\n        const HTTP2_HEADER_AUTHORIZATION: string;\n        const HTTP2_HEADER_CACHE_CONTROL: string;\n        const HTTP2_HEADER_CONNECTION: string;\n        const HTTP2_HEADER_CONTENT_DISPOSITION: string;\n        const HTTP2_HEADER_CONTENT_ENCODING: string;\n        const HTTP2_HEADER_CONTENT_LANGUAGE: string;\n        const HTTP2_HEADER_CONTENT_LENGTH: string;\n        const HTTP2_HEADER_CONTENT_LOCATION: string;\n        const HTTP2_HEADER_CONTENT_MD5: string;\n        const HTTP2_HEADER_CONTENT_RANGE: string;\n        const HTTP2_HEADER_CONTENT_TYPE: string;\n        const HTTP2_HEADER_COOKIE: string;\n        const HTTP2_HEADER_DATE: string;\n        const HTTP2_HEADER_ETAG: string;\n        const HTTP2_HEADER_EXPECT: string;\n        const HTTP2_HEADER_EXPIRES: string;\n        const HTTP2_HEADER_FROM: string;\n        const HTTP2_HEADER_HOST: string;\n        const HTTP2_HEADER_IF_MATCH: string;\n        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;\n        const HTTP2_HEADER_IF_NONE_MATCH: string;\n        const HTTP2_HEADER_IF_RANGE: string;\n        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;\n        const HTTP2_HEADER_LAST_MODIFIED: string;\n        const HTTP2_HEADER_LINK: string;\n        const HTTP2_HEADER_LOCATION: string;\n        const HTTP2_HEADER_MAX_FORWARDS: string;\n        const HTTP2_HEADER_PREFER: string;\n        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;\n        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;\n        const HTTP2_HEADER_RANGE: string;\n        const HTTP2_HEADER_REFERER: string;\n        const HTTP2_HEADER_REFRESH: string;\n        const HTTP2_HEADER_RETRY_AFTER: string;\n        const HTTP2_HEADER_SERVER: string;\n        const HTTP2_HEADER_SET_COOKIE: string;\n        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;\n        const HTTP2_HEADER_TRANSFER_ENCODING: string;\n        const HTTP2_HEADER_TE: string;\n        const HTTP2_HEADER_UPGRADE: string;\n        const HTTP2_HEADER_USER_AGENT: string;\n        const HTTP2_HEADER_VARY: string;\n        const HTTP2_HEADER_VIA: string;\n        const HTTP2_HEADER_WWW_AUTHENTICATE: string;\n        const HTTP2_HEADER_HTTP2_SETTINGS: string;\n        const HTTP2_HEADER_KEEP_ALIVE: string;\n        const HTTP2_HEADER_PROXY_CONNECTION: string;\n        const HTTP2_METHOD_ACL: string;\n        const HTTP2_METHOD_BASELINE_CONTROL: string;\n        const HTTP2_METHOD_BIND: string;\n        const HTTP2_METHOD_CHECKIN: string;\n        const HTTP2_METHOD_CHECKOUT: string;\n        const HTTP2_METHOD_CONNECT: string;\n        const HTTP2_METHOD_COPY: string;\n        const HTTP2_METHOD_DELETE: string;\n        const HTTP2_METHOD_GET: string;\n        const HTTP2_METHOD_HEAD: string;\n        const HTTP2_METHOD_LABEL: string;\n        const HTTP2_METHOD_LINK: string;\n        const HTTP2_METHOD_LOCK: string;\n        const HTTP2_METHOD_MERGE: string;\n        const HTTP2_METHOD_MKACTIVITY: string;\n        const HTTP2_METHOD_MKCALENDAR: string;\n        const HTTP2_METHOD_MKCOL: string;\n        const HTTP2_METHOD_MKREDIRECTREF: string;\n        const HTTP2_METHOD_MKWORKSPACE: string;\n        const HTTP2_METHOD_MOVE: string;\n        const HTTP2_METHOD_OPTIONS: string;\n        const HTTP2_METHOD_ORDERPATCH: string;\n        const HTTP2_METHOD_PATCH: string;\n        const HTTP2_METHOD_POST: string;\n        const HTTP2_METHOD_PRI: string;\n        const HTTP2_METHOD_PROPFIND: string;\n        const HTTP2_METHOD_PROPPATCH: string;\n        const HTTP2_METHOD_PUT: string;\n        const HTTP2_METHOD_REBIND: string;\n        const HTTP2_METHOD_REPORT: string;\n        const HTTP2_METHOD_SEARCH: string;\n        const HTTP2_METHOD_TRACE: string;\n        const HTTP2_METHOD_UNBIND: string;\n        const HTTP2_METHOD_UNCHECKOUT: string;\n        const HTTP2_METHOD_UNLINK: string;\n        const HTTP2_METHOD_UNLOCK: string;\n        const HTTP2_METHOD_UPDATE: string;\n        const HTTP2_METHOD_UPDATEREDIRECTREF: string;\n        const HTTP2_METHOD_VERSION_CONTROL: string;\n        const HTTP_STATUS_CONTINUE: number;\n        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;\n        const HTTP_STATUS_PROCESSING: number;\n        const HTTP_STATUS_OK: number;\n        const HTTP_STATUS_CREATED: number;\n        const HTTP_STATUS_ACCEPTED: number;\n        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;\n        const HTTP_STATUS_NO_CONTENT: number;\n        const HTTP_STATUS_RESET_CONTENT: number;\n        const HTTP_STATUS_PARTIAL_CONTENT: number;\n        const HTTP_STATUS_MULTI_STATUS: number;\n        const HTTP_STATUS_ALREADY_REPORTED: number;\n        const HTTP_STATUS_IM_USED: number;\n        const HTTP_STATUS_MULTIPLE_CHOICES: number;\n        const HTTP_STATUS_MOVED_PERMANENTLY: number;\n        const HTTP_STATUS_FOUND: number;\n        const HTTP_STATUS_SEE_OTHER: number;\n        const HTTP_STATUS_NOT_MODIFIED: number;\n        const HTTP_STATUS_USE_PROXY: number;\n        const HTTP_STATUS_TEMPORARY_REDIRECT: number;\n        const HTTP_STATUS_PERMANENT_REDIRECT: number;\n        const HTTP_STATUS_BAD_REQUEST: number;\n        const HTTP_STATUS_UNAUTHORIZED: number;\n        const HTTP_STATUS_PAYMENT_REQUIRED: number;\n        const HTTP_STATUS_FORBIDDEN: number;\n        const HTTP_STATUS_NOT_FOUND: number;\n        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;\n        const HTTP_STATUS_NOT_ACCEPTABLE: number;\n        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;\n        const HTTP_STATUS_REQUEST_TIMEOUT: number;\n        const HTTP_STATUS_CONFLICT: number;\n        const HTTP_STATUS_GONE: number;\n        const HTTP_STATUS_LENGTH_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_FAILED: number;\n        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;\n        const HTTP_STATUS_URI_TOO_LONG: number;\n        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;\n        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;\n        const HTTP_STATUS_EXPECTATION_FAILED: number;\n        const HTTP_STATUS_TEAPOT: number;\n        const HTTP_STATUS_MISDIRECTED_REQUEST: number;\n        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;\n        const HTTP_STATUS_LOCKED: number;\n        const HTTP_STATUS_FAILED_DEPENDENCY: number;\n        const HTTP_STATUS_UNORDERED_COLLECTION: number;\n        const HTTP_STATUS_UPGRADE_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_REQUIRED: number;\n        const HTTP_STATUS_TOO_MANY_REQUESTS: number;\n        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;\n        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;\n        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;\n        const HTTP_STATUS_NOT_IMPLEMENTED: number;\n        const HTTP_STATUS_BAD_GATEWAY: number;\n        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;\n        const HTTP_STATUS_GATEWAY_TIMEOUT: number;\n        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;\n        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;\n        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;\n        const HTTP_STATUS_LOOP_DETECTED: number;\n        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;\n        const HTTP_STATUS_NOT_EXTENDED: number;\n        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;\n    }\n\n    export function getDefaultSettings(): Settings;\n    export function getPackedSettings(settings: Settings): Settings;\n    export function getUnpackedSettings(buf: Buffer | Uint8Array): Settings;\n\n    export function createServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n    export function createServer(options: ServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n\n    export function createSecureServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n    export function createSecureServer(options: SecureServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n\n    export function connect(authority: string | url.URL, listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;\n    export function connect(\n        authority: string | url.URL,\n        options?: ClientSessionOptions | SecureClientSessionOptions,\n        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n    ): ClientHttp2Session;\n}\n\ndeclare module \"perf_hooks\" {\n    import { AsyncResource } from \"async_hooks\";\n\n    interface PerformanceEntry {\n        /**\n         * The total number of milliseconds elapsed for this entry.\n         * This value will not be meaningful for all Performance Entry types.\n         */\n        readonly duration: number;\n\n        /**\n         * The name of the performance entry.\n         */\n        readonly name: string;\n\n        /**\n         * The high resolution millisecond timestamp marking the starting time of the Performance Entry.\n         */\n        readonly startTime: number;\n\n        /**\n         * The type of the performance entry.\n         * Currently it may be one of: 'node', 'mark', 'measure', 'gc', or 'function'.\n         */\n        readonly entryType: string;\n\n        /**\n         * When performanceEntry.entryType is equal to 'gc', the performance.kind property identifies\n         * the type of garbage collection operation that occurred.\n         * The value may be one of perf_hooks.constants.\n         */\n        readonly kind?: number;\n    }\n\n    interface PerformanceNodeTiming extends PerformanceEntry {\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process completed bootstrap.\n         */\n        readonly bootstrapComplete: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing ended.\n         */\n        readonly clusterSetupEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing started.\n         */\n        readonly clusterSetupStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop exited.\n         */\n        readonly loopExit: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop started.\n         */\n        readonly loopStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load ended.\n         */\n        readonly moduleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load started.\n         */\n        readonly moduleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process was initialized.\n         */\n        readonly nodeStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load ended.\n         */\n        readonly preloadModuleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load started.\n         */\n        readonly preloadModuleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing ended.\n         */\n        readonly thirdPartyMainEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing started.\n         */\n        readonly thirdPartyMainStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the V8 platform was initialized.\n         */\n        readonly v8Start: number;\n    }\n\n    interface Performance {\n        /**\n         * If name is not provided, removes all PerformanceFunction objects from the Performance Timeline.\n         * If name is provided, removes entries with name.\n         * @param name\n         */\n        clearFunctions(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMark objects from the Performance Timeline.\n         * If name is provided, removes only the named mark.\n         * @param name\n         */\n        clearMarks(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMeasure objects from the Performance Timeline.\n         * If name is provided, removes only objects whose performanceEntry.name matches name.\n         */\n        clearMeasures(name?: string): void;\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         * @return list of all PerformanceEntry objects\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         * @param name\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByName(name: string, type?: string): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByType(type: string): PerformanceEntry[];\n\n        /**\n         * Creates a new PerformanceMark entry in the Performance Timeline.\n         * A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'mark',\n         * and whose performanceEntry.duration is always 0.\n         * Performance marks are used to mark specific significant moments in the Performance Timeline.\n         * @param name\n         */\n        mark(name?: string): void;\n\n        /**\n         * Creates a new PerformanceMeasure entry in the Performance Timeline.\n         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',\n         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.\n         *\n         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify\n         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,\n         * then startMark is set to timeOrigin by default.\n         *\n         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp\n         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.\n         * @param name\n         * @param startMark\n         * @param endMark\n         */\n        measure(name: string, startMark: string, endMark: string): void;\n\n        /**\n         * An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones.\n         */\n        readonly nodeTiming: PerformanceNodeTiming;\n\n        /**\n         * @return the current high resolution millisecond timestamp\n         */\n        now(): number;\n\n        /**\n         * The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured.\n         */\n        readonly timeOrigin: number;\n\n        /**\n         * Wraps a function within a new function that measures the running time of the wrapped function.\n         * A PerformanceObserver must be subscribed to the 'function' event type in order for the timing details to be accessed.\n         * @param fn\n         */\n        timerify<T extends (...optionalParams: any[]) => any>(fn: T): T;\n    }\n\n    interface PerformanceObserverEntryList {\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByName(name: string, type?: string): PerformanceEntry[];\n\n        /**\n         * @return Returns a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByType(type: string): PerformanceEntry[];\n    }\n\n    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;\n\n    class PerformanceObserver extends AsyncResource {\n        constructor(callback: PerformanceObserverCallback);\n\n        /**\n         * Disconnects the PerformanceObserver instance from all notifications.\n         */\n        disconnect(): void;\n\n        /**\n         * Subscribes the PerformanceObserver instance to notifications of new PerformanceEntry instances identified by options.entryTypes.\n         * When options.buffered is false, the callback will be invoked once for every PerformanceEntry instance.\n         * Property buffered defaults to false.\n         * @param options\n         */\n        observe(options: { entryTypes: string[], buffered?: boolean }): void;\n    }\n\n    namespace constants {\n        const NODE_PERFORMANCE_GC_MAJOR: number;\n        const NODE_PERFORMANCE_GC_MINOR: number;\n        const NODE_PERFORMANCE_GC_INCREMENTAL: number;\n        const NODE_PERFORMANCE_GC_WEAKCB: number;\n    }\n\n    const performance: Performance;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmbdh7dp"
      ],
      "thing": "node",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ]
    },
    "01m4wm3xjctl": {
      "id": "01m4wm3xjctl",
      "pos": 3609,
      "end": 3978,
      "text": "from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnspmc95"
      ],
      "name": "from",
      "type": [
        "type",
        895
      ]
    },
    "01m4wn9099ak": {
      "id": "01m4wn9099ak",
      "pos": 2137,
      "end": 2516,
      "text": "from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "node",
      "kind": "MethodSignature",
      "flags": "Ambient",
      "parent": [
        "node",
        "01m4wnfrthog"
      ],
      "name": "from",
      "type": [
        "type",
        895
      ]
    }
  },
  "sourceFile": {
    "01m4wnff99qd": {
      "id": "01m4wnff99qd",
      "pos": 0,
      "end": 235,
      "text": "export interface VehicleLike {\n  /**\n   * Start driving\n   */\n  drive(): void;\n}\n\n/**\n * A factory for vehicles\n */\nexport type VehicleFactory<N extends number> = new (\n  numWheels: N,\n) => VehicleLike;\n",
      "sourceFile": [
        "sourceFile",
        "01m4wnff99qd"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wn661fce"
        ],
        [
          "node",
          "01m4wmmjrvpn"
        ]
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/types.ts",
      "isDeclarationFile": false,
      "amdDependencies": [],
      "symbol": [
        "symbol",
        "01m4wmn1jtlc"
      ]
    },
    "01m4wlu7hcxf": {
      "id": "01m4wlu7hcxf",
      "pos": 0,
      "end": 483,
      "text": "import { VehicleFactory, VehicleLike } from \"./types\";\n\n/**\n * A vehicle is a thing that goes places\n */\nexport default class Vehicle implements VehicleLike {\n  /**\n   * Create a new vehicle\n   * @param {number} numWheels Number of wheels\n   */\n  constructor(protected numWheels: number) {}\n  /**\n   * Drive the vehicle\n   * @returns {string}\n   */\n  public drive() {\n    return `Driving with all ${this.numWheels} wheels`;\n  }\n}\n\nexport const Factory4: VehicleFactory<4> = Vehicle;\n",
      "sourceFile": [
        "sourceFile",
        "01m4wlu7hcxf"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wnmkepxu"
        ]
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/vehicle.ts",
      "isDeclarationFile": false,
      "amdDependencies": [],
      "symbol": [
        "symbol",
        "01m4wne8buvw"
      ]
    },
    "01m4wmg3dxx8": {
      "id": "01m4wmg3dxx8",
      "pos": 0,
      "end": 322,
      "text": "import Vehicle from './vehicle';\n\n/**\n * A bike is a 2-wheeled vehicle\n */\nexport class Bike extends Vehicle {\n  constructor() {\n    super(2);\n  }\n}\n\n/**\n * A Unicycle is a 1-wheeled vehicle\n */\n// tslint:disable-next-line:max-classes-per-file\nexport class Unicycle extends Vehicle {\n  constructor() {\n    super(1);\n  }\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmg3dxx8"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wnhowcn6"
        ],
        [
          "node",
          "01m4wmxuabg6"
        ]
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/cycles.ts",
      "isDeclarationFile": false,
      "amdDependencies": [],
      "symbol": [
        "symbol",
        "01m4wllkm4ws"
      ]
    },
    "01m4wmnl4m34": {
      "id": "01m4wmnl4m34",
      "pos": 0,
      "end": 189,
      "text": "import Vehicle from \"./vehicle\";\n\n/**\n * A car is a 4-wheeled vehicle\n */\nexport default class Car extends Vehicle {\n  /**\n   * Create a new car\n   */\n  constructor() {\n    super(4);\n  }\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmnl4m34"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wmyeu4oh"
        ]
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/cases/6-ts-advanced-types/src/car.ts",
      "isDeclarationFile": false,
      "amdDependencies": [],
      "symbol": [
        "symbol",
        "01m4wlrk93ht"
      ]
    },
    "01m4wlr69xyn": {
      "id": "01m4wlr69xyn",
      "pos": 0,
      "end": 1541,
      "text": "import { Bike } from './cycles';\n\n/**\n * Add two numbers together\n * @param a first number\n * @param b second number\n */\nexport function add(a: number, b: number): number;\nexport function add(a: string, b: string): string;\nexport function add(a: number | string, b: number | string): number | string {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  } else {\n    return '' + a + b;\n  }\n}\n\nexport const SECRET_STRING = 'shhhhh!';\n\nexport { default as Car } from './car';\nexport { Unicycle, Bike } from './cycles';\nexport { VehicleLike } from './types';\n\n/**\n * A class that helps with vehicle maintenance\n */\nclass VehicleUtils {\n  /**\n   * Static things\n   */\n  public static description: 'Utilities for vehicles';\n  /**\n   * Members\n   */\n  public memberFn() {\n    return '';\n  }\n}\n\n// tslint:disable-next-line:no-namespace\nnamespace VehicleUtils {\n  /**\n   * Create a new bike\n   */\n  export function createBike(): Bike {\n    return new Bike();\n  }\n}\n\n/**\n * The first bike\n */\nexport const firstBike = VehicleUtils.createBike();\n\n/**\n * Create a promise that resolves after a period of time has elapsed\n * @param n number of milliseconds to wait\n */\nfunction timeout(n: number) {\n  return new Promise<void>(resolve => setTimeout(resolve, n));\n}\n\nexport const bikeNow = timeout(0).then(() => new Bike());\n// Get a bike soon\nexport const bikeSoon = timeout(3000).then(() => new Bike());\n/**\n * Get a bike later\n */\nexport const bikeLater = timeout(10000).then(() => new Bike());\n",
      "sourceFile": [
        "sourceFile",
        "01m4wlr69xyn"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "children": [
        [
          "node",
          "01m4wlorf6g7"
        ],
        [
          "node",
          "01m4wna76n7c"
        ],
        [
          "node",
          "01m4wnso8fts"
        ],
        [
          "node",
          "01m4wno7p69a"
        ],
        [
          "node",
          "01m4wlrd9j0i"
        ],
        [
          "node",
          "01m4wm2gtk7p"
        ]
      ],
      "fileName": "cases/6-ts-advanced-types/src/index.ts",
      "isDeclarationFile": false,
      "amdDependencies": [],
      "typeReferenceDirectives": [
        {
          "name": "lodash",
          "pos": 22,
          "end": 28
        }
      ],
      "symbol": [
        "symbol",
        "01m4wnb74hed"
      ]
    },
    "01m4wmvyle70": {
      "id": "01m4wmvyle70",
      "pos": 0,
      "end": 10652,
      "text": "interface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise<any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>]): Promise<[T1, T2, T3, T4]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<T1 | T2 | T3 | T4 | T5 | T6>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<T1 | T2 | T3 | T4 | T5>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<T1 | T2 | T3 | T4>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<T1 | T2 | T3>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<T1 | T2>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: (T | PromiseLike<T>)[]): Promise<T>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject<T = never>(reason?: any): Promise<T>;\n\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\n    /**\n     * Creates a new resolved promise .\n     * @returns A resolved promise.\n     */\n    resolve(): Promise<void>;\n}\n\ndeclare var Promise: PromiseConstructor;\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmvyle70"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.es2015.promise.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": []
    },
    "01m4wlpn69il": {
      "id": "01m4wlpn69il",
      "pos": 0,
      "end": 196217,
      "text": "declare const NaN: number;\ndeclare const Infinity: number;\n\n/**\n  * Evaluates JavaScript code and executes it.\n  * @param x A String value that contains valid JavaScript code.\n  */\ndeclare function eval(x: string): any;\n\n/**\n  * Converts A string to an integer.\n  * @param s A string to convert into a number.\n  * @param radix A value between 2 and 36 that specifies the base of the number in numString.\n  * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n  * All other strings are considered decimal.\n  */\ndeclare function parseInt(s: string, radix?: number): number;\n\n/**\n  * Converts a string to a floating-point number.\n  * @param string A string that contains a floating-point number.\n  */\ndeclare function parseFloat(string: string): number;\n\n/**\n  * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number).\n  * @param number A numeric value.\n  */\ndeclare function isNaN(number: number): boolean;\n\n/**\n  * Determines whether a supplied number is finite.\n  * @param number Any numeric value.\n  */\ndeclare function isFinite(number: number): boolean;\n\n/**\n  * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\n  * @param encodedURI A value representing an encoded URI.\n  */\ndeclare function decodeURI(encodedURI: string): string;\n\n/**\n  * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\n  * @param encodedURIComponent A value representing an encoded URI component.\n  */\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\n\n/**\n  * Encodes a text string as a valid Uniform Resource Identifier (URI)\n  * @param uri A value representing an encoded URI.\n  */\ndeclare function encodeURI(uri: string): string;\n\n/**\n  * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\n  * @param uriComponent A value representing an encoded URI component.\n  */\ndeclare function encodeURIComponent(uriComponent: string): string;\n\n/**\n  * Computes a new string in which certain characters have been replaced by a hexadecimal escape sequence.\n  * @param string A string value\n  */\ndeclare function escape(string: string): string;\n\n/**\n  * Computes a new string in which hexadecimal escape sequences are replaced with the character that it represents.\n  * @param string A string value\n  */\ndeclare function unescape(string: string): string;\n\ninterface Symbol {\n  /** Returns a string representation of an object. */\n  toString(): string;\n\n  /** Returns the primitive value of the specified object. */\n  valueOf(): symbol;\n}\n\ndeclare type PropertyKey = string | number | symbol;\n\ninterface PropertyDescriptor {\n    configurable?: boolean;\n    enumerable?: boolean;\n    value?: any;\n    writable?: boolean;\n    get?(): any;\n    set?(v: any): void;\n}\n\ninterface PropertyDescriptorMap {\n    [s: string]: PropertyDescriptor;\n}\n\ninterface Object {\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\n    constructor: Function;\n\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns a date converted to a string using the current locale. */\n    toLocaleString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Object;\n\n    /**\n      * Determines whether an object has a property with the specified name.\n      * @param v A property name.\n      */\n    hasOwnProperty(v: PropertyKey): boolean;\n\n    /**\n      * Determines whether an object exists in another object's prototype chain.\n      * @param v Another object whose prototype chain is to be checked.\n      */\n    isPrototypeOf(v: Object): boolean;\n\n    /**\n      * Determines whether a specified property is enumerable.\n      * @param v A property name.\n      */\n    propertyIsEnumerable(v: PropertyKey): boolean;\n}\n\ninterface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    /**\n      * Returns the prototype of an object.\n      * @param o The object that references the prototype.\n      */\n    getPrototypeOf(o: any): any;\n\n    /**\n      * Gets the own property descriptor of the specified object.\n      * An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype.\n      * @param o Object that contains the property.\n      * @param p Name of the property.\n    */\n    getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;\n\n    /**\n      * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\n      * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\n      * @param o Object that contains the own properties.\n      */\n    getOwnPropertyNames(o: any): string[];\n\n    /**\n      * Creates an object that has the specified prototype or that has null prototype.\n      * @param o Object to use as a prototype. May be null.\n      */\n    create(o: object | null): any;\n\n    /**\n      * Creates an object that has the specified prototype, and that optionally contains specified properties.\n      * @param o Object to use as a prototype. May be null\n      * @param properties JavaScript object that contains one or more property descriptors.\n      */\n    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Adds a property to an object, or modifies attributes of an existing property.\n      * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.\n      * @param p The property name.\n      * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\n      */\n    defineProperty(o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): any;\n\n    /**\n      * Adds one or more properties to an object, and/or modifies attributes of existing properties.\n      * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.\n      * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.\n      */\n    defineProperties(o: any, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    seal<T>(o: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(a: T[]): ReadonlyArray<T>;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T extends Function>(f: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(o: T): Readonly<T>;\n\n    /**\n      * Prevents the addition of new properties to an object.\n      * @param o Object to make non-extensible.\n      */\n    preventExtensions<T>(o: T): T;\n\n    /**\n      * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isSealed(o: any): boolean;\n\n    /**\n      * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isFrozen(o: any): boolean;\n\n    /**\n      * Returns a value that indicates whether new properties can be added to an object.\n      * @param o Object to test.\n      */\n    isExtensible(o: any): boolean;\n\n    /**\n      * Returns the names of the enumerable properties and methods of an object.\n      * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n      */\n    keys(o: {}): string[];\n}\n\n/**\n  * Provides functionality common to all JavaScript objects.\n  */\ndeclare const Object: ObjectConstructor;\n\n/**\n  * Creates a new function.\n  */\ninterface Function {\n    /**\n      * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n      * @param thisArg The object to be used as the this object.\n      * @param argArray A set of arguments to be passed to the function.\n      */\n    apply(this: Function, thisArg: any, argArray?: any): any;\n\n    /**\n      * Calls a method of an object, substituting another object for the current object.\n      * @param thisArg The object to be used as the current object.\n      * @param argArray A list of arguments to be passed to the method.\n      */\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /**\n      * For a given function, creates a bound function that has the same body as the original function.\n      * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n      * @param thisArg An object to which the this keyword can refer inside the new function.\n      * @param argArray A list of arguments to be passed to the new function.\n      */\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /** Returns a string representation of a function. */\n    toString(): string;\n\n    prototype: any;\n    readonly length: number;\n\n    // Non-standard extensions\n    arguments: any;\n    caller: Function;\n}\n\ninterface FunctionConstructor {\n    /**\n      * Creates a new function.\n      * @param args A list of arguments the function accepts.\n      */\n    new(...args: string[]): Function;\n    (...args: string[]): Function;\n    readonly prototype: Function;\n}\n\ndeclare const Function: FunctionConstructor;\n\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n\ninterface String {\n    /** Returns a string representation of a string. */\n    toString(): string;\n\n    /**\n      * Returns the character at the specified index.\n      * @param pos The zero-based index of the desired character.\n      */\n    charAt(pos: number): string;\n\n    /**\n      * Returns the Unicode value of the character at the specified location.\n      * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n      */\n    charCodeAt(index: number): number;\n\n    /**\n      * Returns a string that contains the concatenation of two or more strings.\n      * @param strings The strings to append to the end of the string.\n      */\n    concat(...strings: string[]): string;\n\n    /**\n      * Returns the position of the first occurrence of a substring.\n      * @param searchString The substring to search for in the string\n      * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\n      */\n    indexOf(searchString: string, position?: number): number;\n\n    /**\n      * Returns the last occurrence of a substring in the string.\n      * @param searchString The substring to search for.\n      * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n      */\n    lastIndexOf(searchString: string, position?: number): number;\n\n    /**\n      * Determines whether two strings are equivalent in the current locale.\n      * @param that String to compare to target string\n      */\n    localeCompare(that: string): number;\n\n    /**\n      * Matches a string with a regular expression, and returns an array containing the results of that search.\n      * @param regexp A variable name or string literal containing the regular expression pattern and flags.\n      */\n    match(regexp: string | RegExp): RegExpMatchArray | null;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n      */\n    replace(searchValue: string | RegExp, replaceValue: string): string;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replacer A function that returns the replacement text.\n      */\n    replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n      * Finds the first substring match in a regular expression search.\n      * @param regexp The regular expression pattern and applicable flags.\n      */\n    search(regexp: string | RegExp): number;\n\n    /**\n      * Returns a section of a string.\n      * @param start The index to the beginning of the specified portion of stringObj.\n      * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\n      * If this value is not specified, the substring continues to the end of stringObj.\n      */\n    slice(start?: number, end?: number): string;\n\n    /**\n      * Split a string into substrings using the specified separator and return them as an array.\n      * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\n      * @param limit A value used to limit the number of elements returned in the array.\n      */\n    split(separator: string | RegExp, limit?: number): string[];\n\n    /**\n      * Returns the substring at the specified location within a String object.\n      * @param start The zero-based index number indicating the beginning of the substring.\n      * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\n      * If end is omitted, the characters from start through the end of the original string are returned.\n      */\n    substring(start: number, end?: number): string;\n\n    /** Converts all the alphabetic characters in a string to lowercase. */\n    toLowerCase(): string;\n\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */\n    toLocaleLowerCase(): string;\n\n    /** Converts all the alphabetic characters in a string to uppercase. */\n    toUpperCase(): string;\n\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */\n    toLocaleUpperCase(): string;\n\n    /** Removes the leading and trailing white space and line terminator characters from a string. */\n    trim(): string;\n\n    /** Returns the length of a String object. */\n    readonly length: number;\n\n    // IE extensions\n    /**\n      * Gets a substring beginning at the specified location and having the specified length.\n      * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n      * @param length The number of characters to include in the returned substring.\n      */\n    substr(from: number, length?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): string;\n\n    readonly [index: number]: string;\n}\n\ninterface StringConstructor {\n    new(value?: any): String;\n    (value?: any): string;\n    readonly prototype: String;\n    fromCharCode(...codes: number[]): string;\n}\n\n/**\n  * Allows manipulation and formatting of text strings and determination and location of substrings within strings.\n  */\ndeclare const String: StringConstructor;\n\ninterface Boolean {\n    /** Returns the primitive value of the specified object. */\n    valueOf(): boolean;\n}\n\ninterface BooleanConstructor {\n    new(value?: any): Boolean;\n    (value?: any): boolean;\n    readonly prototype: Boolean;\n}\n\ndeclare const Boolean: BooleanConstructor;\n\ninterface Number {\n    /**\n      * Returns a string representation of an object.\n      * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.\n      */\n    toString(radix?: number): string;\n\n    /**\n      * Returns a string representing a number in fixed-point notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toFixed(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented in exponential notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toExponential(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n      * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.\n      */\n    toPrecision(precision?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): number;\n}\n\ninterface NumberConstructor {\n    new(value?: any): Number;\n    (value?: any): number;\n    readonly prototype: Number;\n\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\n    readonly MAX_VALUE: number;\n\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\n    readonly MIN_VALUE: number;\n\n    /**\n      * A value that is not a number.\n      * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\n      */\n    readonly NaN: number;\n\n    /**\n      * A value that is less than the largest negative number that can be represented in JavaScript.\n      * JavaScript displays NEGATIVE_INFINITY values as -infinity.\n      */\n    readonly NEGATIVE_INFINITY: number;\n\n    /**\n      * A value greater than the largest number that can be represented in JavaScript.\n      * JavaScript displays POSITIVE_INFINITY values as infinity.\n      */\n    readonly POSITIVE_INFINITY: number;\n}\n\n/** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */\ndeclare const Number: NumberConstructor;\n\ninterface TemplateStringsArray extends ReadonlyArray<string> {\n    readonly raw: ReadonlyArray<string>;\n}\n\n/**\n * The type of `import.meta`.\n * \n * If you need to declare that a given property exists on `import.meta`,\n * this type may be augmented via interface merging.\n */\ninterface ImportMeta {\n}\n\ninterface Math {\n    /** The mathematical constant e. This is Euler's number, the base of natural logarithms. */\n    readonly E: number;\n    /** The natural logarithm of 10. */\n    readonly LN10: number;\n    /** The natural logarithm of 2. */\n    readonly LN2: number;\n    /** The base-2 logarithm of e. */\n    readonly LOG2E: number;\n    /** The base-10 logarithm of e. */\n    readonly LOG10E: number;\n    /** Pi. This is the ratio of the circumference of a circle to its diameter. */\n    readonly PI: number;\n    /** The square root of 0.5, or, equivalently, one divided by the square root of 2. */\n    readonly SQRT1_2: number;\n    /** The square root of 2. */\n    readonly SQRT2: number;\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    abs(x: number): number;\n    /**\n      * Returns the arc cosine (or inverse cosine) of a number.\n      * @param x A numeric expression.\n      */\n    acos(x: number): number;\n    /**\n      * Returns the arcsine of a number.\n      * @param x A numeric expression.\n      */\n    asin(x: number): number;\n    /**\n      * Returns the arctangent of a number.\n      * @param x A numeric expression for which the arctangent is needed.\n      */\n    atan(x: number): number;\n    /**\n      * Returns the angle (in radians) from the X axis to a point.\n      * @param y A numeric expression representing the cartesian y-coordinate.\n      * @param x A numeric expression representing the cartesian x-coordinate.\n      */\n    atan2(y: number, x: number): number;\n    /**\n      * Returns the smallest integer greater than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    ceil(x: number): number;\n    /**\n      * Returns the cosine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    cos(x: number): number;\n    /**\n      * Returns e (the base of natural logarithms) raised to a power.\n      * @param x A numeric expression representing the power of e.\n      */\n    exp(x: number): number;\n    /**\n      * Returns the greatest integer less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    floor(x: number): number;\n    /**\n      * Returns the natural logarithm (base e) of a number.\n      * @param x A numeric expression.\n      */\n    log(x: number): number;\n    /**\n      * Returns the larger of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    max(...values: number[]): number;\n    /**\n      * Returns the smaller of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    min(...values: number[]): number;\n    /**\n      * Returns the value of a base expression taken to a specified power.\n      * @param x The base value of the expression.\n      * @param y The exponent value of the expression.\n      */\n    pow(x: number, y: number): number;\n    /** Returns a pseudorandom number between 0 and 1. */\n    random(): number;\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    round(x: number): number;\n    /**\n      * Returns the sine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    sin(x: number): number;\n    /**\n      * Returns the square root of a number.\n      * @param x A numeric expression.\n      */\n    sqrt(x: number): number;\n    /**\n      * Returns the tangent of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    tan(x: number): number;\n}\n/** An intrinsic object that provides basic mathematics functionality and constants. */\ndeclare const Math: Math;\n\n/** Enables basic storage and retrieval of dates and times. */\ninterface Date {\n    /** Returns a string representation of a date. The format of the string depends on the locale. */\n    toString(): string;\n    /** Returns a date as a string value. */\n    toDateString(): string;\n    /** Returns a time as a string value. */\n    toTimeString(): string;\n    /** Returns a value as a string value appropriate to the host environment's current locale. */\n    toLocaleString(): string;\n    /** Returns a date as a string value appropriate to the host environment's current locale. */\n    toLocaleDateString(): string;\n    /** Returns a time as a string value appropriate to the host environment's current locale. */\n    toLocaleTimeString(): string;\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\n    valueOf(): number;\n    /** Gets the time value in milliseconds. */\n    getTime(): number;\n    /** Gets the year, using local time. */\n    getFullYear(): number;\n    /** Gets the year using Universal Coordinated Time (UTC). */\n    getUTCFullYear(): number;\n    /** Gets the month, using local time. */\n    getMonth(): number;\n    /** Gets the month of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMonth(): number;\n    /** Gets the day-of-the-month, using local time. */\n    getDate(): number;\n    /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */\n    getUTCDate(): number;\n    /** Gets the day of the week, using local time. */\n    getDay(): number;\n    /** Gets the day of the week using Universal Coordinated Time (UTC). */\n    getUTCDay(): number;\n    /** Gets the hours in a date, using local time. */\n    getHours(): number;\n    /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */\n    getUTCHours(): number;\n    /** Gets the minutes of a Date object, using local time. */\n    getMinutes(): number;\n    /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMinutes(): number;\n    /** Gets the seconds of a Date object, using local time. */\n    getSeconds(): number;\n    /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCSeconds(): number;\n    /** Gets the milliseconds of a Date, using local time. */\n    getMilliseconds(): number;\n    /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMilliseconds(): number;\n    /** Gets the difference in minutes between the time on the local computer and Universal Coordinated Time (UTC). */\n    getTimezoneOffset(): number;\n    /**\n      * Sets the date and time value in the Date object.\n      * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT.\n      */\n    setTime(time: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using local time.\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setMilliseconds(ms: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setUTCMilliseconds(ms: number): number;\n\n    /**\n      * Sets the seconds value in the Date object using local time.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using local time.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hour value in the Date object using local time.\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hours value in the Date object using Universal Coordinated Time (UTC).\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the numeric day-of-the-month value of the Date object using local time.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setDate(date: number): number;\n    /**\n      * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCDate(date: number): number;\n    /**\n      * Sets the month value in the Date object using local time.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.\n      */\n    setMonth(month: number, date?: number): number;\n    /**\n      * Sets the month value in the Date object using Universal Coordinated Time (UTC).\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.\n      */\n    setUTCMonth(month: number, date?: number): number;\n    /**\n      * Sets the year of the Date object using local time.\n      * @param year A numeric value for the year.\n      * @param month A zero-based numeric value for the month (0 for January, 11 for December). Must be specified if numDate is specified.\n      * @param date A numeric value equal for the day of the month.\n      */\n    setFullYear(year: number, month?: number, date?: number): number;\n    /**\n      * Sets the year value in the Date object using Universal Coordinated Time (UTC).\n      * @param year A numeric value equal to the year.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. Must be supplied if numDate is supplied.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCFullYear(year: number, month?: number, date?: number): number;\n    /** Returns a date converted to a string using Universal Coordinated Time (UTC). */\n    toUTCString(): string;\n    /** Returns a date as a string value in ISO format. */\n    toISOString(): string;\n    /** Used by the JSON.stringify method to enable the transformation of an object's data for JavaScript Object Notation (JSON) serialization. */\n    toJSON(key?: any): string;\n}\n\ninterface DateConstructor {\n    new(): Date;\n    new(value: number | string): Date;\n    new(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n    (): string;\n    readonly prototype: Date;\n    /**\n      * Parses a string containing a date, and returns the number of milliseconds between that date and midnight, January 1, 1970.\n      * @param s A date string\n      */\n    parse(s: string): number;\n    /**\n      * Returns the number of milliseconds between midnight, January 1, 1970 Universal Coordinated Time (UTC) (or GMT) and the specified date.\n      * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\n      * @param month The month as an number between 0 and 11 (January to December).\n      * @param date The date as an number between 1 and 31.\n      * @param hours Must be supplied if minutes is supplied. An number from 0 to 23 (midnight to 11pm) that specifies the hour.\n      * @param minutes Must be supplied if seconds is supplied. An number from 0 to 59 that specifies the minutes.\n      * @param seconds Must be supplied if milliseconds is supplied. An number from 0 to 59 that specifies the seconds.\n      * @param ms An number from 0 to 999 that specifies the milliseconds.\n      */\n    UTC(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number;\n    now(): number;\n}\n\ndeclare const Date: DateConstructor;\n\ninterface RegExpMatchArray extends Array<string> {\n    index?: number;\n    input?: string;\n}\n\ninterface RegExpExecArray extends Array<string> {\n    index: number;\n    input: string;\n}\n\ninterface RegExp {\n    /**\n      * Executes a search on a string using a regular expression pattern, and returns an array containing the results of that search.\n      * @param string The String object or string literal on which to perform the search.\n      */\n    exec(string: string): RegExpExecArray | null;\n\n    /**\n      * Returns a Boolean value that indicates whether or not a pattern exists in a searched string.\n      * @param string String on which to perform the search.\n      */\n    test(string: string): boolean;\n\n    /** Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal. */\n    readonly source: string;\n\n    /** Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only. */\n    readonly global: boolean;\n\n    /** Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only. */\n    readonly ignoreCase: boolean;\n\n    /** Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only. */\n    readonly multiline: boolean;\n\n    lastIndex: number;\n\n    // Non-standard extensions\n    compile(): this;\n}\n\ninterface RegExpConstructor {\n    new(pattern: RegExp | string): RegExp;\n    new(pattern: string, flags?: string): RegExp;\n    (pattern: RegExp | string): RegExp;\n    (pattern: string, flags?: string): RegExp;\n    readonly prototype: RegExp;\n\n    // Non-standard extensions\n    $1: string;\n    $2: string;\n    $3: string;\n    $4: string;\n    $5: string;\n    $6: string;\n    $7: string;\n    $8: string;\n    $9: string;\n    lastMatch: string;\n}\n\ndeclare const RegExp: RegExpConstructor;\n\ninterface Error {\n    name: string;\n    message: string;\n    stack?: string;\n}\n\ninterface ErrorConstructor {\n    new(message?: string): Error;\n    (message?: string): Error;\n    readonly prototype: Error;\n}\n\ndeclare const Error: ErrorConstructor;\n\ninterface EvalError extends Error {\n}\n\ninterface EvalErrorConstructor {\n    new(message?: string): EvalError;\n    (message?: string): EvalError;\n    readonly prototype: EvalError;\n}\n\ndeclare const EvalError: EvalErrorConstructor;\n\ninterface RangeError extends Error {\n}\n\ninterface RangeErrorConstructor {\n    new(message?: string): RangeError;\n    (message?: string): RangeError;\n    readonly prototype: RangeError;\n}\n\ndeclare const RangeError: RangeErrorConstructor;\n\ninterface ReferenceError extends Error {\n}\n\ninterface ReferenceErrorConstructor {\n    new(message?: string): ReferenceError;\n    (message?: string): ReferenceError;\n    readonly prototype: ReferenceError;\n}\n\ndeclare const ReferenceError: ReferenceErrorConstructor;\n\ninterface SyntaxError extends Error {\n}\n\ninterface SyntaxErrorConstructor {\n    new(message?: string): SyntaxError;\n    (message?: string): SyntaxError;\n    readonly prototype: SyntaxError;\n}\n\ndeclare const SyntaxError: SyntaxErrorConstructor;\n\ninterface TypeError extends Error {\n}\n\ninterface TypeErrorConstructor {\n    new(message?: string): TypeError;\n    (message?: string): TypeError;\n    readonly prototype: TypeError;\n}\n\ndeclare const TypeError: TypeErrorConstructor;\n\ninterface URIError extends Error {\n}\n\ninterface URIErrorConstructor {\n    new(message?: string): URIError;\n    (message?: string): URIError;\n    readonly prototype: URIError;\n}\n\ndeclare const URIError: URIErrorConstructor;\n\ninterface JSON {\n    /**\n      * Converts a JavaScript Object Notation (JSON) string into an object.\n      * @param text A valid JSON string.\n      * @param reviver A function that transforms the results. This function is called for each member of the object.\n      * If a member contains nested objects, the nested objects are transformed before the parent object is.\n      */\n    parse(text: string, reviver?: (key: any, value: any) => any): any;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer A function that transforms the results.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (key: string, value: any) => any, space?: string | number): string;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer An array of strings and numbers that acts as a approved list for selecting the object properties that will be stringified.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\n}\n\n/**\n  * An intrinsic object that provides functions to convert JavaScript values to and from the JavaScript Object Notation (JSON) format.\n  */\ndeclare const JSON: JSON;\n\n\n/////////////////////////////\n/// ECMAScript Array API (specially handled by compiler)\n/////////////////////////////\n\ninterface ReadonlyArray<T> {\n    /**\n      * Gets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    readonly length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n\n    readonly [n: number]: T;\n}\n\ninterface ConcatArray<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n    join(separator?: string): string;\n    slice(start?: number, end?: number): T[];\n}\n\ninterface Array<T> {\n    /**\n      * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Removes the last element from an array and returns it.\n      */\n    pop(): T | undefined;\n    /**\n      * Appends new elements to an array, and returns the new length of the array.\n      * @param items New elements of the Array.\n      */\n    push(...items: T[]): number;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): T[];\n    /**\n      * Removes the first element from an array and returns it.\n      */\n    shift(): T | undefined;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: T, b: T) => number): this;\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      */\n    splice(start: number, deleteCount?: number): T[];\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      * @param items Elements to insert into the array in place of the deleted elements.\n      */\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    /**\n      * Inserts new elements at the start of an array.\n      * @param items  Elements to insert at the start of the Array.\n      */\n    unshift(...items: T[]): number;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    [n: number]: T;\n}\n\ninterface ArrayConstructor {\n    new(arrayLength?: number): any[];\n    new <T>(arrayLength: number): T[];\n    new <T>(...items: T[]): T[];\n    (arrayLength?: number): any[];\n    <T>(arrayLength: number): T[];\n    <T>(...items: T[]): T[];\n    isArray(arg: any): arg is Array<any>;\n    readonly prototype: Array<any>;\n}\n\ndeclare const Array: ArrayConstructor;\n\ninterface TypedPropertyDescriptor<T> {\n    enumerable?: boolean;\n    configurable?: boolean;\n    writable?: boolean;\n    value?: T;\n    get?: () => T;\n    set?: (value: T) => void;\n}\n\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n\ndeclare type PromiseConstructorLike = new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) => PromiseLike<T>;\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;\n}\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}\n\ninterface ArrayLike<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n}\n\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\n/**\n * Make all properties in T required\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n\n/**\n * Make all properties in T readonly\n */\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n/**\n * From T pick a set of properties K\n */\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n\n/**\n * Extract from T those types that are assignable to U\n */\ntype Extract<T, U> = T extends U ? T : never;\n\n/**\n * Exclude null and undefined from T\n */\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n/**\n * Obtain the parameters of a function type in a tuple\n */\ntype Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the parameters of a constructor function type in a tuple\n */\ntype ConstructorParameters<T extends new (...args: any[]) => any> = T extends new (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;\n\n/**\n * Obtain the return type of a constructor function type\n */\ntype InstanceType<T extends new (...args: any[]) => any> = T extends new (...args: any[]) => infer R ? R : any;\n\n/**\n * Marker for contextual 'this' type\n */\ninterface ThisType<T> { }\n\n/**\n  * Represents a raw buffer of binary data, which is used to store data for the\n  * different typed arrays. ArrayBuffers cannot be read from or written to directly,\n  * but can be passed to a typed array or DataView Object to interpret the raw\n  * buffer as needed.\n  */\ninterface ArrayBuffer {\n    /**\n      * Read-only. The length of the ArrayBuffer (in bytes).\n      */\n    readonly byteLength: number;\n\n    /**\n      * Returns a section of an ArrayBuffer.\n      */\n    slice(begin: number, end?: number): ArrayBuffer;\n}\n\n/**\n * Allowed ArrayBuffer types for the buffer of an ArrayBufferView and related Typed Arrays.\n */\ninterface ArrayBufferTypes {\n    ArrayBuffer: ArrayBuffer;\n}\ntype ArrayBufferLike = ArrayBufferTypes[keyof ArrayBufferTypes];\n\ninterface ArrayBufferConstructor {\n    readonly prototype: ArrayBuffer;\n    new(byteLength: number): ArrayBuffer;\n    isView(arg: any): arg is ArrayBufferView;\n}\ndeclare const ArrayBuffer: ArrayBufferConstructor;\n\ninterface ArrayBufferView {\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    byteOffset: number;\n}\n\ninterface DataView {\n    readonly buffer: ArrayBuffer;\n    readonly byteLength: number;\n    readonly byteOffset: number;\n    /**\n      * Gets the Float32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Float64 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat64(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Int8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt8(byteOffset: number): number;\n\n    /**\n      * Gets the Int16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt16(byteOffset: number, littleEndian?: boolean): number;\n    /**\n      * Gets the Int32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint8(byteOffset: number): number;\n\n    /**\n      * Gets the Uint16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint16(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Stores an Float32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Float64 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat64(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setInt8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Int16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setUint8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Uint16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint32(byteOffset: number, value: number, littleEndian?: boolean): void;\n}\n\ninterface DataViewConstructor {\n    new(buffer: ArrayBufferLike, byteOffset?: number, byteLength?: number): DataView;\n}\ndeclare const DataView: DataViewConstructor;\n\n/**\n  * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Int8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int8Array) => any, thisArg?: any): Int8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int8Array) => number, thisArg?: any): Int8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\ninterface Int8ArrayConstructor {\n    readonly prototype: Int8Array;\n    new(length: number): Int8Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int8Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int8Array;\n\n\n}\ndeclare const Int8Array: Int8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8Array) => any, thisArg?: any): Uint8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any): Uint8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ArrayConstructor {\n    readonly prototype: Uint8Array;\n    new(length: number): Uint8Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint8Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8Array;\n\n}\ndeclare const Uint8Array: Uint8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\n  * If the requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8ClampedArray {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => any, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => number, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8ClampedArray;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8ClampedArray view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    readonly prototype: Uint8ClampedArray;\n    new(length: number): Uint8ClampedArray;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint8ClampedArray;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint8ClampedArray;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8ClampedArray;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\ndeclare const Uint8ClampedArray: Uint8ClampedArrayConstructor;\n\n/**\n  * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int16Array) => any, thisArg?: any): Int16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int16Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int16Array) => number, thisArg?: any): Int16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int16ArrayConstructor {\n    readonly prototype: Int16Array;\n    new(length: number): Int16Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int16Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int16Array;\n\n\n}\ndeclare const Int16Array: Int16ArrayConstructor;\n\n/**\n  * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint16Array) => any, thisArg?: any): Uint16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint16Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint16Array) => number, thisArg?: any): Uint16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint16ArrayConstructor {\n    readonly prototype: Uint16Array;\n    new(length: number): Uint16Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint16Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint16Array;\n\n\n}\ndeclare const Uint16Array: Uint16ArrayConstructor;\n/**\n  * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int32Array) => any, thisArg?: any): Int32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int32Array) => number, thisArg?: any): Int32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int32ArrayConstructor {\n    readonly prototype: Int32Array;\n    new(length: number): Int32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int32Array;\n\n}\ndeclare const Int32Array: Int32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint32Array) => any, thisArg?: any): Uint32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint32Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint32Array) => number, thisArg?: any): Uint32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint32ArrayConstructor {\n    readonly prototype: Uint32Array;\n    new(length: number): Uint32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint32Array;\n\n}\ndeclare const Uint32Array: Uint32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\n  * of bytes could not be allocated an exception is raised.\n  */\ninterface Float32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float32Array) => any, thisArg?: any): Float32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any): Float32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float32ArrayConstructor {\n    readonly prototype: Float32Array;\n    new(length: number): Float32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Float32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Float32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float32Array;\n\n\n}\ndeclare const Float32Array: Float32ArrayConstructor;\n\n/**\n  * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Float64Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float64Array) => any, thisArg?: any): Float64Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float64Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Float64Array) => number, thisArg?: any): Float64Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float64Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float64Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float64Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float64Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float64ArrayConstructor {\n    readonly prototype: Float64Array;\n    new(length: number): Float64Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Float64Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Float64Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float64Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float64Array;\n\n}\ndeclare const Float64Array: Float64ArrayConstructor;\n\n/////////////////////////////\n/// ECMAScript Internationalization API\n/////////////////////////////\n\ndeclare namespace Intl {\n    interface CollatorOptions {\n        usage?: string;\n        localeMatcher?: string;\n        numeric?: boolean;\n        caseFirst?: string;\n        sensitivity?: string;\n        ignorePunctuation?: boolean;\n    }\n\n    interface ResolvedCollatorOptions {\n        locale: string;\n        usage: string;\n        sensitivity: string;\n        ignorePunctuation: boolean;\n        collation: string;\n        caseFirst: string;\n        numeric: boolean;\n    }\n\n    interface Collator {\n        compare(x: string, y: string): number;\n        resolvedOptions(): ResolvedCollatorOptions;\n    }\n    var Collator: {\n        new(locales?: string | string[], options?: CollatorOptions): Collator;\n        (locales?: string | string[], options?: CollatorOptions): Collator;\n        supportedLocalesOf(locales: string | string[], options?: CollatorOptions): string[];\n    };\n\n    interface NumberFormatOptions {\n        localeMatcher?: string;\n        style?: string;\n        currency?: string;\n        currencyDisplay?: string;\n        useGrouping?: boolean;\n        minimumIntegerDigits?: number;\n        minimumFractionDigits?: number;\n        maximumFractionDigits?: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n    }\n\n    interface ResolvedNumberFormatOptions {\n        locale: string;\n        numberingSystem: string;\n        style: string;\n        currency?: string;\n        currencyDisplay?: string;\n        minimumIntegerDigits: number;\n        minimumFractionDigits: number;\n        maximumFractionDigits: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n        useGrouping: boolean;\n    }\n\n    interface NumberFormat {\n        format(value: number): string;\n        resolvedOptions(): ResolvedNumberFormatOptions;\n    }\n    var NumberFormat: {\n        new(locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        (locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        supportedLocalesOf(locales: string | string[], options?: NumberFormatOptions): string[];\n    };\n\n    interface DateTimeFormatOptions {\n        localeMatcher?: string;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n        formatMatcher?: string;\n        hour12?: boolean;\n        timeZone?: string;\n    }\n\n    interface ResolvedDateTimeFormatOptions {\n        locale: string;\n        calendar: string;\n        numberingSystem: string;\n        timeZone: string;\n        hour12?: boolean;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n    }\n\n    interface DateTimeFormat {\n        format(date?: Date | number): string;\n        resolvedOptions(): ResolvedDateTimeFormatOptions;\n    }\n    var DateTimeFormat: {\n        new(locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        (locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        supportedLocalesOf(locales: string | string[], options?: DateTimeFormatOptions): string[];\n    };\n}\n\ninterface String {\n    /**\n      * Determines whether two strings are equivalent in the current or specified locale.\n      * @param that String to compare to target string\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\n      * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\n      */\n    localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;\n}\n\ninterface Number {\n    /**\n      * Converts a number to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Date {\n    /**\n      * Converts a date and time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n    /**\n      * Converts a date to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n\n    /**\n      * Converts a time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wlpn69il"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.es5.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": []
    },
    "01m4wmxj40nf": {
      "id": "01m4wmxj40nf",
      "pos": 0,
      "end": 1361,
      "text": "interface Promise<T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmxj40nf"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.es2018.promise.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": []
    },
    "01m4wns4nne7": {
      "id": "01m4wns4nne7",
      "pos": 0,
      "end": 14551,
      "text": "interface SymbolConstructor {\n    /**\n     * A method that returns the default iterator for an object. Called by the semantics of the\n     * for-of statement.\n     */\n    readonly iterator: symbol;\n}\n\ninterface IteratorResult<T> {\n    done: boolean;\n    value: T;\n}\n\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}\n\ninterface Iterable<T> {\n    [Symbol.iterator](): Iterator<T>;\n}\n\ninterface IterableIterator<T> extends Iterator<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n}\n\ninterface Array<T> {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     */\n    from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n}\n\ninterface ReadonlyArray<T> {\n    /** Iterator of values in the array. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface IArguments {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<any>;\n}\n\ninterface Map<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface ReadonlyMap<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface MapConstructor {\n    new <K, V>(iterable: Iterable<[K, V]>): Map<K, V>;\n}\n\ninterface WeakMap<K extends object, V> { }\n\ninterface WeakMapConstructor {\n    new <K extends object = object, V = any>(iterable: Iterable<[K, V]>): WeakMap<K, V>;\n}\n\ninterface Set<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ReadonlySet<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface SetConstructor {\n    new <T>(iterable: Iterable<T>): Set<T>;\n}\n\ninterface WeakSet<T extends object> { }\n\ninterface WeakSetConstructor {\n    new <T extends object = object>(iterable: Iterable<T>): WeakSet<T>;\n}\n\ninterface Promise<T> { }\n\ninterface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\n}\n\ndeclare namespace Reflect {\n    function enumerate(target: object): IterableIterator<any>;\n}\n\ninterface String {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\ninterface Int8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int8ArrayConstructor {\n    new (elements: Iterable<number>): Int8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int8Array;\n}\n\ninterface Uint8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ArrayConstructor {\n    new (elements: Iterable<number>): Uint8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8Array;\n}\n\ninterface Uint8ClampedArray {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    new (elements: Iterable<number>): Uint8ClampedArray;\n\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\n\ninterface Int16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int16ArrayConstructor {\n    new (elements: Iterable<number>): Int16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int16Array;\n}\n\ninterface Uint16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint16ArrayConstructor {\n    new (elements: Iterable<number>): Uint16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint16Array;\n}\n\ninterface Int32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int32ArrayConstructor {\n    new (elements: Iterable<number>): Int32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int32Array;\n}\n\ninterface Uint32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint32ArrayConstructor {\n    new (elements: Iterable<number>): Uint32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint32Array;\n}\n\ninterface Float32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float32ArrayConstructor {\n    new (elements: Iterable<number>): Float32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float32Array;\n}\n\ninterface Float64Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float64ArrayConstructor {\n    new (elements: Iterable<number>): Float64Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float64Array;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wns4nne7"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.es2015.iterable.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": [],
      "libReferenceDirectives": [
        {
          "name": "es2015.symbol",
          "pos": 882,
          "end": 895
        }
      ]
    },
    "01m4wmyyev1l": {
      "id": "01m4wmyyev1l",
      "pos": 0,
      "end": 19588,
      "text": "interface Array<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;\n\n    /**\n     * Returns the this object after filling the section identified by start and end with value\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: T, start?: number, end?: number): this;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an array-like object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from<T>(arrayLike: ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of<T>(...items: T[]): T[];\n}\n\ninterface DateConstructor {\n    new (value: number | string | Date): Date;\n}\n\ninterface Function {\n    /**\n     * Returns the name of the function. Function names are read-only and can not be changed.\n     */\n    readonly name: string;\n}\n\ninterface Math {\n    /**\n     * Returns the number of leading zero bits in the 32-bit binary representation of a number.\n     * @param x A numeric expression.\n     */\n    clz32(x: number): number;\n\n    /**\n     * Returns the result of 32-bit multiplication of two numbers.\n     * @param x First number\n     * @param y Second number\n     */\n    imul(x: number, y: number): number;\n\n    /**\n     * Returns the sign of the x, indicating whether x is positive, negative or zero.\n     * @param x The numeric expression to test\n     */\n    sign(x: number): number;\n\n    /**\n     * Returns the base 10 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log10(x: number): number;\n\n    /**\n     * Returns the base 2 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log2(x: number): number;\n\n    /**\n     * Returns the natural logarithm of 1 + x.\n     * @param x A numeric expression.\n     */\n    log1p(x: number): number;\n\n    /**\n     * Returns the result of (e^x - 1), which is an implementation-dependent approximation to\n     * subtracting 1 from the exponential function of x (e raised to the power of x, where e\n     * is the base of the natural logarithms).\n     * @param x A numeric expression.\n     */\n    expm1(x: number): number;\n\n    /**\n     * Returns the hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    cosh(x: number): number;\n\n    /**\n     * Returns the hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    sinh(x: number): number;\n\n    /**\n     * Returns the hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    tanh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    acosh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    asinh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    atanh(x: number): number;\n\n    /**\n     * Returns the square root of the sum of squares of its arguments.\n     * @param values Values to compute the square root for.\n     *     If no arguments are passed, the result is +0.\n     *     If there is only one argument, the result is the absolute value.\n     *     If any argument is +Infinity or -Infinity, the result is +Infinity.\n     *     If any argument is NaN, the result is NaN.\n     *     If all arguments are either +0 or −0, the result is +0.\n     */\n    hypot(...values: number[]): number;\n\n    /**\n     * Returns the integral part of the a numeric expression, x, removing any fractional digits.\n     * If x is already an integer, the result is x.\n     * @param x A numeric expression.\n     */\n    trunc(x: number): number;\n\n    /**\n     * Returns the nearest single precision float representation of a number.\n     * @param x A numeric expression.\n     */\n    fround(x: number): number;\n\n    /**\n     * Returns an implementation-dependent approximation to the cube root of number.\n     * @param x A numeric expression.\n     */\n    cbrt(x: number): number;\n}\n\ninterface NumberConstructor {\n    /**\n     * The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1\n     * that is representable as a Number value, which is approximately:\n     * 2.2204460492503130808472633361816 x 10‍−‍16.\n     */\n    readonly EPSILON: number;\n\n    /**\n     * Returns true if passed value is finite.\n     * Unlike the global isFinite, Number.isFinite doesn't forcibly convert the parameter to a\n     * number. Only finite values of the type number, result in true.\n     * @param number A numeric value.\n     */\n    isFinite(number: number): boolean;\n\n    /**\n     * Returns true if the value passed is an integer, false otherwise.\n     * @param number A numeric value.\n     */\n    isInteger(number: number): boolean;\n\n    /**\n     * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a\n     * number). Unlike the global isNaN(), Number.isNaN() doesn't forcefully convert the parameter\n     * to a number. Only values of the type number, that are also NaN, result in true.\n     * @param number A numeric value.\n     */\n    isNaN(number: number): boolean;\n\n    /**\n     * Returns true if the value passed is a safe integer.\n     * @param number A numeric value.\n     */\n    isSafeInteger(number: number): boolean;\n\n    /**\n     * The value of the largest integer n such that n and n + 1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 − 1.\n     */\n    readonly MAX_SAFE_INTEGER: number;\n\n    /**\n     * The value of the smallest integer n such that n and n − 1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MIN_SAFE_INTEGER is −9007199254740991 (−(2^53 − 1)).\n     */\n    readonly MIN_SAFE_INTEGER: number;\n\n    /**\n     * Converts a string to a floating-point number.\n     * @param string A string that contains a floating-point number.\n     */\n    parseFloat(string: string): number;\n\n    /**\n     * Converts A string to an integer.\n     * @param s A string to convert into a number.\n     * @param radix A value between 2 and 36 that specifies the base of the number in numString.\n     * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n     * All other strings are considered decimal.\n     */\n    parseInt(string: string, radix?: number): number;\n}\n\ninterface ObjectConstructor {\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source The source object from which to copy properties.\n     */\n    assign<T, U>(target: T, source: U): T & U;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     */\n    assign<T, U, V>(target: T, source1: U, source2: V): T & U & V;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     * @param source3 The third source object from which to copy properties.\n     */\n    assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param sources One or more source objects from which to copy properties\n     */\n    assign(target: object, ...sources: any[]): any;\n\n    /**\n     * Returns an array of all symbol properties found directly on object o.\n     * @param o Object to retrieve the symbols from.\n     */\n    getOwnPropertySymbols(o: any): symbol[];\n\n    /**\n     * Returns true if the values are the same value, false otherwise.\n     * @param value1 The first value.\n     * @param value2 The second value.\n     */\n    is(value1: any, value2: any): boolean;\n\n    /**\n     * Sets the prototype of a specified object o to  object proto or null. Returns the object o.\n     * @param o The object to change its prototype.\n     * @param proto The value of the new prototype or null.\n     */\n    setPrototypeOf(o: any, proto: object | null): any;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (this: void, value: T, index: number, obj: ReadonlyArray<T>) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: ReadonlyArray<T>) => boolean, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: ReadonlyArray<T>) => boolean, thisArg?: any): number;\n}\n\ninterface RegExp {\n    /**\n     * Returns a string indicating the flags of the regular expression in question. This field is read-only.\n     * The characters in this string are sequenced and concatenated in the following order:\n     *\n     *    - \"g\" for global\n     *    - \"i\" for ignoreCase\n     *    - \"m\" for multiline\n     *    - \"u\" for unicode\n     *    - \"y\" for sticky\n     *\n     * If no flags are set, the value is the empty string.\n     */\n    readonly flags: string;\n\n    /**\n     * Returns a Boolean value indicating the state of the sticky flag (y) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly sticky: boolean;\n\n    /**\n     * Returns a Boolean value indicating the state of the Unicode flag (u) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly unicode: boolean;\n}\n\ninterface RegExpConstructor {\n    new (pattern: RegExp, flags?: string): RegExp;\n    (pattern: RegExp, flags?: string): RegExp;\n}\n\ninterface String {\n    /**\n     * Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\n     * value of the UTF-16 encoded code point starting at the string element at position pos in\n     * the String resulting from converting this object to a String.\n     * If there is no element at that position, the result is undefined.\n     * If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.\n     */\n    codePointAt(pos: number): number | undefined;\n\n    /**\n     * Returns true if searchString appears as a substring of the result of converting this\n     * object to a String, at one or more positions that are\n     * greater than or equal to position; otherwise, returns false.\n     * @param searchString search string\n     * @param position If position is undefined, 0 is assumed, so as to search all of the String.\n     */\n    includes(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * endPosition – length(this). Otherwise returns false.\n     */\n    endsWith(searchString: string, endPosition?: number): boolean;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    normalize(form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\n     * is \"NFC\"\n     */\n    normalize(form?: string): string;\n\n    /**\n     * Returns a String value that is made from count copies appended together. If count is 0,\n     * the empty string is returned.\n     * @param count number of copies to append\n     */\n    repeat(count: number): string;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * position. Otherwise returns false.\n     */\n    startsWith(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns an <a> HTML anchor element and sets the name attribute to the text value\n     * @param name\n     */\n    anchor(name: string): string;\n\n    /** Returns a <big> HTML element */\n    big(): string;\n\n    /** Returns a <blink> HTML element */\n    blink(): string;\n\n    /** Returns a <b> HTML element */\n    bold(): string;\n\n    /** Returns a <tt> HTML element */\n    fixed(): string;\n\n    /** Returns a <font> HTML element and sets the color attribute value */\n    fontcolor(color: string): string;\n\n    /** Returns a <font> HTML element and sets the size attribute value */\n    fontsize(size: number): string;\n\n    /** Returns a <font> HTML element and sets the size attribute value */\n    fontsize(size: string): string;\n\n    /** Returns an <i> HTML element */\n    italics(): string;\n\n    /** Returns an <a> HTML element and sets the href attribute value */\n    link(url: string): string;\n\n    /** Returns a <small> HTML element */\n    small(): string;\n\n    /** Returns a <strike> HTML element */\n    strike(): string;\n\n    /** Returns a <sub> HTML element */\n    sub(): string;\n\n    /** Returns a <sup> HTML element */\n    sup(): string;\n}\n\ninterface StringConstructor {\n    /**\n     * Return the String value whose elements are, in order, the elements in the List elements.\n     * If length is 0, the empty string is returned.\n     */\n    fromCodePoint(...codePoints: number[]): string;\n\n    /**\n     * String.raw is intended for use as a tag function of a Tagged Template String. When called\n     * as such the first argument will be a well formed template call site object and the rest\n     * parameter will contain the substitution values.\n     * @param template A well-formed template string call site representation.\n     * @param substitutions A set of substitution values.\n     */\n    raw(template: TemplateStringsArray, ...substitutions: any[]): string;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmyyev1l"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.es2015.core.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": []
    },
    "01m4wncw7qaf": {
      "id": "01m4wncw7qaf",
      "pos": 0,
      "end": 10288,
      "text": "interface SymbolConstructor {\n    /**\n     * A method that determines if a constructor object recognizes an object as one of the\n     * constructor’s instances. Called by the semantics of the instanceof operator.\n     */\n    readonly hasInstance: symbol;\n\n    /**\n     * A Boolean value that if true indicates that an object should flatten to its array elements\n     * by Array.prototype.concat.\n     */\n    readonly isConcatSpreadable: symbol;\n\n    /**\n     * A regular expression method that matches the regular expression against a string. Called\n     * by the String.prototype.match method.\n     */\n    readonly match: symbol;\n\n    /**\n     * A regular expression method that replaces matched substrings of a string. Called by the\n     * String.prototype.replace method.\n     */\n    readonly replace: symbol;\n\n    /**\n     * A regular expression method that returns the index within a string that matches the\n     * regular expression. Called by the String.prototype.search method.\n     */\n    readonly search: symbol;\n\n    /**\n     * A function valued property that is the constructor function that is used to create\n     * derived objects.\n     */\n    readonly species: symbol;\n\n    /**\n     * A regular expression method that splits a string at the indices that match the regular\n     * expression. Called by the String.prototype.split method.\n     */\n    readonly split: symbol;\n\n    /**\n     * A method that converts an object to a corresponding primitive value.\n     * Called by the ToPrimitive abstract operation.\n     */\n    readonly toPrimitive: symbol;\n\n    /**\n     * A String value that is used in the creation of the default string description of an object.\n     * Called by the built-in method Object.prototype.toString.\n     */\n    readonly toStringTag: symbol;\n\n    /**\n     * An Object whose own property names are property names that are excluded from the 'with'\n     * environment bindings of the associated objects.\n     */\n    readonly unscopables: symbol;\n}\n\ninterface Symbol {\n    readonly [Symbol.toStringTag]: \"Symbol\";\n}\n\ninterface Array<T> {\n    /**\n     * Returns an object whose properties have the value 'true'\n     * when they will be absent when used in a 'with' statement.\n     */\n    [Symbol.unscopables](): {\n        copyWithin: boolean;\n        entries: boolean;\n        fill: boolean;\n        find: boolean;\n        findIndex: boolean;\n        keys: boolean;\n        values: boolean;\n    };\n}\n\ninterface Date {\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"default\"): string;\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: \"string\"): string;\n    /**\n     * Converts a Date object to a number.\n     */\n    [Symbol.toPrimitive](hint: \"number\"): number;\n    /**\n     * Converts a Date object to a string or number.\n     *\n     * @param hint The strings \"number\", \"string\", or \"default\" to specify what primitive to return.\n     *\n     * @throws {TypeError} If 'hint' was given something other than \"number\", \"string\", or \"default\".\n     * @returns A number if 'hint' was \"number\", a string if 'hint' was \"string\" or \"default\".\n     */\n    [Symbol.toPrimitive](hint: string): string | number;\n}\n\ninterface Map<K, V> {\n    readonly [Symbol.toStringTag]: \"Map\";\n}\n\ninterface WeakMap<K extends object, V> {\n    readonly [Symbol.toStringTag]: \"WeakMap\";\n}\n\ninterface Set<T> {\n    readonly [Symbol.toStringTag]: \"Set\";\n}\n\ninterface WeakSet<T extends object> {\n    readonly [Symbol.toStringTag]: \"WeakSet\";\n}\n\ninterface JSON {\n    readonly [Symbol.toStringTag]: \"JSON\";\n}\n\ninterface Function {\n    /**\n     * Determines whether the given value inherits from this function if this function was used\n     * as a constructor function.\n     *\n     * A constructor function can control which objects are recognized as its instances by\n     * 'instanceof' by overriding this method.\n     */\n    [Symbol.hasInstance](value: any): boolean;\n}\n\ninterface GeneratorFunction {\n    readonly [Symbol.toStringTag]: \"GeneratorFunction\";\n}\n\ninterface Math {\n    readonly [Symbol.toStringTag]: \"Math\";\n}\n\ninterface Promise<T> {\n    readonly [Symbol.toStringTag]: \"Promise\";\n}\n\ninterface PromiseConstructor {\n    readonly [Symbol.species]: PromiseConstructor;\n}\n\ninterface RegExp {\n    /**\n     * Matches a string with this regular expression, and returns an array containing the results of\n     * that search.\n     * @param string A string to search within.\n     */\n    [Symbol.match](string: string): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replaceValue A String object or string literal containing the text to replace for every\n     *                     successful match of this regular expression.\n     */\n    [Symbol.replace](string: string, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replacer A function that returns the replacement text.\n     */\n    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the position beginning first substring match in a regular expression search\n     * using this regular expression.\n     *\n     * @param string The string to search within.\n     */\n    [Symbol.search](string: string): number;\n\n    /**\n     * Returns an array of substrings that were delimited by strings in the original input that\n     * match against this regular expression.\n     *\n     * If the regular expression contains capturing parentheses, then each time this\n     * regular expression matches, the results (including any undefined results) of the\n     * capturing parentheses are spliced.\n     *\n     * @param string string value to split\n     * @param limit if not undefined, the output array is truncated so that it contains no more\n     * than 'limit' elements.\n     */\n    [Symbol.split](string: string, limit?: number): string[];\n}\n\ninterface RegExpConstructor {\n    readonly [Symbol.species]: RegExpConstructor;\n}\n\ninterface String {\n    /**\n     * Matches a string an object that supports being matched against, and returns an array containing the results of that search.\n     * @param matcher An object that supports being matched against.\n     */\n    match(matcher: { [Symbol.match](string: string): RegExpMatchArray | null; }): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replacer A function that returns the replacement text.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the first substring match in a regular expression search.\n     * @param searcher An object which supports searching within a string.\n     */\n    search(searcher: { [Symbol.search](string: string): number; }): number;\n\n    /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * @param splitter An object that can split a string.\n     * @param limit A value used to limit the number of elements returned in the array.\n     */\n    split(splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[];\n}\n\ninterface ArrayBuffer {\n    readonly [Symbol.toStringTag]: \"ArrayBuffer\";\n}\n\ninterface DataView {\n    readonly [Symbol.toStringTag]: \"DataView\";\n}\n\ninterface Int8Array {\n    readonly [Symbol.toStringTag]: \"Int8Array\";\n}\n\ninterface Uint8Array {\n    readonly [Symbol.toStringTag]: \"UInt8Array\";\n}\n\ninterface Uint8ClampedArray {\n    readonly [Symbol.toStringTag]: \"Uint8ClampedArray\";\n}\n\ninterface Int16Array {\n    readonly [Symbol.toStringTag]: \"Int16Array\";\n}\n\ninterface Uint16Array {\n    readonly [Symbol.toStringTag]: \"Uint16Array\";\n}\n\ninterface Int32Array {\n    readonly [Symbol.toStringTag]: \"Int32Array\";\n}\n\ninterface Uint32Array {\n    readonly [Symbol.toStringTag]: \"Uint32Array\";\n}\n\ninterface Float32Array {\n    readonly [Symbol.toStringTag]: \"Float32Array\";\n}\n\ninterface Float64Array {\n    readonly [Symbol.toStringTag]: \"Float64Array\";\n}\n\ninterface ArrayConstructor {\n    readonly [Symbol.species]: ArrayConstructor;\n}\ninterface MapConstructor {\n    readonly [Symbol.species]: MapConstructor;\n}\ninterface SetConstructor {\n    readonly [Symbol.species]: SetConstructor;\n}\ninterface ArrayBufferConstructor {\n    readonly [Symbol.species]: ArrayBufferConstructor;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wncw7qaf"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": [],
      "libReferenceDirectives": [
        {
          "name": "es2015.symbol",
          "pos": 882,
          "end": 895
        }
      ]
    },
    "01m4wn4ej8td": {
      "id": "01m4wn4ej8td",
      "pos": 0,
      "end": 4870,
      "text": "interface Array<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface Int8Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8ClampedArray {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int16Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint16Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float64Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}",
      "sourceFile": [
        "sourceFile",
        "01m4wn4ej8td"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.es2016.array.include.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": []
    },
    "01m4wmyc29un": {
      "id": "01m4wmyc29un",
      "pos": 0,
      "end": 7686,
      "text": "interface ReadonlyArray<T> {\n\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined> (\n        callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>,\n        thisArg?: This\n    ): U[]\n\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[][][][]> |\n\n        ReadonlyArray<ReadonlyArray<U[][][]>> |\n        ReadonlyArray<ReadonlyArray<U[][]>[]> |\n        ReadonlyArray<ReadonlyArray<U[]>[][]> |\n        ReadonlyArray<ReadonlyArray<U>[][][]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[][]>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[][]>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[][]> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>[]> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>[]> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>[]>> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[]>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>[]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>>>,\n        depth: 4): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[][][]> |\n\n        ReadonlyArray<ReadonlyArray<U>[][]> |\n        ReadonlyArray<ReadonlyArray<U[]>[]> |\n        ReadonlyArray<ReadonlyArray<U[][]>> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>> |\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>>,\n        depth: 3): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[][]> |\n\n        ReadonlyArray<ReadonlyArray<U[]>> |\n        ReadonlyArray<ReadonlyArray<U>[]> |\n\n        ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>,\n        depth: 2): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U[]> |\n        ReadonlyArray<ReadonlyArray<U>>,\n        depth?: 1\n    ): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this:\n        ReadonlyArray<U>,\n        depth: 0\n    ): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth. If no depth is provided, flat method defaults to the depth of 1.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(depth?: number): any[];\n  }\n\ninterface Array<T> {\n\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    flatMap<U, This = undefined> (\n        callback: (this: This, value: T, index: number, array: T[]) => U|ReadonlyArray<U>,\n        thisArg?: This\n    ): U[]\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][][][], depth: 7): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][][], depth: 6): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][][], depth: 5): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][][], depth: 4): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][][], depth: 3): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][][], depth: 2): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[][], depth?: 1): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(this: U[], depth: 0): U[];\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth. If no depth is provided, flat method defaults to the depth of 1.\n     *\n     * @param depth The maximum recursion depth\n     */\n    flat<U>(depth?: number): any[];\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmyc29un"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/typescript/lib/lib.esnext.array.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": []
    },
    "01m4wmbdh7dp": {
      "id": "01m4wmbdh7dp",
      "pos": 0,
      "end": 413672,
      "text": "interface Console {\n    Console: NodeJS.ConsoleConstructor;\n    /**\n     * A simple assertion test that verifies whether `value` is truthy.\n     * If it is not, an `AssertionError` is thrown.\n     * If provided, the error `message` is formatted using `util.format()` and used as the error message.\n     */\n    assert(value: any, message?: string, ...optionalParams: any[]): void;\n    /**\n     * When `stdout` is a TTY, calling `console.clear()` will attempt to clear the TTY.\n     * When `stdout` is not a TTY, this method does nothing.\n     */\n    clear(): void;\n    /**\n     * Maintains an internal counter specific to `label` and outputs to `stdout` the number of times `console.count()` has been called with the given `label`.\n     */\n    count(label?: string): void;\n    /**\n     * Resets the internal counter specific to `label`.\n     */\n    countReset(label?: string): void;\n    /**\n     * The `console.debug()` function is an alias for {@link console.log()}.\n     */\n    debug(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Uses {@link util.inspect()} on `obj` and prints the resulting string to `stdout`.\n     * This function bypasses any custom `inspect()` function defined on `obj`.\n     */\n    dir(obj: any, options?: NodeJS.InspectOptions): void;\n    /**\n     * This method calls {@link console.log()} passing it the arguments received. Please note that this method does not produce any XML formatting\n     */\n    dirxml(...data: any[]): void;\n    /**\n     * Prints to `stderr` with newline.\n     */\n    error(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Increases indentation of subsequent lines by two spaces.\n     * If one or more `label`s are provided, those are printed first without the additional indentation.\n     */\n    group(...label: any[]): void;\n    /**\n     * The `console.groupCollapsed()` function is an alias for {@link console.group()}.\n     */\n    groupCollapsed(): void;\n    /**\n     * Decreases indentation of subsequent lines by two spaces.\n     */\n    groupEnd(): void;\n    /**\n     * The {@link console.info()} function is an alias for {@link console.log()}.\n     */\n    info(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Prints to `stdout` with newline.\n     */\n    log(message?: any, ...optionalParams: any[]): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Prints to `stdout` the array `array` formatted as a table.\n     */\n    table(tabularData: any, properties?: string[]): void;\n    /**\n     * Starts a timer that can be used to compute the duration of an operation. Timers are identified by a unique `label`.\n     */\n    time(label?: string): void;\n    /**\n     * Stops a timer that was previously started by calling {@link console.time()} and prints the result to `stdout`.\n     */\n    timeEnd(label?: string): void;\n    /**\n     * For a timer that was previously started by calling {@link console.time()}, prints the elapsed time and other `data` arguments to `stdout`.\n     */\n    timeLog(label: string, ...data: any[]): void;\n    /**\n     * Prints to `stderr` the string 'Trace :', followed by the {@link util.format()} formatted message and stack trace to the current position in the code.\n     */\n    trace(message?: any, ...optionalParams: any[]): void;\n    /**\n     * The {@link console.warn()} function is an alias for {@link console.error()}.\n     */\n    warn(message?: any, ...optionalParams: any[]): void;\n\n    // --- Inspector mode only ---\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Starts a JavaScript CPU profile with an optional label.\n     */\n    profile(label?: string): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Stops the current JavaScript CPU profiling session if one has been started and prints the report to the Profiles panel of the inspector.\n     */\n    profileEnd(): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Adds an event with the label `label` to the Timeline panel of the inspector.\n     */\n    timeStamp(label?: string): void;\n}\n\ninterface Error {\n    stack?: string;\n}\n\n// Declare \"static\" methods in Error\ninterface ErrorConstructor {\n    /** Create .stack property on a target object */\n    captureStackTrace(targetObject: Object, constructorOpt?: Function): void;\n\n    /**\n     * Optional override for formatting stack traces\n     *\n     * @see https://github.com/v8/v8/wiki/Stack%20Trace%20API#customizing-stack-traces\n     */\n    prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;\n\n    stackTraceLimit: number;\n}\n\n// compat for TypeScript 1.8 and default es5 target\n// if you use with --target es3 or --target es5 and use below definitions,\n// use the lib.es6.d.ts that is bundled with TypeScript 1.8.\ninterface MapConstructor { }\ninterface WeakMapConstructor { }\ninterface SetConstructor { }\ninterface WeakSetConstructor { }\n\ninterface Set<T> {}\ninterface ReadonlySet<T> {}\n\n// Forward-declare needed types from lib.es2015.d.ts (in case users are using `--lib es5`)\ninterface Iterable<T> { }\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n}\ninterface IteratorResult<T> { }\ninterface AsyncIterableIterator<T> {}\ninterface SymbolConstructor {\n    readonly observable: symbol;\n    readonly iterator: symbol;\n    readonly asyncIterator: symbol;\n}\ndeclare var Symbol: SymbolConstructor;\ninterface SharedArrayBuffer {\n    readonly byteLength: number;\n    slice(begin?: number, end?: number): SharedArrayBuffer;\n}\n\n// Node.js ESNEXT support\ninterface String {\n    /** Removes whitespace from the left end of a string. */\n    trimLeft(): string;\n    /** Removes whitespace from the right end of a string. */\n    trimRight(): string;\n}\n\n/*-----------------------------------------------*\n *                                               *\n *                   GLOBAL                      *\n *                                               *\n ------------------------------------------------*/\ndeclare var process: NodeJS.Process;\ndeclare var global: NodeJS.Global;\ndeclare var console: Console;\n\ndeclare var __filename: string;\ndeclare var __dirname: string;\n\ndeclare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare namespace setTimeout {\n    function __promisify__(ms: number): Promise<void>;\n    function __promisify__<T>(ms: number, value: T): Promise<T>;\n}\ndeclare function clearTimeout(timeoutId: NodeJS.Timeout): void;\ndeclare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare function clearInterval(intervalId: NodeJS.Timeout): void;\ndeclare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\ndeclare namespace setImmediate {\n    function __promisify__(): Promise<void>;\n    function __promisify__<T>(value: T): Promise<T>;\n}\ndeclare function clearImmediate(immediateId: NodeJS.Immediate): void;\n\n// TODO: change to `type NodeRequireFunction = (id: string) => any;` in next mayor version.\ninterface NodeRequireFunction {\n    /* tslint:disable-next-line:callable-types */\n    (id: string): any;\n}\n\ninterface NodeRequire extends NodeRequireFunction {\n    resolve: RequireResolve;\n    cache: any;\n    extensions: NodeExtensions;\n    main: NodeModule | undefined;\n}\n\ninterface RequireResolve {\n    (id: string, options?: { paths?: string[]; }): string;\n    paths(request: string): string[] | null;\n}\n\ninterface NodeExtensions {\n    '.js': (m: NodeModule, filename: string) => any;\n    '.json': (m: NodeModule, filename: string) => any;\n    '.node': (m: NodeModule, filename: string) => any;\n    [ext: string]: (m: NodeModule, filename: string) => any;\n}\n\ndeclare var require: NodeRequire;\n\ninterface NodeModule {\n    exports: any;\n    require: NodeRequireFunction;\n    id: string;\n    filename: string;\n    loaded: boolean;\n    parent: NodeModule | null;\n    children: NodeModule[];\n    paths: string[];\n}\n\ndeclare var module: NodeModule;\n\n// Same as module.exports\ndeclare var exports: any;\ndeclare const SlowBuffer: {\n    new(str: string, encoding?: string): Buffer;\n    new(size: number): Buffer;\n    new(size: Uint8Array): Buffer;\n    new(array: any[]): Buffer;\n    prototype: Buffer;\n    isBuffer(obj: any): boolean;\n    byteLength(string: string, encoding?: string): number;\n    concat(list: Buffer[], totalLength?: number): Buffer;\n};\n\n// Buffer class\ntype BufferEncoding = \"ascii\" | \"utf8\" | \"utf16le\" | \"ucs2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\";\ninterface Buffer extends Uint8Array {\n    constructor: typeof Buffer;\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\n    toString(encoding?: string, start?: number, end?: number): string;\n    toJSON(): { type: 'Buffer', data: any[] };\n    equals(otherBuffer: Uint8Array): boolean;\n    compare(otherBuffer: Uint8Array, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\n    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n    slice(start?: number, end?: number): Buffer;\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUInt8(offset: number, noAssert?: boolean): number;\n    readUInt16LE(offset: number, noAssert?: boolean): number;\n    readUInt16BE(offset: number, noAssert?: boolean): number;\n    readUInt32LE(offset: number, noAssert?: boolean): number;\n    readUInt32BE(offset: number, noAssert?: boolean): number;\n    readInt8(offset: number, noAssert?: boolean): number;\n    readInt16LE(offset: number, noAssert?: boolean): number;\n    readInt16BE(offset: number, noAssert?: boolean): number;\n    readInt32LE(offset: number, noAssert?: boolean): number;\n    readInt32BE(offset: number, noAssert?: boolean): number;\n    readFloatLE(offset: number, noAssert?: boolean): number;\n    readFloatBE(offset: number, noAssert?: boolean): number;\n    readDoubleLE(offset: number, noAssert?: boolean): number;\n    readDoubleBE(offset: number, noAssert?: boolean): number;\n    swap16(): Buffer;\n    swap32(): Buffer;\n    swap64(): Buffer;\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\n    fill(value: any, offset?: number, end?: number): this;\n    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;\n    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;\n    entries(): IterableIterator<[number, number]>;\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\n    keys(): IterableIterator<number>;\n    values(): IterableIterator<number>;\n}\n\n/**\n * Raw data is stored in instances of the Buffer class.\n * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\n * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n */\ndeclare const Buffer: {\n    /**\n     * Allocates a new buffer containing the given {str}.\n     *\n     * @param str String to store in buffer.\n     * @param encoding encoding to use, optional.  Default is 'utf8'\n     * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.\n     */\n    new(str: string, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).\n     */\n    new(size: number): Buffer;\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    new(array: Uint8Array): Buffer;\n    /**\n     * Produces a Buffer backed by the same allocated memory as\n     * the given {ArrayBuffer}/{SharedArrayBuffer}.\n     *\n     *\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\n     * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.\n     */\n    new(arrayBuffer: ArrayBuffer | SharedArrayBuffer): Buffer;\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    new(array: any[]): Buffer;\n    /**\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\n     *\n     * @param buffer The buffer to copy.\n     * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.\n     */\n    new(buffer: Buffer): Buffer;\n    prototype: Buffer;\n    /**\n     * When passed a reference to the .buffer property of a TypedArray instance,\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\n     * The optional {byteOffset} and {length} arguments specify a memory range\n     * within the {arrayBuffer} that will be shared by the Buffer.\n     *\n     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()\n     */\n    from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param data data to create a new Buffer\n     */\n    from(data: any[]): Buffer;\n    from(data: Uint8Array): Buffer;\n    /**\n     * Creates a new Buffer containing the given JavaScript string {str}.\n     * If provided, the {encoding} parameter identifies the character encoding.\n     * If not provided, {encoding} defaults to 'utf8'.\n     */\n    from(str: string, encoding?: string): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param values to create a new Buffer\n     */\n    of(...items: number[]): Buffer;\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    isBuffer(obj: any): obj is Buffer;\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n     *\n     * @param encoding string to test.\n     */\n    isEncoding(encoding: string): boolean | undefined;\n    /**\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\n     *\n     * @param string string to test.\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\n     */\n    byteLength(string: string | NodeJS.TypedArray | DataView | ArrayBuffer | SharedArrayBuffer, encoding?: string): number;\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    concat(list: Uint8Array[], totalLength?: number): Buffer;\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    compare(buf1: Uint8Array, buf2: Uint8Array): number;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initalizing\n     */\n    alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    allocUnsafe(size: number): Buffer;\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    allocUnsafeSlow(size: number): Buffer;\n    /**\n     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.\n     */\n    poolSize: number;\n};\n\n/*----------------------------------------------*\n*                                               *\n*               GLOBAL INTERFACES               *\n*                                               *\n*-----------------------------------------------*/\ndeclare namespace NodeJS {\n    interface InspectOptions {\n        showHidden?: boolean;\n        depth?: number | null;\n        colors?: boolean;\n        customInspect?: boolean;\n        showProxy?: boolean;\n        maxArrayLength?: number | null;\n        breakLength?: number;\n        compact?: boolean;\n    }\n\n    interface ConsoleConstructor {\n        prototype: Console;\n        new(stdout: WritableStream, stderr?: WritableStream): Console;\n    }\n\n    interface CallSite {\n        /**\n         * Value of \"this\"\n         */\n        getThis(): any;\n\n        /**\n         * Type of \"this\" as a string.\n         * This is the name of the function stored in the constructor field of\n         * \"this\", if available.  Otherwise the object's [[Class]] internal\n         * property.\n         */\n        getTypeName(): string | null;\n\n        /**\n         * Current function\n         */\n        getFunction(): Function | undefined;\n\n        /**\n         * Name of the current function, typically its name property.\n         * If a name property is not available an attempt will be made to try\n         * to infer a name from the function's context.\n         */\n        getFunctionName(): string | null;\n\n        /**\n         * Name of the property [of \"this\" or one of its prototypes] that holds\n         * the current function\n         */\n        getMethodName(): string | null;\n\n        /**\n         * Name of the script [if this function was defined in a script]\n         */\n        getFileName(): string | null;\n\n        /**\n         * Current line number [if this function was defined in a script]\n         */\n        getLineNumber(): number | null;\n\n        /**\n         * Current column number [if this function was defined in a script]\n         */\n        getColumnNumber(): number | null;\n\n        /**\n         * A call site object representing the location where eval was called\n         * [if this function was created using a call to eval]\n         */\n        getEvalOrigin(): string | undefined;\n\n        /**\n         * Is this a toplevel invocation, that is, is \"this\" the global object?\n         */\n        isToplevel(): boolean;\n\n        /**\n         * Does this call take place in code defined by a call to eval?\n         */\n        isEval(): boolean;\n\n        /**\n         * Is this call in native V8 code?\n         */\n        isNative(): boolean;\n\n        /**\n         * Is this a constructor call?\n         */\n        isConstructor(): boolean;\n    }\n\n    interface ErrnoException extends Error {\n        errno?: number;\n        code?: string;\n        path?: string;\n        syscall?: string;\n        stack?: string;\n    }\n\n    class EventEmitter {\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string | symbol): this;\n        setMaxListeners(n: number): this;\n        getMaxListeners(): number;\n        listeners(event: string | symbol): Function[];\n        rawListeners(event: string | symbol): Function[];\n        emit(event: string | symbol, ...args: any[]): boolean;\n        listenerCount(type: string | symbol): number;\n        // Added in Node 6...\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        eventNames(): Array<string | symbol>;\n    }\n\n    interface ReadableStream extends EventEmitter {\n        readable: boolean;\n        read(size?: number): string | Buffer;\n        setEncoding(encoding: string): this;\n        pause(): this;\n        resume(): this;\n        isPaused(): boolean;\n        pipe<T extends WritableStream>(destination: T, options?: { end?: boolean; }): T;\n        unpipe(destination?: WritableStream): this;\n        unshift(chunk: string): void;\n        unshift(chunk: Buffer): void;\n        wrap(oldStream: ReadableStream): this;\n        [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;\n    }\n\n    interface WritableStream extends EventEmitter {\n        writable: boolean;\n        write(buffer: Buffer | string, cb?: Function): boolean;\n        write(str: string, encoding?: string, cb?: Function): boolean;\n        end(cb?: Function): void;\n        end(buffer: Buffer, cb?: Function): void;\n        end(str: string, cb?: Function): void;\n        end(str: string, encoding?: string, cb?: Function): void;\n    }\n\n    interface ReadWriteStream extends ReadableStream, WritableStream { }\n\n    interface Events extends EventEmitter { }\n\n    interface Domain extends Events {\n        run(fn: Function): void;\n        add(emitter: Events): void;\n        remove(emitter: Events): void;\n        bind(cb: (err: Error, data: any) => any): any;\n        intercept(cb: (data: any) => any): any;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        on(event: string, listener: (...args: any[]) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        removeListener(event: string, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string): this;\n    }\n\n    interface MemoryUsage {\n        rss: number;\n        heapTotal: number;\n        heapUsed: number;\n        external: number;\n    }\n\n    interface CpuUsage {\n        user: number;\n        system: number;\n    }\n\n    interface ProcessRelease {\n        name: string;\n        sourceUrl?: string;\n        headersUrl?: string;\n        libUrl?: string;\n        lts?: string;\n    }\n\n    interface ProcessVersions {\n        http_parser: string;\n        node: string;\n        v8: string;\n        ares: string;\n        uv: string;\n        zlib: string;\n        modules: string;\n        openssl: string;\n    }\n\n    type Platform = 'aix'\n        | 'android'\n        | 'darwin'\n        | 'freebsd'\n        | 'linux'\n        | 'openbsd'\n        | 'sunos'\n        | 'win32'\n        | 'cygwin';\n\n    type Signals =\n        \"SIGABRT\" | \"SIGALRM\" | \"SIGBUS\" | \"SIGCHLD\" | \"SIGCONT\" | \"SIGFPE\" | \"SIGHUP\" | \"SIGILL\" | \"SIGINT\" | \"SIGIO\" |\n        \"SIGIOT\" | \"SIGKILL\" | \"SIGPIPE\" | \"SIGPOLL\" | \"SIGPROF\" | \"SIGPWR\" | \"SIGQUIT\" | \"SIGSEGV\" | \"SIGSTKFLT\" |\n        \"SIGSTOP\" | \"SIGSYS\" | \"SIGTERM\" | \"SIGTRAP\" | \"SIGTSTP\" | \"SIGTTIN\" | \"SIGTTOU\" | \"SIGUNUSED\" | \"SIGURG\" |\n        \"SIGUSR1\" | \"SIGUSR2\" | \"SIGVTALRM\" | \"SIGWINCH\" | \"SIGXCPU\" | \"SIGXFSZ\" | \"SIGBREAK\" | \"SIGLOST\" | \"SIGINFO\";\n\n    type BeforeExitListener = (code: number) => void;\n    type DisconnectListener = () => void;\n    type ExitListener = (code: number) => void;\n    type RejectionHandledListener = (promise: Promise<any>) => void;\n    type UncaughtExceptionListener = (error: Error) => void;\n    type UnhandledRejectionListener = (reason: any, promise: Promise<any>) => void;\n    type WarningListener = (warning: Error) => void;\n    type MessageListener = (message: any, sendHandle: any) => void;\n    type SignalsListener = (signal: Signals) => void;\n    type NewListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n    type RemoveListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n\n    interface Socket extends ReadWriteStream {\n        isTTY?: true;\n    }\n\n    interface ProcessEnv {\n        [key: string]: string | undefined;\n    }\n\n    interface WriteStream extends Socket {\n        readonly writableHighWaterMark: number;\n        readonly writableLength: number;\n        columns?: number;\n        rows?: number;\n        _write(chunk: any, encoding: string, callback: Function): void;\n        _destroy(err: Error | null, callback: Function): void;\n        _final(callback: Function): void;\n        setDefaultEncoding(encoding: string): this;\n        cork(): void;\n        uncork(): void;\n        destroy(error?: Error): void;\n    }\n    interface ReadStream extends Socket {\n        readonly readableHighWaterMark: number;\n        readonly readableLength: number;\n        isRaw?: boolean;\n        setRawMode?(mode: boolean): void;\n        _read(size: number): void;\n        _destroy(err: Error | null, callback: Function): void;\n        push(chunk: any, encoding?: string): boolean;\n        destroy(error?: Error): void;\n    }\n\n    interface Process extends EventEmitter {\n        stdout: WriteStream;\n        stderr: WriteStream;\n        stdin: ReadStream;\n        openStdin(): Socket;\n        argv: string[];\n        argv0: string;\n        execArgv: string[];\n        execPath: string;\n        abort(): void;\n        chdir(directory: string): void;\n        cwd(): string;\n        debugPort: number;\n        emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\n        env: ProcessEnv;\n        exit(code?: number): never;\n        exitCode: number;\n        getgid(): number;\n        setgid(id: number | string): void;\n        getuid(): number;\n        setuid(id: number | string): void;\n        geteuid(): number;\n        seteuid(id: number | string): void;\n        getegid(): number;\n        setegid(id: number | string): void;\n        getgroups(): number[];\n        setgroups(groups: Array<string | number>): void;\n        setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;\n        hasUncaughtExceptionCaptureCallback(): boolean;\n        version: string;\n        versions: ProcessVersions;\n        config: {\n            target_defaults: {\n                cflags: any[];\n                default_configuration: string;\n                defines: string[];\n                include_dirs: string[];\n                libraries: string[];\n            };\n            variables: {\n                clang: number;\n                host_arch: string;\n                node_install_npm: boolean;\n                node_install_waf: boolean;\n                node_prefix: string;\n                node_shared_openssl: boolean;\n                node_shared_v8: boolean;\n                node_shared_zlib: boolean;\n                node_use_dtrace: boolean;\n                node_use_etw: boolean;\n                node_use_openssl: boolean;\n                target_arch: string;\n                v8_no_strict_aliasing: number;\n                v8_use_snapshot: boolean;\n                visibility: string;\n            };\n        };\n        kill(pid: number, signal?: string | number): void;\n        pid: number;\n        ppid: number;\n        title: string;\n        arch: string;\n        platform: Platform;\n        mainModule?: NodeModule;\n        memoryUsage(): MemoryUsage;\n        cpuUsage(previousValue?: CpuUsage): CpuUsage;\n        nextTick(callback: Function, ...args: any[]): void;\n        release: ProcessRelease;\n        umask(mask?: number): number;\n        uptime(): number;\n        hrtime(time?: [number, number]): [number, number];\n        domain: Domain;\n\n        // Worker\n        send?(message: any, sendHandle?: any): void;\n        disconnect(): void;\n        connected: boolean;\n\n        /**\n         * The `process.allowedNodeEnvironmentFlags` property is a special,\n         * read-only `Set` of flags allowable within the [`NODE_OPTIONS`][]\n         * environment variable.\n         */\n        allowedNodeEnvironmentFlags: ReadonlySet<string>;\n\n        /**\n         * EventEmitter\n         *   1. beforeExit\n         *   2. disconnect\n         *   3. exit\n         *   4. message\n         *   5. rejectionHandled\n         *   6. uncaughtException\n         *   7. unhandledRejection\n         *   8. warning\n         *   9. message\n         *  10. <All OS Signals>\n         *  11. newListener/removeListener inherited from EventEmitter\n         */\n        addListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        addListener(event: \"disconnect\", listener: DisconnectListener): this;\n        addListener(event: \"exit\", listener: ExitListener): this;\n        addListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        addListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        addListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        addListener(event: \"warning\", listener: WarningListener): this;\n        addListener(event: \"message\", listener: MessageListener): this;\n        addListener(event: Signals, listener: SignalsListener): this;\n        addListener(event: \"newListener\", listener: NewListenerListener): this;\n        addListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        emit(event: \"beforeExit\", code: number): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"exit\", code: number): boolean;\n        emit(event: \"rejectionHandled\", promise: Promise<any>): boolean;\n        emit(event: \"uncaughtException\", error: Error): boolean;\n        emit(event: \"unhandledRejection\", reason: any, promise: Promise<any>): boolean;\n        emit(event: \"warning\", warning: Error): boolean;\n        emit(event: \"message\", message: any, sendHandle: any): this;\n        emit(event: Signals, signal: Signals): boolean;\n        emit(event: \"newListener\", eventName: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"removeListener\", eventName: string, listener: (...args: any[]) => void): this;\n\n        on(event: \"beforeExit\", listener: BeforeExitListener): this;\n        on(event: \"disconnect\", listener: DisconnectListener): this;\n        on(event: \"exit\", listener: ExitListener): this;\n        on(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        on(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        on(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        on(event: \"warning\", listener: WarningListener): this;\n        on(event: \"message\", listener: MessageListener): this;\n        on(event: Signals, listener: SignalsListener): this;\n        on(event: \"newListener\", listener: NewListenerListener): this;\n        on(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        once(event: \"beforeExit\", listener: BeforeExitListener): this;\n        once(event: \"disconnect\", listener: DisconnectListener): this;\n        once(event: \"exit\", listener: ExitListener): this;\n        once(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        once(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        once(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        once(event: \"warning\", listener: WarningListener): this;\n        once(event: \"message\", listener: MessageListener): this;\n        once(event: Signals, listener: SignalsListener): this;\n        once(event: \"newListener\", listener: NewListenerListener): this;\n        once(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        prependListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        prependListener(event: \"disconnect\", listener: DisconnectListener): this;\n        prependListener(event: \"exit\", listener: ExitListener): this;\n        prependListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        prependListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        prependListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        prependListener(event: \"warning\", listener: WarningListener): this;\n        prependListener(event: \"message\", listener: MessageListener): this;\n        prependListener(event: Signals, listener: SignalsListener): this;\n        prependListener(event: \"newListener\", listener: NewListenerListener): this;\n        prependListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        prependOnceListener(event: \"beforeExit\", listener: BeforeExitListener): this;\n        prependOnceListener(event: \"disconnect\", listener: DisconnectListener): this;\n        prependOnceListener(event: \"exit\", listener: ExitListener): this;\n        prependOnceListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\n        prependOnceListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\n        prependOnceListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\n        prependOnceListener(event: \"warning\", listener: WarningListener): this;\n        prependOnceListener(event: \"message\", listener: MessageListener): this;\n        prependOnceListener(event: Signals, listener: SignalsListener): this;\n        prependOnceListener(event: \"newListener\", listener: NewListenerListener): this;\n        prependOnceListener(event: \"removeListener\", listener: RemoveListenerListener): this;\n\n        listeners(event: \"beforeExit\"): BeforeExitListener[];\n        listeners(event: \"disconnect\"): DisconnectListener[];\n        listeners(event: \"exit\"): ExitListener[];\n        listeners(event: \"rejectionHandled\"): RejectionHandledListener[];\n        listeners(event: \"uncaughtException\"): UncaughtExceptionListener[];\n        listeners(event: \"unhandledRejection\"): UnhandledRejectionListener[];\n        listeners(event: \"warning\"): WarningListener[];\n        listeners(event: \"message\"): MessageListener[];\n        listeners(event: Signals): SignalsListener[];\n        listeners(event: \"newListener\"): NewListenerListener[];\n        listeners(event: \"removeListener\"): RemoveListenerListener[];\n    }\n\n    interface Global {\n        Array: typeof Array;\n        ArrayBuffer: typeof ArrayBuffer;\n        Boolean: typeof Boolean;\n        Buffer: typeof Buffer;\n        DataView: typeof DataView;\n        Date: typeof Date;\n        Error: typeof Error;\n        EvalError: typeof EvalError;\n        Float32Array: typeof Float32Array;\n        Float64Array: typeof Float64Array;\n        Function: typeof Function;\n        GLOBAL: Global;\n        Infinity: typeof Infinity;\n        Int16Array: typeof Int16Array;\n        Int32Array: typeof Int32Array;\n        Int8Array: typeof Int8Array;\n        Intl: typeof Intl;\n        JSON: typeof JSON;\n        Map: MapConstructor;\n        Math: typeof Math;\n        NaN: typeof NaN;\n        Number: typeof Number;\n        Object: typeof Object;\n        Promise: Function;\n        RangeError: typeof RangeError;\n        ReferenceError: typeof ReferenceError;\n        RegExp: typeof RegExp;\n        Set: SetConstructor;\n        String: typeof String;\n        Symbol: Function;\n        SyntaxError: typeof SyntaxError;\n        TypeError: typeof TypeError;\n        URIError: typeof URIError;\n        Uint16Array: typeof Uint16Array;\n        Uint32Array: typeof Uint32Array;\n        Uint8Array: typeof Uint8Array;\n        Uint8ClampedArray: Function;\n        WeakMap: WeakMapConstructor;\n        WeakSet: WeakSetConstructor;\n        clearImmediate: (immediateId: Immediate) => void;\n        clearInterval: (intervalId: Timeout) => void;\n        clearTimeout: (timeoutId: Timeout) => void;\n        console: typeof console;\n        decodeURI: typeof decodeURI;\n        decodeURIComponent: typeof decodeURIComponent;\n        encodeURI: typeof encodeURI;\n        encodeURIComponent: typeof encodeURIComponent;\n        escape: (str: string) => string;\n        eval: typeof eval;\n        global: Global;\n        isFinite: typeof isFinite;\n        isNaN: typeof isNaN;\n        parseFloat: typeof parseFloat;\n        parseInt: typeof parseInt;\n        process: Process;\n        root: Global;\n        setImmediate: (callback: (...args: any[]) => void, ...args: any[]) => Immediate;\n        setInterval: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        setTimeout: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        undefined: typeof undefined;\n        unescape: (str: string) => string;\n        gc: () => void;\n        v8debug?: any;\n    }\n\n    interface Timer {\n        ref(): void;\n        refresh(): void;\n        unref(): void;\n    }\n\n    class Immediate {\n        ref(): void;\n        unref(): void;\n        _onImmediate: Function; // to distinguish it from the Timeout class\n    }\n\n    class Timeout implements Timer {\n        ref(): void;\n        refresh(): void;\n        unref(): void;\n    }\n\n    class Module {\n        static runMain(): void;\n        static wrap(code: string): string;\n        static builtinModules: string[];\n\n        static Module: typeof Module;\n\n        exports: any;\n        require: NodeRequireFunction;\n        id: string;\n        filename: string;\n        loaded: boolean;\n        parent: Module | null;\n        children: Module[];\n        paths: string[];\n\n        constructor(id: string, parent?: Module);\n    }\n\n    type TypedArray = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n}\n\ninterface IterableIterator<T> { }\n\n/*----------------------------------------------*\n*                                               *\n*                   MODULES                     *\n*                                               *\n*-----------------------------------------------*/\ndeclare module \"buffer\" {\n    export const INSPECT_MAX_BYTES: number;\n    const BuffType: typeof Buffer;\n    const SlowBuffType: typeof SlowBuffer;\n    export { BuffType as Buffer, SlowBuffType as SlowBuffer };\n}\n\ndeclare module \"querystring\" {\n    interface StringifyOptions {\n        encodeURIComponent?: Function;\n    }\n\n    interface ParseOptions {\n        maxKeys?: number;\n        decodeURIComponent?: Function;\n    }\n\n    interface ParsedUrlQuery { [key: string]: string | string[]; }\n\n    function stringify(obj?: {}, sep?: string, eq?: string, options?: StringifyOptions): string;\n    function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;\n    function escape(str: string): string;\n    function unescape(str: string): string;\n}\n\ndeclare module \"events\" {\n    class internal extends NodeJS.EventEmitter { }\n\n    namespace internal {\n         class EventEmitter extends internal {\n            /** @deprecated since v4.0.0 */\n            static listenerCount(emitter: EventEmitter, event: string | symbol): number;\n            static defaultMaxListeners: number;\n\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            off(event: string | symbol, listener: (...args: any[]) => void): this;\n            removeAllListeners(event?: string | symbol): this;\n            setMaxListeners(n: number): this;\n            getMaxListeners(): number;\n            listeners(event: string | symbol): Function[];\n            rawListeners(event: string | symbol): Function[];\n            emit(event: string | symbol, ...args: any[]): boolean;\n            eventNames(): Array<string | symbol>;\n            listenerCount(type: string | symbol): number;\n        }\n    }\n\n    export = internal;\n}\n\ndeclare module \"http\" {\n    import * as events from \"events\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n    import { URL } from \"url\";\n\n    // incoming headers will never contain number\n    interface IncomingHttpHeaders {\n        'accept'?: string;\n        'access-control-allow-origin'?: string;\n        'access-control-allow-credentials'?: string;\n        'access-control-expose-headers'?: string;\n        'access-control-max-age'?: string;\n        'access-control-allow-methods'?: string;\n        'access-control-allow-headers'?: string;\n        'accept-patch'?: string;\n        'accept-ranges'?: string;\n        'authorization'?: string;\n        'age'?: string;\n        'allow'?: string;\n        'alt-svc'?: string;\n        'cache-control'?: string;\n        'connection'?: string;\n        'content-disposition'?: string;\n        'content-encoding'?: string;\n        'content-language'?: string;\n        'content-length'?: string;\n        'content-location'?: string;\n        'content-range'?: string;\n        'content-type'?: string;\n        'date'?: string;\n        'expires'?: string;\n        'host'?: string;\n        'last-modified'?: string;\n        'location'?: string;\n        'pragma'?: string;\n        'proxy-authenticate'?: string;\n        'public-key-pins'?: string;\n        'referer'?: string;\n        'retry-after'?: string;\n        'set-cookie'?: string[];\n        'strict-transport-security'?: string;\n        'trailer'?: string;\n        'transfer-encoding'?: string;\n        'tk'?: string;\n        'upgrade'?: string;\n        'user-agent'?: string;\n        'vary'?: string;\n        'via'?: string;\n        'warning'?: string;\n        'www-authenticate'?: string;\n        [header: string]: string | string[] | undefined;\n    }\n\n    // outgoing headers allows numbers (as they are converted internally to strings)\n    interface OutgoingHttpHeaders {\n        [header: string]: number | string | string[] | undefined;\n    }\n\n    interface ClientRequestArgs {\n        protocol?: string;\n        host?: string;\n        hostname?: string;\n        family?: number;\n        port?: number | string;\n        defaultPort?: number | string;\n        localAddress?: string;\n        socketPath?: string;\n        method?: string;\n        path?: string;\n        headers?: OutgoingHttpHeaders;\n        auth?: string;\n        agent?: Agent | boolean;\n        _defaultAgent?: Agent;\n        timeout?: number;\n        // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L278\n        createConnection?: (options: ClientRequestArgs, oncreate: (err: Error, socket: net.Socket) => void) => net.Socket;\n    }\n\n    class Server extends net.Server {\n        constructor(requestListener?: (req: IncomingMessage, res: ServerResponse) => void);\n\n        setTimeout(msecs?: number, callback?: () => void): this;\n        setTimeout(callback: () => void): this;\n        maxHeadersCount: number;\n        timeout: number;\n        keepAliveTimeout: number;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js\n    class OutgoingMessage extends stream.Writable {\n        upgrading: boolean;\n        chunkedEncoding: boolean;\n        shouldKeepAlive: boolean;\n        useChunkedEncodingByDefault: boolean;\n        sendDate: boolean;\n        finished: boolean;\n        headersSent: boolean;\n        connection: net.Socket;\n\n        constructor();\n\n        setTimeout(msecs: number, callback?: () => void): this;\n        setHeader(name: string, value: number | string | string[]): void;\n        getHeader(name: string): number | string | string[] | undefined;\n        getHeaders(): OutgoingHttpHeaders;\n        getHeaderNames(): string[];\n        hasHeader(name: string): boolean;\n        removeHeader(name: string): void;\n        addTrailers(headers: OutgoingHttpHeaders | Array<[string, string]>): void;\n        flushHeaders(): void;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_server.js#L108-L256\n    class ServerResponse extends OutgoingMessage {\n        statusCode: number;\n        statusMessage: string;\n\n        constructor(req: IncomingMessage);\n\n        assignSocket(socket: net.Socket): void;\n        detachSocket(socket: net.Socket): void;\n        // https://github.com/nodejs/node/blob/master/test/parallel/test-http-write-callbacks.js#L53\n        // no args in writeContinue callback\n        writeContinue(callback?: () => void): void;\n        writeHead(statusCode: number, reasonPhrase?: string, headers?: OutgoingHttpHeaders): void;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L77\n    class ClientRequest extends OutgoingMessage {\n        connection: net.Socket;\n        socket: net.Socket;\n        aborted: number;\n\n        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);\n\n        abort(): void;\n        onSocket(socket: net.Socket): void;\n        setTimeout(timeout: number, callback?: () => void): this;\n        setNoDelay(noDelay?: boolean): void;\n        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;\n    }\n\n    class IncomingMessage extends stream.Readable {\n        constructor(socket: net.Socket);\n\n        httpVersion: string;\n        httpVersionMajor: number;\n        httpVersionMinor: number;\n        connection: net.Socket;\n        headers: IncomingHttpHeaders;\n        rawHeaders: string[];\n        trailers: { [key: string]: string | undefined };\n        rawTrailers: string[];\n        setTimeout(msecs: number, callback: () => void): this;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        method?: string;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        url?: string;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusCode?: number;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusMessage?: string;\n        socket: net.Socket;\n        destroy(error?: Error): void;\n    }\n\n    interface AgentOptions {\n        /**\n         * Keep sockets around in a pool to be used by other requests in the future. Default = false\n         */\n        keepAlive?: boolean;\n        /**\n         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.\n         * Only relevant if keepAlive is set to true.\n         */\n        keepAliveMsecs?: number;\n        /**\n         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity\n         */\n        maxSockets?: number;\n        /**\n         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.\n         */\n        maxFreeSockets?: number;\n        /**\n         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.\n         */\n        timeout?: number;\n    }\n\n    class Agent {\n        maxFreeSockets: number;\n        maxSockets: number;\n        sockets: any;\n        requests: any;\n\n        constructor(opts?: AgentOptions);\n\n        /**\n         * Destroy any sockets that are currently in use by the agent.\n         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,\n         * then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,\n         * sockets may hang open for quite a long time before the server terminates them.\n         */\n        destroy(): void;\n    }\n\n    const METHODS: string[];\n\n    const STATUS_CODES: {\n        [errorCode: number]: string | undefined;\n        [errorCode: string]: string | undefined;\n    };\n\n    function createServer(requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server;\n    function createClient(port?: number, host?: string): any;\n\n    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,\n    // create interface RequestOptions would make the naming more clear to developers\n    interface RequestOptions extends ClientRequestArgs { }\n    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    let globalAgent: Agent;\n}\n\ndeclare module \"cluster\" {\n    import * as child from \"child_process\";\n    import * as events from \"events\";\n    import * as net from \"net\";\n\n    // interfaces\n    interface ClusterSettings {\n        execArgv?: string[]; // default: process.execArgv\n        exec?: string;\n        args?: string[];\n        silent?: boolean;\n        stdio?: any[];\n        uid?: number;\n        gid?: number;\n        inspectPort?: number | (() => number);\n    }\n\n    interface Address {\n        address: string;\n        port: number;\n        addressType: number | \"udp4\" | \"udp6\";  // 4, 6, -1, \"udp4\", \"udp6\"\n    }\n\n    class Worker extends events.EventEmitter {\n        id: number;\n        process: child.ChildProcess;\n        suicide: boolean;\n        send(message: any, sendHandle?: any, callback?: (error: Error) => void): boolean;\n        kill(signal?: string): void;\n        destroy(signal?: string): void;\n        disconnect(): void;\n        isConnected(): boolean;\n        isDead(): boolean;\n        exitedAfterDisconnect: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. error\n         *   3. exit\n         *   4. listening\n         *   5. message\n         *   6. online\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"listening\", listener: (address: Address) => void): this;\n        addListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"exit\", code: number, signal: string): boolean;\n        emit(event: \"listening\", address: Address): boolean;\n        emit(event: \"message\", message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        on(event: \"listening\", listener: (address: Address) => void): this;\n        on(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        once(event: \"listening\", listener: (address: Address) => void): this;\n        once(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: \"online\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependOnceListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: \"online\", listener: () => void): this;\n    }\n\n    interface Cluster extends events.EventEmitter {\n        Worker: Worker;\n        disconnect(callback?: Function): void;\n        fork(env?: any): Worker;\n        isMaster: boolean;\n        isWorker: boolean;\n        // TODO: cluster.schedulingPolicy\n        settings: ClusterSettings;\n        setupMaster(settings?: ClusterSettings): void;\n        worker?: Worker;\n        workers?: {\n            [index: string]: Worker | undefined\n        };\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. exit\n         *   3. fork\n         *   4. listening\n         *   5. message\n         *   6. online\n         *   7. setup\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        addListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: (worker: Worker) => void): this;\n        addListener(event: \"setup\", listener: (settings: any) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\", worker: Worker): boolean;\n        emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\n        emit(event: \"fork\", worker: Worker): boolean;\n        emit(event: \"listening\", worker: Worker, address: Address): boolean;\n        emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\", worker: Worker): boolean;\n        emit(event: \"setup\", settings: any): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        on(event: \"fork\", listener: (worker: Worker) => void): this;\n        on(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: (worker: Worker) => void): this;\n        on(event: \"setup\", listener: (settings: any) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        once(event: \"fork\", listener: (worker: Worker) => void): this;\n        once(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: (worker: Worker) => void): this;\n        once(event: \"setup\", listener: (settings: any) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"setup\", listener: (settings: any) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;\n        prependOnceListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"setup\", listener: (settings: any) => void): this;\n    }\n\n    function disconnect(callback?: Function): void;\n    function fork(env?: any): Worker;\n    const isMaster: boolean;\n    const isWorker: boolean;\n    // TODO: cluster.schedulingPolicy\n    const settings: ClusterSettings;\n    function setupMaster(settings?: ClusterSettings): void;\n    const worker: Worker;\n    const workers: {\n        [index: string]: Worker | undefined\n    };\n\n    /**\n     * events.EventEmitter\n     *   1. disconnect\n     *   2. exit\n     *   3. fork\n     *   4. listening\n     *   5. message\n     *   6. online\n     *   7. setup\n     */\n    function addListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function addListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function addListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function addListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function emit(event: string | symbol, ...args: any[]): boolean;\n    function emit(event: \"disconnect\", worker: Worker): boolean;\n    function emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\n    function emit(event: \"fork\", worker: Worker): boolean;\n    function emit(event: \"listening\", worker: Worker, address: Address): boolean;\n    function emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n    function emit(event: \"online\", worker: Worker): boolean;\n    function emit(event: \"setup\", settings: any): boolean;\n\n    function on(event: string, listener: (...args: any[]) => void): Cluster;\n    function on(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function on(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n    function on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function on(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function on(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function once(event: string, listener: (...args: any[]) => void): Cluster;\n    function once(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function once(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n    function once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function once(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function once(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function removeListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function removeAllListeners(event?: string): Cluster;\n    function setMaxListeners(n: number): Cluster;\n    function getMaxListeners(): number;\n    function listeners(event: string): Function[];\n    function listenerCount(type: string): number;\n\n    function prependListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function prependOnceListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependOnceListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: \"setup\", listener: (settings: any) => void): Cluster;\n\n    function eventNames(): string[];\n}\n\ndeclare module \"zlib\" {\n    import * as stream from \"stream\";\n\n    interface ZlibOptions {\n        flush?: number; // default: zlib.constants.Z_NO_FLUSH\n        finishFlush?: number; // default: zlib.constants.Z_FINISH\n        chunkSize?: number; // default: 16*1024\n        windowBits?: number;\n        level?: number; // compression only\n        memLevel?: number; // compression only\n        strategy?: number; // compression only\n        dictionary?: Buffer | NodeJS.TypedArray | DataView | ArrayBuffer; // deflate/inflate only, empty dictionary by default\n    }\n\n    interface Zlib {\n        readonly bytesRead: number;\n        close(callback?: () => void): void;\n        flush(kind?: number | (() => void), callback?: () => void): void;\n    }\n\n    interface ZlibParams {\n        params(level: number, strategy: number, callback: () => void): void;\n    }\n\n    interface ZlibReset {\n        reset(): void;\n    }\n\n    interface Gzip extends stream.Transform, Zlib { }\n    interface Gunzip extends stream.Transform, Zlib { }\n    interface Deflate extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface Inflate extends stream.Transform, Zlib, ZlibReset { }\n    interface DeflateRaw extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface InflateRaw extends stream.Transform, Zlib, ZlibReset { }\n    interface Unzip extends stream.Transform, Zlib { }\n\n    function createGzip(options?: ZlibOptions): Gzip;\n    function createGunzip(options?: ZlibOptions): Gunzip;\n    function createDeflate(options?: ZlibOptions): Deflate;\n    function createInflate(options?: ZlibOptions): Inflate;\n    function createDeflateRaw(options?: ZlibOptions): DeflateRaw;\n    function createInflateRaw(options?: ZlibOptions): InflateRaw;\n    function createUnzip(options?: ZlibOptions): Unzip;\n\n    type InputType = string | Buffer | DataView | ArrayBuffer | NodeJS.TypedArray;\n    function deflate(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflate(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function deflateRaw(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateRaw(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function gzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function gzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gunzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function gunzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function gunzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflate(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflate(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflateRaw(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateRaw(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function unzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function unzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function unzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n\n    namespace constants {\n        // Allowed flush values.\n\n        const Z_NO_FLUSH: number;\n        const Z_PARTIAL_FLUSH: number;\n        const Z_SYNC_FLUSH: number;\n        const Z_FULL_FLUSH: number;\n        const Z_FINISH: number;\n        const Z_BLOCK: number;\n        const Z_TREES: number;\n\n        // Return codes for the compression/decompression functions. Negative values are errors, positive values are used for special but normal events.\n\n        const Z_OK: number;\n        const Z_STREAM_END: number;\n        const Z_NEED_DICT: number;\n        const Z_ERRNO: number;\n        const Z_STREAM_ERROR: number;\n        const Z_DATA_ERROR: number;\n        const Z_MEM_ERROR: number;\n        const Z_BUF_ERROR: number;\n        const Z_VERSION_ERROR: number;\n\n        // Compression levels.\n\n        const Z_NO_COMPRESSION: number;\n        const Z_BEST_SPEED: number;\n        const Z_BEST_COMPRESSION: number;\n        const Z_DEFAULT_COMPRESSION: number;\n\n        // Compression strategy.\n\n        const Z_FILTERED: number;\n        const Z_HUFFMAN_ONLY: number;\n        const Z_RLE: number;\n        const Z_FIXED: number;\n        const Z_DEFAULT_STRATEGY: number;\n    }\n\n    // Constants\n    const Z_NO_FLUSH: number;\n    const Z_PARTIAL_FLUSH: number;\n    const Z_SYNC_FLUSH: number;\n    const Z_FULL_FLUSH: number;\n    const Z_FINISH: number;\n    const Z_BLOCK: number;\n    const Z_TREES: number;\n    const Z_OK: number;\n    const Z_STREAM_END: number;\n    const Z_NEED_DICT: number;\n    const Z_ERRNO: number;\n    const Z_STREAM_ERROR: number;\n    const Z_DATA_ERROR: number;\n    const Z_MEM_ERROR: number;\n    const Z_BUF_ERROR: number;\n    const Z_VERSION_ERROR: number;\n    const Z_NO_COMPRESSION: number;\n    const Z_BEST_SPEED: number;\n    const Z_BEST_COMPRESSION: number;\n    const Z_DEFAULT_COMPRESSION: number;\n    const Z_FILTERED: number;\n    const Z_HUFFMAN_ONLY: number;\n    const Z_RLE: number;\n    const Z_FIXED: number;\n    const Z_DEFAULT_STRATEGY: number;\n    const Z_BINARY: number;\n    const Z_TEXT: number;\n    const Z_ASCII: number;\n    const Z_UNKNOWN: number;\n    const Z_DEFLATED: number;\n}\n\ndeclare module \"os\" {\n    interface CpuInfo {\n        model: string;\n        speed: number;\n        times: {\n            user: number;\n            nice: number;\n            sys: number;\n            idle: number;\n            irq: number;\n        };\n    }\n\n    interface NetworkInterfaceBase {\n        address: string;\n        netmask: string;\n        mac: string;\n        internal: boolean;\n        cidr: string | null;\n    }\n\n    interface NetworkInterfaceInfoIPv4 extends NetworkInterfaceBase {\n        family: \"IPv4\";\n    }\n\n    interface NetworkInterfaceInfoIPv6 extends NetworkInterfaceBase {\n        family: \"IPv6\";\n        scopeid: number;\n    }\n\n    type NetworkInterfaceInfo = NetworkInterfaceInfoIPv4 | NetworkInterfaceInfoIPv6;\n\n    function hostname(): string;\n    function loadavg(): number[];\n    function uptime(): number;\n    function freemem(): number;\n    function totalmem(): number;\n    function cpus(): CpuInfo[];\n    function type(): string;\n    function release(): string;\n    function networkInterfaces(): { [index: string]: NetworkInterfaceInfo[] };\n    function homedir(): string;\n    function userInfo(options?: { encoding: string }): { username: string, uid: number, gid: number, shell: any, homedir: string };\n    const constants: {\n        UV_UDP_REUSEADDR: number;\n        signals: {\n            SIGHUP: number;\n            SIGINT: number;\n            SIGQUIT: number;\n            SIGILL: number;\n            SIGTRAP: number;\n            SIGABRT: number;\n            SIGIOT: number;\n            SIGBUS: number;\n            SIGFPE: number;\n            SIGKILL: number;\n            SIGUSR1: number;\n            SIGSEGV: number;\n            SIGUSR2: number;\n            SIGPIPE: number;\n            SIGALRM: number;\n            SIGTERM: number;\n            SIGCHLD: number;\n            SIGSTKFLT: number;\n            SIGCONT: number;\n            SIGSTOP: number;\n            SIGTSTP: number;\n            SIGTTIN: number;\n            SIGTTOU: number;\n            SIGURG: number;\n            SIGXCPU: number;\n            SIGXFSZ: number;\n            SIGVTALRM: number;\n            SIGPROF: number;\n            SIGWINCH: number;\n            SIGIO: number;\n            SIGPOLL: number;\n            SIGPWR: number;\n            SIGSYS: number;\n            SIGUNUSED: number;\n        };\n        errno: {\n            E2BIG: number;\n            EACCES: number;\n            EADDRINUSE: number;\n            EADDRNOTAVAIL: number;\n            EAFNOSUPPORT: number;\n            EAGAIN: number;\n            EALREADY: number;\n            EBADF: number;\n            EBADMSG: number;\n            EBUSY: number;\n            ECANCELED: number;\n            ECHILD: number;\n            ECONNABORTED: number;\n            ECONNREFUSED: number;\n            ECONNRESET: number;\n            EDEADLK: number;\n            EDESTADDRREQ: number;\n            EDOM: number;\n            EDQUOT: number;\n            EEXIST: number;\n            EFAULT: number;\n            EFBIG: number;\n            EHOSTUNREACH: number;\n            EIDRM: number;\n            EILSEQ: number;\n            EINPROGRESS: number;\n            EINTR: number;\n            EINVAL: number;\n            EIO: number;\n            EISCONN: number;\n            EISDIR: number;\n            ELOOP: number;\n            EMFILE: number;\n            EMLINK: number;\n            EMSGSIZE: number;\n            EMULTIHOP: number;\n            ENAMETOOLONG: number;\n            ENETDOWN: number;\n            ENETRESET: number;\n            ENETUNREACH: number;\n            ENFILE: number;\n            ENOBUFS: number;\n            ENODATA: number;\n            ENODEV: number;\n            ENOENT: number;\n            ENOEXEC: number;\n            ENOLCK: number;\n            ENOLINK: number;\n            ENOMEM: number;\n            ENOMSG: number;\n            ENOPROTOOPT: number;\n            ENOSPC: number;\n            ENOSR: number;\n            ENOSTR: number;\n            ENOSYS: number;\n            ENOTCONN: number;\n            ENOTDIR: number;\n            ENOTEMPTY: number;\n            ENOTSOCK: number;\n            ENOTSUP: number;\n            ENOTTY: number;\n            ENXIO: number;\n            EOPNOTSUPP: number;\n            EOVERFLOW: number;\n            EPERM: number;\n            EPIPE: number;\n            EPROTO: number;\n            EPROTONOSUPPORT: number;\n            EPROTOTYPE: number;\n            ERANGE: number;\n            EROFS: number;\n            ESPIPE: number;\n            ESRCH: number;\n            ESTALE: number;\n            ETIME: number;\n            ETIMEDOUT: number;\n            ETXTBSY: number;\n            EWOULDBLOCK: number;\n            EXDEV: number;\n        };\n        priority: {\n            PRIORITY_LOW: number;\n            PRIORITY_BELOW_NORMAL: number;\n            PRIORITY_NORMAL: number;\n            PRIORITY_ABOVE_NORMAL: number;\n            PRIORITY_HIGH: number;\n            PRIORITY_HIGHEST: number;\n        }\n    };\n    function arch(): string;\n    function platform(): NodeJS.Platform;\n    function tmpdir(): string;\n    const EOL: string;\n    function endianness(): \"BE\" | \"LE\";\n    /**\n     * Gets the priority of a process.\n     * Defaults to current process.\n     */\n    function getPriority(pid?: number): number;\n    /**\n     * Sets the priority of the current process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(priority: number): void;\n    /**\n     * Sets the priority of the process specified process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(pid: number, priority: number): void;\n}\n\ndeclare module \"https\" {\n    import * as tls from \"tls\";\n    import * as events from \"events\";\n    import * as http from \"http\";\n    import { URL } from \"url\";\n\n    type ServerOptions = tls.SecureContextOptions & tls.TlsOptions;\n\n    type RequestOptions = http.RequestOptions & tls.SecureContextOptions & {\n        rejectUnauthorized?: boolean; // Defaults to true\n        servername?: string; // SNI TLS Extension\n    };\n\n    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {\n        rejectUnauthorized?: boolean;\n        maxCachedSessions?: number;\n    }\n\n    class Agent extends http.Agent {\n        constructor(options?: AgentOptions);\n        options: AgentOptions;\n    }\n\n    class Server extends tls.Server {\n        setTimeout(callback: () => void): this;\n        setTimeout(msecs?: number, callback?: () => void): this;\n        timeout: number;\n        keepAliveTimeout: number;\n    }\n\n    function createServer(options: ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): Server;\n    function request(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    let globalAgent: Agent;\n}\n\ndeclare module \"punycode\" {\n    function decode(string: string): string;\n    function encode(string: string): string;\n    function toUnicode(domain: string): string;\n    function toASCII(domain: string): string;\n    const ucs2: ucs2;\n    interface ucs2 {\n        decode(string: string): number[];\n        encode(codePoints: number[]): string;\n    }\n    const version: any;\n}\n\ndeclare module \"repl\" {\n    import * as stream from \"stream\";\n    import * as readline from \"readline\";\n\n    interface ReplOptions {\n        prompt?: string;\n        input?: NodeJS.ReadableStream;\n        output?: NodeJS.WritableStream;\n        terminal?: boolean;\n        eval?: Function;\n        useColors?: boolean;\n        useGlobal?: boolean;\n        ignoreUndefined?: boolean;\n        writer?: Function;\n        completer?: Function;\n        replMode?: any;\n        breakEvalOnSigint?: any;\n    }\n\n    interface REPLServer extends readline.ReadLine {\n        context: any;\n        inputStream: NodeJS.ReadableStream;\n        outputStream: NodeJS.WritableStream;\n\n        defineCommand(keyword: string, cmd: Function | { help: string, action: Function }): void;\n        displayPrompt(preserveCursor?: boolean): void;\n\n        /**\n         * events.EventEmitter\n         * 1. exit\n         * 2. reset\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"exit\", listener: () => void): this;\n        addListener(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"exit\"): boolean;\n        emit(event: \"reset\", context: any): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"exit\", listener: () => void): this;\n        on(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"exit\", listener: () => void): this;\n        once(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"exit\", listener: () => void): this;\n        prependListener(event: \"reset\", listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"exit\", listener: () => void): this;\n        prependOnceListener(event: \"reset\", listener: (...args: any[]) => void): this;\n    }\n\n    function start(options?: string | ReplOptions): REPLServer;\n\n    class Recoverable extends SyntaxError {\n        err: Error;\n\n        constructor(err: Error);\n    }\n}\n\ndeclare module \"readline\" {\n    import * as events from \"events\";\n    import * as stream from \"stream\";\n\n    interface Key {\n        sequence?: string;\n        name?: string;\n        ctrl?: boolean;\n        meta?: boolean;\n        shift?: boolean;\n    }\n\n    interface ReadLine extends events.EventEmitter {\n        setPrompt(prompt: string): void;\n        prompt(preserveCursor?: boolean): void;\n        question(query: string, callback: (answer: string) => void): void;\n        pause(): ReadLine;\n        resume(): ReadLine;\n        close(): void;\n        write(data: string | Buffer, key?: Key): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. line\n         * 3. pause\n         * 4. resume\n         * 5. SIGCONT\n         * 6. SIGINT\n         * 7. SIGTSTP\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"line\", listener: (input: any) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: \"SIGCONT\", listener: () => void): this;\n        addListener(event: \"SIGINT\", listener: () => void): this;\n        addListener(event: \"SIGTSTP\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"line\", input: any): boolean;\n        emit(event: \"pause\"): boolean;\n        emit(event: \"resume\"): boolean;\n        emit(event: \"SIGCONT\"): boolean;\n        emit(event: \"SIGINT\"): boolean;\n        emit(event: \"SIGTSTP\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"line\", listener: (input: any) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: \"SIGCONT\", listener: () => void): this;\n        on(event: \"SIGINT\", listener: () => void): this;\n        on(event: \"SIGTSTP\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"line\", listener: (input: any) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: \"SIGCONT\", listener: () => void): this;\n        once(event: \"SIGINT\", listener: () => void): this;\n        once(event: \"SIGTSTP\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"line\", listener: (input: any) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: \"SIGCONT\", listener: () => void): this;\n        prependListener(event: \"SIGINT\", listener: () => void): this;\n        prependListener(event: \"SIGTSTP\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"line\", listener: (input: any) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: \"SIGCONT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGINT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGTSTP\", listener: () => void): this;\n    }\n\n    type Completer = (line: string) => CompleterResult;\n    type AsyncCompleter = (line: string, callback: (err: any, result: CompleterResult) => void) => any;\n\n    type CompleterResult = [string[], string];\n\n    interface ReadLineOptions {\n        input: NodeJS.ReadableStream;\n        output?: NodeJS.WritableStream;\n        completer?: Completer | AsyncCompleter;\n        terminal?: boolean;\n        historySize?: number;\n        prompt?: string;\n        crlfDelay?: number;\n        removeHistoryDuplicates?: boolean;\n    }\n\n    function createInterface(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean): ReadLine;\n    function createInterface(options: ReadLineOptions): ReadLine;\n\n    function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number): void;\n    function emitKeypressEvents(stream: NodeJS.ReadableStream, interface?: ReadLine): void;\n    function moveCursor(stream: NodeJS.WritableStream, dx: number | string, dy: number | string): void;\n    function clearLine(stream: NodeJS.WritableStream, dir: number): void;\n    function clearScreenDown(stream: NodeJS.WritableStream): void;\n}\n\ndeclare module \"vm\" {\n    interface Context { }\n    interface BaseOptions {\n        /**\n         * Specifies the filename used in stack traces produced by this script.\n         * Default: `''`.\n         */\n        filename?: string;\n        /**\n         * Specifies the line number offset that is displayed in stack traces produced by this script.\n         * Default: `0`.\n         */\n        lineOffset?: number;\n        /**\n         * Specifies the column number offset that is displayed in stack traces produced by this script.\n         * Default: `0`\n         */\n        columnOffset?: number;\n    }\n    interface ScriptOptions extends BaseOptions {\n        displayErrors?: boolean;\n        timeout?: number;\n        cachedData?: Buffer;\n        produceCachedData?: boolean;\n    }\n    interface RunningScriptOptions extends BaseOptions {\n        displayErrors?: boolean;\n        timeout?: number;\n    }\n    interface CompileFunctionOptions extends BaseOptions {\n        /**\n         * Provides an optional data with V8's code cache data for the supplied source.\n         */\n        cachedData?: Buffer;\n        /**\n         * Specifies whether to produce new cache data.\n         * Default: `false`,\n         */\n        produceCachedData?: boolean;\n        /**\n         * The sandbox/context in which the said function should be compiled in.\n         */\n        parsingContext?: Context;\n\n        /**\n         * An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling\n         */\n        contextExtensions?: Object[];\n    }\n    class Script {\n        constructor(code: string, options?: ScriptOptions);\n        runInContext(contextifiedSandbox: Context, options?: RunningScriptOptions): any;\n        runInNewContext(sandbox?: Context, options?: RunningScriptOptions): any;\n        runInThisContext(options?: RunningScriptOptions): any;\n    }\n    function createContext(sandbox?: Context): Context;\n    function isContext(sandbox: Context): boolean;\n    function runInContext(code: string, contextifiedSandbox: Context, options?: RunningScriptOptions | string): any;\n    function runInNewContext(code: string, sandbox?: Context, options?: RunningScriptOptions | string): any;\n    function runInThisContext(code: string, options?: RunningScriptOptions | string): any;\n    function compileFunction(code: string, params: string[], options: CompileFunctionOptions): Function;\n}\n\ndeclare module \"child_process\" {\n    import * as events from \"events\";\n    import * as stream from \"stream\";\n    import * as net from \"net\";\n\n    interface ChildProcess extends events.EventEmitter {\n        stdin: stream.Writable;\n        stdout: stream.Readable;\n        stderr: stream.Readable;\n        stdio: [stream.Writable, stream.Readable, stream.Readable];\n        killed: boolean;\n        pid: number;\n        kill(signal?: string): void;\n        send(message: any, callback?: (error: Error) => void): boolean;\n        send(message: any, sendHandle?: net.Socket | net.Server, callback?: (error: Error) => void): boolean;\n        send(message: any, sendHandle?: net.Socket | net.Server, options?: MessageOptions, callback?: (error: Error) => void): boolean;\n        connected: boolean;\n        disconnect(): void;\n        unref(): void;\n        ref(): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. disconnect\n         * 3. error\n         * 4. exit\n         * 5. message\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", code: number, signal: string): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"exit\", code: number, signal: string): boolean;\n        emit(event: \"message\", message: any, sendHandle: net.Socket | net.Server): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (code: number, signal: string) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        on(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (code: number, signal: string) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        once(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n    }\n\n    interface MessageOptions {\n        keepOpen?: boolean;\n    }\n\n    type StdioOptions = \"pipe\" | \"ignore\" | \"inherit\" | Array<(\"pipe\" | \"ipc\" | \"ignore\" | \"inherit\" | stream.Stream | number | null | undefined)>;\n\n    interface SpawnOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        argv0?: string;\n        stdio?: StdioOptions;\n        detached?: boolean;\n        uid?: number;\n        gid?: number;\n        shell?: boolean | string;\n        windowsVerbatimArguments?: boolean;\n        windowsHide?: boolean;\n    }\n\n    function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): ChildProcess;\n\n    interface ExecOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        shell?: string;\n        timeout?: number;\n        maxBuffer?: number;\n        killSignal?: string;\n        uid?: number;\n        gid?: number;\n        windowsHide?: boolean;\n    }\n\n    interface ExecOptionsWithStringEncoding extends ExecOptions {\n        encoding: BufferEncoding;\n    }\n\n    interface ExecOptionsWithBufferEncoding extends ExecOptions {\n        encoding: string | null; // specify `null`.\n    }\n\n    interface ExecException extends Error {\n        cmd?: string;\n        killed?: boolean;\n        code?: number;\n        signal?: string;\n    }\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function exec(command: string, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function exec(command: string, options: { encoding: \"buffer\" | null } & ExecOptions, callback?: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: { encoding: BufferEncoding } & ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function exec(command: string, options: { encoding: string } & ExecOptions, callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function exec(\n        command: string,\n        options: ({ encoding?: string | null } & ExecOptions) | undefined | null,\n        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exec {\n        function __promisify__(command: string): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: { encoding: \"buffer\" | null } & ExecOptions): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(command: string, options: { encoding: BufferEncoding } & ExecOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: ExecOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options?: ({ encoding?: string | null } & ExecOptions) | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ExecFileOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        timeout?: number;\n        maxBuffer?: number;\n        killSignal?: string;\n        uid?: number;\n        gid?: number;\n        windowsHide?: boolean;\n        windowsVerbatimArguments?: boolean;\n    }\n    interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {\n        encoding: 'buffer' | null;\n    }\n    interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {\n        encoding: string;\n    }\n\n    function execFile(file: string): ChildProcess;\n    function execFile(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n    function execFile(file: string, args?: ReadonlyArray<string> | null): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function execFile(file: string, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function execFile(file: string, options: ExecFileOptionsWithBufferEncoding, callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithBufferEncoding,\n        callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void,\n    ): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptionsWithStringEncoding, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithStringEncoding,\n        callback: (error: Error | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function execFile(\n        file: string,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function execFile(\n        file: string,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace execFile {\n        function __promisify__(file: string): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(\n            file: string,\n            args: string[] | undefined | null,\n            options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        ): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ForkOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        execPath?: string;\n        execArgv?: string[];\n        silent?: boolean;\n        stdio?: StdioOptions;\n        windowsVerbatimArguments?: boolean;\n        uid?: number;\n        gid?: number;\n    }\n    function fork(modulePath: string, args?: ReadonlyArray<string>, options?: ForkOptions): ChildProcess;\n\n    interface SpawnSyncOptions {\n        argv0?: string; // Not specified in the docs\n        cwd?: string;\n        input?: string | Buffer | NodeJS.TypedArray | DataView;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        shell?: boolean | string;\n        windowsVerbatimArguments?: boolean;\n        windowsHide?: boolean;\n    }\n    interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    interface SpawnSyncReturns<T> {\n        pid: number;\n        output: string[];\n        stdout: T;\n        stderr: T;\n        status: number;\n        signal: string;\n        error: Error;\n    }\n    function spawnSync(command: string): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n\n    interface ExecSyncOptions {\n        cwd?: string;\n        input?: string | Buffer | Uint8Array;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        shell?: string;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        windowsHide?: boolean;\n    }\n    interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execSync(command: string): Buffer;\n    function execSync(command: string, options?: ExecSyncOptionsWithStringEncoding): string;\n    function execSync(command: string, options?: ExecSyncOptionsWithBufferEncoding): Buffer;\n    function execSync(command: string, options?: ExecSyncOptions): Buffer;\n\n    interface ExecFileSyncOptions {\n        cwd?: string;\n        input?: string | Buffer | NodeJS.TypedArray | DataView;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        windowsHide?: boolean;\n        shell?: boolean | string;\n    }\n    interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execFileSync(command: string): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptions): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptions): Buffer;\n}\n\ndeclare module \"url\" {\n    import { ParsedUrlQuery } from 'querystring';\n\n    interface UrlObjectCommon {\n        auth?: string;\n        hash?: string;\n        host?: string;\n        hostname?: string;\n        href?: string;\n        path?: string;\n        pathname?: string;\n        protocol?: string;\n        search?: string;\n        slashes?: boolean;\n    }\n\n    // Input to `url.format`\n    interface UrlObject extends UrlObjectCommon {\n        port?: string | number;\n        query?: string | null | { [key: string]: any };\n    }\n\n    // Output of `url.parse`\n    interface Url extends UrlObjectCommon {\n        port?: string;\n        query?: string | null | ParsedUrlQuery;\n    }\n\n    interface UrlWithParsedQuery extends Url {\n        query: ParsedUrlQuery;\n    }\n\n    interface UrlWithStringQuery extends Url {\n        query: string | null;\n    }\n\n    function parse(urlStr: string): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: false | undefined, slashesDenoteHost?: boolean): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: true, slashesDenoteHost?: boolean): UrlWithParsedQuery;\n    function parse(urlStr: string, parseQueryString: boolean, slashesDenoteHost?: boolean): Url;\n\n    function format(URL: URL, options?: URLFormatOptions): string;\n    function format(urlObject: UrlObject | string): string;\n    function resolve(from: string, to: string): string;\n\n    function domainToASCII(domain: string): string;\n    function domainToUnicode(domain: string): string;\n\n    interface URLFormatOptions {\n        auth?: boolean;\n        fragment?: boolean;\n        search?: boolean;\n        unicode?: boolean;\n    }\n\n    class URL {\n        constructor(input: string, base?: string | URL);\n        hash: string;\n        host: string;\n        hostname: string;\n        href: string;\n        readonly origin: string;\n        password: string;\n        pathname: string;\n        port: string;\n        protocol: string;\n        search: string;\n        readonly searchParams: URLSearchParams;\n        username: string;\n        toString(): string;\n        toJSON(): string;\n    }\n\n    class URLSearchParams implements Iterable<[string, string]> {\n        constructor(init?: URLSearchParams | string | { [key: string]: string | string[] | undefined } | Iterable<[string, string]> | Array<[string, string]>);\n        append(name: string, value: string): void;\n        delete(name: string): void;\n        entries(): IterableIterator<[string, string]>;\n        forEach(callback: (value: string, name: string, searchParams: this) => void): void;\n        get(name: string): string | null;\n        getAll(name: string): string[];\n        has(name: string): boolean;\n        keys(): IterableIterator<string>;\n        set(name: string, value: string): void;\n        sort(): void;\n        toString(): string;\n        values(): IterableIterator<string>;\n        [Symbol.iterator](): IterableIterator<[string, string]>;\n    }\n}\n\ndeclare module \"dns\" {\n    // Supported getaddrinfo flags.\n    const ADDRCONFIG: number;\n    const V4MAPPED: number;\n\n    interface LookupOptions {\n        family?: number;\n        hints?: number;\n        all?: boolean;\n        verbatim?: boolean;\n    }\n\n    interface LookupOneOptions extends LookupOptions {\n        all?: false;\n    }\n\n    interface LookupAllOptions extends LookupOptions {\n        all: true;\n    }\n\n    interface LookupAddress {\n        address: string;\n        family: number;\n    }\n\n    function lookup(hostname: string, family: number, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupAllOptions, callback: (err: NodeJS.ErrnoException, addresses: LookupAddress[]) => void): void;\n    function lookup(hostname: string, options: LookupOptions, callback: (err: NodeJS.ErrnoException, address: string | LookupAddress[], family: number) => void): void;\n    function lookup(hostname: string, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lookup {\n        function __promisify__(hostname: string, options: LookupAllOptions): Promise<{ address: LookupAddress[] }>;\n        function __promisify__(hostname: string, options?: LookupOneOptions | number): Promise<{ address: string, family: number }>;\n        function __promisify__(hostname: string, options?: LookupOptions | number): Promise<{ address: string | LookupAddress[], family?: number }>;\n    }\n\n    function lookupService(address: string, port: number, callback: (err: NodeJS.ErrnoException, hostname: string, service: string) => void): void;\n\n    namespace lookupService {\n        function __promisify__(address: string, port: number): Promise<{ hostname: string, service: string }>;\n    }\n\n    interface ResolveOptions {\n        ttl: boolean;\n    }\n\n    interface ResolveWithTtlOptions extends ResolveOptions {\n        ttl: true;\n    }\n\n    interface RecordWithTtl {\n        address: string;\n        ttl: number;\n    }\n\n    /** @deprecated Use AnyARecord or AnyAaaaRecord instead. */\n    type AnyRecordWithTtl = AnyARecord | AnyAaaaRecord;\n\n    interface AnyARecord extends RecordWithTtl {\n        type: \"A\";\n    }\n\n    interface AnyAaaaRecord extends RecordWithTtl {\n        type: \"AAAA\";\n    }\n\n    interface MxRecord {\n        priority: number;\n        exchange: string;\n    }\n\n    interface AnyMxRecord extends MxRecord {\n        type: \"MX\";\n    }\n\n    interface NaptrRecord {\n        flags: string;\n        service: string;\n        regexp: string;\n        replacement: string;\n        order: number;\n        preference: number;\n    }\n\n    interface AnyNaptrRecord extends NaptrRecord {\n        type: \"NAPTR\";\n    }\n\n    interface SoaRecord {\n        nsname: string;\n        hostmaster: string;\n        serial: number;\n        refresh: number;\n        retry: number;\n        expire: number;\n        minttl: number;\n    }\n\n    interface AnySoaRecord extends SoaRecord {\n        type: \"SOA\";\n    }\n\n    interface SrvRecord {\n        priority: number;\n        weight: number;\n        port: number;\n        name: string;\n    }\n\n    interface AnySrvRecord extends SrvRecord {\n        type: \"SRV\";\n    }\n\n    interface AnyTxtRecord {\n        type: \"TXT\";\n        entries: string[];\n    }\n\n    interface AnyNsRecord {\n        type: \"NS\";\n        value: string;\n    }\n\n    interface AnyPtrRecord {\n        type: \"PTR\";\n        value: string;\n    }\n\n    interface AnyCnameRecord {\n        type: \"CNAME\";\n        value: string;\n    }\n\n    type AnyRecord = AnyARecord |\n        AnyAaaaRecord |\n        AnyCnameRecord |\n        AnyMxRecord |\n        AnyNaptrRecord |\n        AnyNsRecord |\n        AnyPtrRecord |\n        AnySoaRecord |\n        AnySrvRecord |\n        AnyTxtRecord;\n\n    function resolve(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"A\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"AAAA\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"ANY\", callback: (err: NodeJS.ErrnoException, addresses: AnyRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"CNAME\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"MX\", callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"NAPTR\", callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"NS\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"PTR\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: \"SOA\", callback: (err: NodeJS.ErrnoException, addresses: SoaRecord) => void): void;\n    function resolve(hostname: string, rrtype: \"SRV\", callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: \"TXT\", callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\n    function resolve(\n        hostname: string,\n        rrtype: string,\n        callback: (err: NodeJS.ErrnoException, addresses: string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve {\n        function __promisify__(hostname: string, rrtype?: \"A\" | \"AAAA\" | \"CNAME\" | \"NS\" | \"PTR\"): Promise<string[]>;\n        function __promisify__(hostname: string, rrtype: \"ANY\"): Promise<AnyRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"MX\"): Promise<MxRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"NAPTR\"): Promise<NaptrRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"SOA\"): Promise<SoaRecord>;\n        function __promisify__(hostname: string, rrtype: \"SRV\"): Promise<SrvRecord[]>;\n        function __promisify__(hostname: string, rrtype: \"TXT\"): Promise<string[][]>;\n        function __promisify__(hostname: string, rrtype: string): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]>;\n    }\n\n    function resolve4(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve4(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\n    function resolve4(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve4 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolve6(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve6(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\n    function resolve6(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve6 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolveCname(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolveCname {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveMx(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\n    namespace resolveMx {\n        function __promisify__(hostname: string): Promise<MxRecord[]>;\n    }\n\n    function resolveNaptr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\n    namespace resolveNaptr {\n        function __promisify__(hostname: string): Promise<NaptrRecord[]>;\n    }\n\n    function resolveNs(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolveNs {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolvePtr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolvePtr {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveSoa(hostname: string, callback: (err: NodeJS.ErrnoException, address: SoaRecord) => void): void;\n    namespace resolveSoa {\n        function __promisify__(hostname: string): Promise<SoaRecord>;\n    }\n\n    function resolveSrv(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\n    namespace resolveSrv {\n        function __promisify__(hostname: string): Promise<SrvRecord[]>;\n    }\n\n    function resolveTxt(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\n    namespace resolveTxt {\n        function __promisify__(hostname: string): Promise<string[][]>;\n    }\n\n    function resolveAny(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: AnyRecord[]) => void): void;\n    namespace resolveAny {\n        function __promisify__(hostname: string): Promise<AnyRecord[]>;\n    }\n\n    function reverse(ip: string, callback: (err: NodeJS.ErrnoException, hostnames: string[]) => void): void;\n    function setServers(servers: string[]): void;\n    function getServers(): string[];\n\n    // Error codes\n    const NODATA: string;\n    const FORMERR: string;\n    const SERVFAIL: string;\n    const NOTFOUND: string;\n    const NOTIMP: string;\n    const REFUSED: string;\n    const BADQUERY: string;\n    const BADNAME: string;\n    const BADFAMILY: string;\n    const BADRESP: string;\n    const CONNREFUSED: string;\n    const TIMEOUT: string;\n    const EOF: string;\n    const FILE: string;\n    const NOMEM: string;\n    const DESTRUCTION: string;\n    const BADSTR: string;\n    const BADFLAGS: string;\n    const NONAME: string;\n    const BADHINTS: string;\n    const NOTINITIALIZED: string;\n    const LOADIPHLPAPI: string;\n    const ADDRGETNETWORKPARAMS: string;\n    const CANCELLED: string;\n\n    class Resolver {\n        getServers: typeof getServers;\n        setServers: typeof setServers;\n        resolve: typeof resolve;\n        resolve4: typeof resolve4;\n        resolve6: typeof resolve6;\n        resolveAny: typeof resolveAny;\n        resolveCname: typeof resolveCname;\n        resolveMx: typeof resolveMx;\n        resolveNaptr: typeof resolveNaptr;\n        resolveNs: typeof resolveNs;\n        resolvePtr: typeof resolvePtr;\n        resolveSoa: typeof resolveSoa;\n        resolveSrv: typeof resolveSrv;\n        resolveTxt: typeof resolveTxt;\n        reverse: typeof reverse;\n        cancel(): void;\n    }\n}\n\ndeclare module \"net\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import * as dns from \"dns\";\n\n    type LookupFunction = (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void) => void;\n\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface SocketConstructorOpts {\n        fd?: number;\n        allowHalfOpen?: boolean;\n        readable?: boolean;\n        writable?: boolean;\n    }\n\n    interface TcpSocketConnectOpts {\n        port: number;\n        host?: string;\n        localAddress?: string;\n        localPort?: number;\n        hints?: number;\n        family?: number;\n        lookup?: LookupFunction;\n    }\n\n    interface IpcSocketConnectOpts {\n        path: string;\n    }\n\n    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\n\n    class Socket extends stream.Duplex {\n        constructor(options?: SocketConstructorOpts);\n\n        // Extended base methods\n        write(buffer: Buffer): boolean;\n        write(buffer: Buffer, cb?: Function): boolean;\n        write(str: string, cb?: Function): boolean;\n        write(str: string, encoding?: string, cb?: Function): boolean;\n        write(str: string, encoding?: string, fd?: string): boolean;\n        write(data: any, encoding?: string, callback?: Function): void;\n\n        connect(options: SocketConnectOpts, connectionListener?: Function): this;\n        connect(port: number, host: string, connectionListener?: Function): this;\n        connect(port: number, connectionListener?: Function): this;\n        connect(path: string, connectionListener?: Function): this;\n\n        setEncoding(encoding?: string): this;\n        pause(): this;\n        resume(): this;\n        setTimeout(timeout: number, callback?: Function): this;\n        setNoDelay(noDelay?: boolean): this;\n        setKeepAlive(enable?: boolean, initialDelay?: number): this;\n        address(): AddressInfo | string;\n        unref(): void;\n        ref(): void;\n\n        readonly bufferSize: number;\n        readonly bytesRead: number;\n        readonly bytesWritten: number;\n        readonly connecting: boolean;\n        readonly destroyed: boolean;\n        readonly localAddress: string;\n        readonly localPort: number;\n        readonly remoteAddress?: string;\n        readonly remoteFamily?: string;\n        readonly remotePort?: number;\n\n        // Extended base methods\n        end(): void;\n        end(buffer: Buffer, cb?: Function): void;\n        end(str: string, cb?: Function): void;\n        end(str: string, encoding?: string, cb?: Function): void;\n        end(data?: any, encoding?: string): void;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connect\n         *   3. data\n         *   4. drain\n         *   5. end\n         *   6. error\n         *   7. lookup\n         *   8. timeout\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        addListener(event: \"connect\", listener: () => void): this;\n        addListener(event: \"data\", listener: (data: Buffer) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", had_error: boolean): boolean;\n        emit(event: \"connect\"): boolean;\n        emit(event: \"data\", data: Buffer): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"lookup\", err: Error, address: string, family: string | number, host: string): boolean;\n        emit(event: \"timeout\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (had_error: boolean) => void): this;\n        on(event: \"connect\", listener: () => void): this;\n        on(event: \"data\", listener: (data: Buffer) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (had_error: boolean) => void): this;\n        once(event: \"connect\", listener: () => void): this;\n        once(event: \"data\", listener: (data: Buffer) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        prependListener(event: \"connect\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: (had_error: boolean) => void): this;\n        prependOnceListener(event: \"connect\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n\n    interface ListenOptions {\n        port?: number;\n        host?: string;\n        backlog?: number;\n        path?: string;\n        exclusive?: boolean;\n        readableAll?: boolean;\n        writableAll?: boolean;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js\n    class Server extends events.EventEmitter {\n        constructor(connectionListener?: (socket: Socket) => void);\n        constructor(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void);\n\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: Function): this;\n        listen(port?: number, hostname?: string, listeningListener?: Function): this;\n        listen(port?: number, backlog?: number, listeningListener?: Function): this;\n        listen(port?: number, listeningListener?: Function): this;\n        listen(path: string, backlog?: number, listeningListener?: Function): this;\n        listen(path: string, listeningListener?: Function): this;\n        listen(options: ListenOptions, listeningListener?: Function): this;\n        listen(handle: any, backlog?: number, listeningListener?: Function): this;\n        listen(handle: any, listeningListener?: Function): this;\n        close(callback?: Function): this;\n        address(): AddressInfo | string;\n        getConnections(cb: (error: Error | null, count: number) => void): void;\n        ref(): this;\n        unref(): this;\n        maxConnections: number;\n        connections: number;\n        listening: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connection\n         *   3. error\n         *   4. listening\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connection\", socket: Socket): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connection\", listener: (socket: Socket) => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connection\", listener: (socket: Socket) => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n    }\n\n    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\n\n    function createServer(connectionListener?: (socket: Socket) => void): Server;\n    function createServer(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void): Server;\n    function connect(options: NetConnectOpts, connectionListener?: Function): Socket;\n    function connect(port: number, host?: string, connectionListener?: Function): Socket;\n    function connect(path: string, connectionListener?: Function): Socket;\n    function createConnection(options: NetConnectOpts, connectionListener?: Function): Socket;\n    function createConnection(port: number, host?: string, connectionListener?: Function): Socket;\n    function createConnection(path: string, connectionListener?: Function): Socket;\n    function isIP(input: string): number;\n    function isIPv4(input: string): boolean;\n    function isIPv6(input: string): boolean;\n}\n\ndeclare module \"dgram\" {\n    import { AddressInfo } from \"net\";\n    import * as dns from \"dns\";\n    import * as events from \"events\";\n\n    interface RemoteInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface BindOptions {\n        port: number;\n        address?: string;\n        exclusive?: boolean;\n    }\n\n    type SocketType = \"udp4\" | \"udp6\";\n\n    interface SocketOptions {\n        type: SocketType;\n        reuseAddr?: boolean;\n        recvBufferSize?: number;\n        sendBufferSize?: number;\n        lookup?: (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void) => void;\n    }\n\n    function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n    function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n\n    class Socket extends events.EventEmitter {\n        send(msg: Buffer | string | Uint8Array | any[], port: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: Buffer | string | Uint8Array, offset: number, length: number, port: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        bind(port?: number, address?: string, callback?: () => void): void;\n        bind(port?: number, callback?: () => void): void;\n        bind(callback?: () => void): void;\n        bind(options: BindOptions, callback?: Function): void;\n        close(callback?: () => void): void;\n        address(): AddressInfo | string;\n        setBroadcast(flag: boolean): void;\n        setTTL(ttl: number): void;\n        setMulticastTTL(ttl: number): void;\n        setMulticastInterface(multicastInterface: string): void;\n        setMulticastLoopback(flag: boolean): void;\n        addMembership(multicastAddress: string, multicastInterface?: string): void;\n        dropMembership(multicastAddress: string, multicastInterface?: string): void;\n        ref(): this;\n        unref(): this;\n        setRecvBufferSize(size: number): void;\n        setSendBufferSize(size: number): void;\n        getRecvBufferSize(): number;\n        getSendBufferSize(): number;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. error\n         * 3. listening\n         * 4. message\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n        addListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n        emit(event: \"message\", msg: Buffer, rinfo: AddressInfo): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n        on(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n        once(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n        prependListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n        prependOnceListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n    }\n}\n\ndeclare module \"fs\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import { URL } from \"url\";\n\n    /**\n     * Valid types for path values in \"fs\".\n     */\n    type PathLike = string | Buffer | URL;\n\n    type BinaryData = Buffer | DataView | NodeJS.TypedArray;\n    class Stats {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        dev: number;\n        ino: number;\n        mode: number;\n        nlink: number;\n        uid: number;\n        gid: number;\n        rdev: number;\n        size: number;\n        blksize: number;\n        blocks: number;\n        atimeMs: number;\n        mtimeMs: number;\n        ctimeMs: number;\n        birthtimeMs: number;\n        atime: Date;\n        mtime: Date;\n        ctime: Date;\n        birthtime: Date;\n    }\n\n    class Dirent {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        name: string;\n    }\n\n    interface FSWatcher extends events.EventEmitter {\n        close(): void;\n\n        /**\n         * events.EventEmitter\n         *   1. change\n         *   2. error\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n    }\n\n    class ReadStream extends stream.Readable {\n        close(): void;\n        bytesRead: number;\n        path: string | Buffer;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n    }\n\n    class WriteStream extends stream.Writable {\n        close(): void;\n        bytesWritten: number;\n        path: string | Buffer;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n    }\n\n    /**\n     * Asynchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function rename(oldPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rename {\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function renameSync(oldPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncate(path: PathLike, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function truncate(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace truncate {\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(path: PathLike, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncateSync(path: PathLike, len?: number | null): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncate(fd: number, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     */\n    function ftruncate(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace ftruncate {\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param fd A file descriptor.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(fd: number, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncateSync(fd: number, len?: number | null): void;\n\n    /**\n     * Asynchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chown {\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchown(fd: number, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchown {\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchownSync(fd: number, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchown {\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chmod {\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmod(fd: number, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchmod {\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param fd A file descriptor.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(fd: number, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmodSync(fd: number, mode: string | number): void;\n\n    /**\n     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchmod {\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function stat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace stat {\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function statSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstat(fd: number, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fstat {\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstatSync(fd: number): Stats;\n\n    /**\n     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lstat {\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstatSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function link(existingPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace link {\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function linkSync(existingPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlink(target: PathLike, path: PathLike, type: symlink.Type | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     */\n    function symlink(target: PathLike, path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace symlink {\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        type Type = \"dir\" | \"file\" | \"junction\";\n    }\n\n    /**\n     * Synchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, linkString: Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readlink {\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, resolvedPath: Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace realpath {\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        function native(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, resolvedPath: Buffer) => void): void;\n        function native(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string | Buffer) => void): void;\n        function native(path: PathLike, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n    }\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    namespace realpathSync {\n        function native(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n        function native(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n    }\n\n    /**\n     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlink(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace unlink {\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlinkSync(path: PathLike): void;\n\n    /**\n     * Asynchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rmdir {\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdirSync(path: PathLike): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(path: PathLike, mode: number | string | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function mkdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdir {\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(path: PathLike, mode?: number | string | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdirSync(path: PathLike, mode?: number | string | null): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: \"buffer\" | { encoding: \"buffer\" }, callback: (err: NodeJS.ErrnoException, folder: Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string | Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     */\n    function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdtemp {\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException, files: string[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\", callback: (err: NodeJS.ErrnoException, files: Buffer[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding?: string | null; withFileTypes?: false } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, files: string[] | Buffer[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException, files: string[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdir(path: PathLike, options: { withFileTypes: true }, callback: (err: NodeJS.ErrnoException, files: Dirent[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readdir {\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: \"buffer\" | { encoding: \"buffer\"; withFileTypes?: false }): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent\n         */\n        function __promisify__(path: PathLike, options: { withFileTypes: true }): Promise<Dirent[]>;\n    }\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): string[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): string[] | Buffer[];\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdirSync(path: PathLike, options: { withFileTypes: true }): Dirent[];\n\n    /**\n     * Asynchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function close(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace close {\n        /**\n         * Asynchronous close(2) - close a file descriptor.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function closeSync(fd: number): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace open {\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n         */\n        function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;\n    }\n\n    /**\n     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace utimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace futimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fsync {\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsyncSync(fd: number): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     */\n    function write<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     */\n    function write<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, offset: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     */\n    function write<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function write(\n        fd: number,\n        string: any,\n        position: number | undefined | null,\n        encoding: string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, str: string) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     */\n    function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace write {\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function __promisify__<TBuffer extends BinaryData>(\n            fd: number,\n            buffer?: TBuffer,\n            offset?: number,\n            length?: number,\n            position?: number | null,\n        ): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n    }\n\n    /**\n     * Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function writeSync(fd: number, buffer: BinaryData, offset?: number | null, length?: number | null, position?: number | null): number;\n\n    /**\n     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;\n\n    /**\n     * Asynchronously reads data from the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function read<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number,\n        length: number,\n        position: number | null,\n        callback?: (err: NodeJS.ErrnoException, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace read {\n        /**\n         * @param fd A file descriptor.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n         */\n        function __promisify__<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, offset: number, length: number, position: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n    }\n\n    /**\n     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function readSync(fd: number, buffer: BinaryData, offset: number, length: number, position: number | null): number;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding?: null; flag?: string; } | undefined | null, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding: string; flag?: string; } | string, callback: (err: NodeJS.ErrnoException, data: string) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(\n        path: PathLike | number,\n        options: { encoding?: string | null; flag?: string; } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, data: string | Buffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     */\n    function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readFile {\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string; } | string): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Buffer;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string; } | string): string;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): string | Buffer;\n\n    type WriteFileOptions = { encoding?: string | null; mode?: number | string; flag?: string; } | string | null;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'w'` is used.\n     */\n    function writeFile(path: PathLike | number, data: any, options: WriteFileOptions, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function writeFile(path: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace writeFile {\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'w'` is used.\n         */\n        function __promisify__(path: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'w'` is used.\n     */\n    function writeFileSync(path: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'a'` is used.\n     */\n    function appendFile(file: PathLike | number, data: any, options: WriteFileOptions, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function appendFile(file: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace appendFile {\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'a'` is used.\n         */\n        function __promisify__(file: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `'a'` is used.\n     */\n    function appendFileSync(file: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     */\n    function watchFile(filename: PathLike, options: { persistent?: boolean; interval?: number; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Stop watching for changes on `filename`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: BufferEncoding | null, persistent?: boolean, recursive?: boolean } | BufferEncoding | undefined | null,\n        listener?: (event: string, filename: string) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(filename: PathLike, options: { encoding: \"buffer\", persistent?: boolean, recursive?: boolean } | \"buffer\", listener?: (event: string, filename: Buffer) => void): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: string | null, persistent?: boolean, recursive?: boolean } | string | null,\n        listener?: (event: string, filename: string | Buffer) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;\n\n    /**\n     * Asynchronously tests whether or not the given path exists by checking with the file system.\n     * @deprecated\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function exists(path: PathLike, callback: (exists: boolean) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exists {\n        /**\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike): Promise<boolean>;\n    }\n\n    /**\n     * Synchronously tests whether or not the given path exists by checking with the file system.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function existsSync(path: PathLike): boolean;\n\n    namespace constants {\n        // File Access Constants\n\n        /** Constant for fs.access(). File is visible to the calling process. */\n        const F_OK: number;\n\n        /** Constant for fs.access(). File can be read by the calling process. */\n        const R_OK: number;\n\n        /** Constant for fs.access(). File can be written by the calling process. */\n        const W_OK: number;\n\n        /** Constant for fs.access(). File can be executed by the calling process. */\n        const X_OK: number;\n\n        // File Copy Constants\n\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\n        const COPYFILE_EXCL: number;\n\n        /**\n         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.\n         */\n        const COPYFILE_FICLONE: number;\n\n        /**\n         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.\n         */\n        const COPYFILE_FICLONE_FORCE: number;\n\n        // File Open Constants\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\n        const O_RDONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\n        const O_WRONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\n        const O_RDWR: number;\n\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\n        const O_CREAT: number;\n\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\n        const O_EXCL: number;\n\n        /**\n         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,\n         * opening the path shall not cause that terminal to become the controlling terminal for the process\n         * (if the process does not already have one).\n         */\n        const O_NOCTTY: number;\n\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\n        const O_TRUNC: number;\n\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\n        const O_APPEND: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\n        const O_DIRECTORY: number;\n\n        /**\n         * constant for fs.open().\n         * Flag indicating reading accesses to the file system will no longer result in\n         * an update to the atime information associated with the file.\n         * This flag is available on Linux operating systems only.\n         */\n        const O_NOATIME: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\n        const O_NOFOLLOW: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\n        const O_SYNC: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\n        const O_DSYNC: number;\n\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\n        const O_SYMLINK: number;\n\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\n        const O_DIRECT: number;\n\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\n        const O_NONBLOCK: number;\n\n        // File Type Constants\n\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\n        const S_IFMT: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\n        const S_IFREG: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\n        const S_IFDIR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\n        const S_IFCHR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\n        const S_IFBLK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\n        const S_IFIFO: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\n        const S_IFLNK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\n        const S_IFSOCK: number;\n\n        // File Mode Constants\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\n        const S_IRWXU: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\n        const S_IRUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\n        const S_IWUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\n        const S_IXUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\n        const S_IRWXG: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\n        const S_IRGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\n        const S_IWGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\n        const S_IXGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\n        const S_IRWXO: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\n        const S_IROTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\n        const S_IWOTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\n        const S_IXOTH: number;\n    }\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, mode: number | undefined, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace access {\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike, mode?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function accessSync(path: PathLike, mode?: number): void;\n\n    /**\n     * Returns a new `ReadStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createReadStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        start?: number;\n        end?: number;\n        highWaterMark?: number;\n    }): ReadStream;\n\n    /**\n     * Returns a new `WriteStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createWriteStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        start?: number;\n    }): WriteStream;\n\n    /**\n     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fdatasync {\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasyncSync(fd: number): void;\n\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     */\n    function copyFile(src: PathLike, dest: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFile(src: PathLike, dest: PathLike, flags: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace copyFile {\n        /**\n         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n         * No arguments other than a possible exception are given to the callback function.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation.\n         * The only supported flag is fs.constants.COPYFILE_EXCL,\n         * which causes the copy operation to fail if dest already exists.\n         */\n        function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An optional integer that specifies the behavior of the copy operation.\n     * The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;\n\n    namespace promises {\n        interface FileHandle {\n            /**\n             * Gets the file descriptor for this file handle.\n             */\n            readonly fd: number;\n\n            /**\n             * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for appending.\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `'utf8'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `'a'` is used.\n             */\n            appendFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous fchown(2) - Change ownership of a file.\n             */\n            chown(uid: number, gid: number): Promise<void>;\n\n            /**\n             * Asynchronous fchmod(2) - Change permissions of a file.\n             * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n             */\n            chmod(mode: string | number): Promise<void>;\n\n            /**\n             * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n             */\n            datasync(): Promise<void>;\n\n            /**\n             * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n             */\n            sync(): Promise<void>;\n\n            /**\n             * Asynchronously reads data from the file.\n             * The `FileHandle` must have been opened for reading.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The offset in the buffer at which to start writing.\n             * @param length The number of bytes to read.\n             * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n             */\n            read<TBuffer extends Buffer | Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `'r'`.\n             */\n            readFile(options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n            /**\n             * Asynchronous fstat(2) - Get file status.\n             */\n            stat(): Promise<Stats>;\n\n            /**\n             * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n             * @param len If not specified, defaults to `0`.\n             */\n            truncate(len?: number): Promise<void>;\n\n            /**\n             * Asynchronously change file timestamps of the file.\n             * @param atime The last access time. If a string is provided, it will be coerced to number.\n             * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n             */\n            utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n            /**\n             * Asynchronously writes `buffer` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n             * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             */\n            write<TBuffer extends Buffer | Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously writes `string` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`\n             * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n             * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             * @param encoding The expected string encoding.\n             */\n            write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n            /**\n             * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `'utf8'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `'w'` is used.\n             */\n            writeFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous close(2) - close a `FileHandle`.\n             */\n            close(): Promise<void>;\n        }\n\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function access(path: PathLike, mode?: number): Promise<void>;\n\n        /**\n         * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it already exists.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation. The only\n         * supported flag is `fs.constants.COPYFILE_EXCL`, which causes the copy operation to fail if\n         * `dest` already exists.\n         */\n        function copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;\n\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not\n         * supplied, defaults to `0o666`.\n         */\n        function open(path: PathLike, flags: string | number, mode?: string | number): Promise<FileHandle>;\n\n        /**\n         * Asynchronously reads data from the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If\n         * `null`, data will be read from the current position.\n         */\n        function read<TBuffer extends Buffer | Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function write<TBuffer extends Buffer | Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function write(handle: FileHandle, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function truncate(path: PathLike, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param handle A `FileHandle`.\n         * @param len If not specified, defaults to `0`.\n         */\n        function ftruncate(handle: FileHandle, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function rmdir(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fdatasync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fsync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function mkdir(path: PathLike, mode?: string | number): Promise<void>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param handle A `FileHandle`.\n         */\n        function fstat(handle: FileHandle): Promise<Stats>;\n\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lstat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function stat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function unlink(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param handle A `FileHandle`.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function fchmod(handle: FileHandle, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function chmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function lchmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lchown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param handle A `FileHandle`.\n         */\n        function fchown(handle: FileHandle, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function chown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function futimes(handle: FileHandle, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * It is unsafe to call `fsPromises.writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'w'` is used.\n         */\n        function writeFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'a'` is used.\n         */\n        function appendFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n    }\n}\n\ndeclare module \"path\" {\n    /**\n     * A parsed path object generated by path.parse() or consumed by path.format().\n     */\n    interface ParsedPath {\n        /**\n         * The root of the path such as '/' or 'c:\\'\n         */\n        root: string;\n        /**\n         * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n         */\n        dir: string;\n        /**\n         * The file name including extension (if any) such as 'index.html'\n         */\n        base: string;\n        /**\n         * The file extension (if any) such as '.html'\n         */\n        ext: string;\n        /**\n         * The file name without extension (if any) such as 'index'\n         */\n        name: string;\n    }\n    interface FormatInputPathObject {\n        /**\n         * The root of the path such as '/' or 'c:\\'\n         */\n        root?: string;\n        /**\n         * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n         */\n        dir?: string;\n        /**\n         * The file name including extension (if any) such as 'index.html'\n         */\n        base?: string;\n        /**\n         * The file extension (if any) such as '.html'\n         */\n        ext?: string;\n        /**\n         * The file name without extension (if any) such as 'index'\n         */\n        name?: string;\n    }\n\n    /**\n     * Normalize a string path, reducing '..' and '.' parts.\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n     *\n     * @param p string path to normalize.\n     */\n    function normalize(p: string): string;\n    /**\n     * Join all arguments together and normalize the resulting path.\n     * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.\n     *\n     * @param paths paths to join.\n     */\n    function join(...paths: string[]): string;\n    /**\n     * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.\n     *\n     * Starting from leftmost {from} paramter, resolves {to} to an absolute path.\n     *\n     * If {to} isn't already absolute, {from} arguments are prepended in right to left order,\n     * until an absolute path is found. If after using all {from} paths still no absolute path is found,\n     * the current working directory is used as well. The resulting path is normalized,\n     * and trailing slashes are removed unless the path gets resolved to the root directory.\n     *\n     * @param pathSegments string paths to join.  Non-string arguments are ignored.\n     */\n    function resolve(...pathSegments: string[]): string;\n    /**\n     * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\n     *\n     * @param path path to test.\n     */\n    function isAbsolute(path: string): boolean;\n    /**\n     * Solve the relative path from {from} to {to}.\n     * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\n     */\n    function relative(from: string, to: string): string;\n    /**\n     * Return the directory name of a path. Similar to the Unix dirname command.\n     *\n     * @param p the path to evaluate.\n     */\n    function dirname(p: string): string;\n    /**\n     * Return the last portion of a path. Similar to the Unix basename command.\n     * Often used to extract the file name from a fully qualified path.\n     *\n     * @param p the path to evaluate.\n     * @param ext optionally, an extension to remove from the result.\n     */\n    function basename(p: string, ext?: string): string;\n    /**\n     * Return the extension of the path, from the last '.' to end of string in the last portion of the path.\n     * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string\n     *\n     * @param p the path to evaluate.\n     */\n    function extname(p: string): string;\n    /**\n     * The platform-specific file separator. '\\\\' or '/'.\n     */\n    const sep: '\\\\' | '/';\n    /**\n     * The platform-specific file delimiter. ';' or ':'.\n     */\n    const delimiter: ';' | ':';\n    /**\n     * Returns an object from a path string - the opposite of format().\n     *\n     * @param pathString path to evaluate.\n     */\n    function parse(pathString: string): ParsedPath;\n    /**\n     * Returns a path string from an object - the opposite of parse().\n     *\n     * @param pathString path to evaluate.\n     */\n    function format(pathObject: FormatInputPathObject): string;\n\n    namespace posix {\n        function normalize(p: string): string;\n        function join(...paths: any[]): string;\n        function resolve(...pathSegments: any[]): string;\n        function isAbsolute(p: string): boolean;\n        function relative(from: string, to: string): string;\n        function dirname(p: string): string;\n        function basename(p: string, ext?: string): string;\n        function extname(p: string): string;\n        const sep: string;\n        const delimiter: string;\n        function parse(p: string): ParsedPath;\n        function format(pP: FormatInputPathObject): string;\n    }\n\n    namespace win32 {\n        function normalize(p: string): string;\n        function join(...paths: any[]): string;\n        function resolve(...pathSegments: any[]): string;\n        function isAbsolute(p: string): boolean;\n        function relative(from: string, to: string): string;\n        function dirname(p: string): string;\n        function basename(p: string, ext?: string): string;\n        function extname(p: string): string;\n        const sep: string;\n        const delimiter: string;\n        function parse(p: string): ParsedPath;\n        function format(pP: FormatInputPathObject): string;\n    }\n}\n\ndeclare module \"string_decoder\" {\n    interface NodeStringDecoder {\n        write(buffer: Buffer): string;\n        end(buffer?: Buffer): string;\n    }\n    const StringDecoder: {\n        new(encoding?: string): NodeStringDecoder;\n    };\n}\n\ndeclare module \"tls\" {\n    import * as crypto from \"crypto\";\n    import * as dns from \"dns\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n\n    const CLIENT_RENEG_LIMIT: number;\n    const CLIENT_RENEG_WINDOW: number;\n\n    interface Certificate {\n        /**\n         * Country code.\n         */\n        C: string;\n        /**\n         * Street.\n         */\n        ST: string;\n        /**\n         * Locality.\n         */\n        L: string;\n        /**\n         * Organization.\n         */\n        O: string;\n        /**\n         * Organizational unit.\n         */\n        OU: string;\n        /**\n         * Common name.\n         */\n        CN: string;\n    }\n\n    interface PeerCertificate {\n        subject: Certificate;\n        issuer: Certificate;\n        subjectaltname: string;\n        infoAccess: { [index: string]: string[] | undefined };\n        modulus: string;\n        exponent: string;\n        valid_from: string;\n        valid_to: string;\n        fingerprint: string;\n        ext_key_usage: string[];\n        serialNumber: string;\n        raw: Buffer;\n    }\n\n    interface DetailedPeerCertificate extends PeerCertificate {\n        issuerCertificate: DetailedPeerCertificate;\n    }\n\n    interface CipherNameAndProtocol {\n        /**\n         * The cipher name.\n         */\n        name: string;\n        /**\n         * SSL/TLS protocol version.\n         */\n        version: string;\n    }\n\n    class TLSSocket extends net.Socket {\n        /**\n         * Construct a new tls.TLSSocket object from an existing TCP socket.\n         */\n        constructor(socket: net.Socket, options?: {\n            /**\n             * An optional TLS context object from tls.createSecureContext()\n             */\n            secureContext?: SecureContext,\n            /**\n             * If true the TLS socket will be instantiated in server-mode.\n             * Defaults to false.\n             */\n            isServer?: boolean,\n            /**\n             * An optional net.Server instance.\n             */\n            server?: net.Server,\n            /**\n             * If true the server will request a certificate from clients that\n             * connect and attempt to verify that certificate. Defaults to\n             * false.\n             */\n            requestCert?: boolean,\n            /**\n             * If true the server will reject any connection which is not\n             * authorized with the list of supplied CAs. This option only has an\n             * effect if requestCert is true. Defaults to false.\n             */\n            rejectUnauthorized?: boolean,\n            /**\n             * An array of strings or a Buffer naming possible NPN protocols.\n             * (Protocols should be ordered by their priority.)\n             */\n            NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array,\n            /**\n             * An array of strings or a Buffer naming possible ALPN protocols.\n             * (Protocols should be ordered by their priority.) When the server\n             * receives both NPN and ALPN extensions from the client, ALPN takes\n             * precedence over NPN and the server does not send an NPN extension\n             * to the client.\n             */\n            ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array,\n            /**\n             * SNICallback(servername, cb) <Function> A function that will be\n             * called if the client supports SNI TLS extension. Two arguments\n             * will be passed when called: servername and cb. SNICallback should\n             * invoke cb(null, ctx), where ctx is a SecureContext instance.\n             * (tls.createSecureContext(...) can be used to get a proper\n             * SecureContext.) If SNICallback wasn't provided the default callback\n             * with high-level API will be used (see below).\n             */\n            SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void,\n            /**\n             * An optional Buffer instance containing a TLS session.\n             */\n            session?: Buffer,\n            /**\n             * If true, specifies that the OCSP status request extension will be\n             * added to the client hello and an 'OCSPResponse' event will be\n             * emitted on the socket before establishing a secure communication\n             */\n            requestOCSP?: boolean\n        });\n\n        /**\n         * A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false.\n         */\n        authorized: boolean;\n        /**\n         * The reason why the peer's certificate has not been verified.\n         * This property becomes available only when tlsSocket.authorized === false.\n         */\n        authorizationError: Error;\n        /**\n         * Static boolean value, always true.\n         * May be used to distinguish TLS sockets from regular ones.\n         */\n        encrypted: boolean;\n        /**\n         * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.\n         * @returns Returns an object representing the cipher name\n         * and the SSL/TLS protocol version of the current connection.\n         */\n        getCipher(): CipherNameAndProtocol;\n        /**\n         * Returns an object representing the peer's certificate.\n         * The returned object has some properties corresponding to the field of the certificate.\n         * If detailed argument is true the full chain with issuer property will be returned,\n         * if false only the top certificate without issuer property.\n         * If the peer does not provide a certificate, it returns null or an empty object.\n         * @param detailed - If true; the full chain with issuer property will be returned.\n         * @returns An object representing the peer's certificate.\n         */\n        getPeerCertificate(detailed: true): DetailedPeerCertificate;\n        getPeerCertificate(detailed?: false): PeerCertificate;\n        getPeerCertificate(detailed?: boolean): PeerCertificate | DetailedPeerCertificate;\n        /**\n         * Returns a string containing the negotiated SSL/TLS protocol version of the current connection.\n         * The value `'unknown'` will be returned for connected sockets that have not completed the handshaking process.\n         * The value `null` will be returned for server sockets or disconnected client sockets.\n         * See https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html for more information.\n         * @returns negotiated SSL/TLS protocol version of the current connection\n         */\n        getProtocol(): string | null;\n        /**\n         * Could be used to speed up handshake establishment when reconnecting to the server.\n         * @returns ASN.1 encoded TLS session or undefined if none was negotiated.\n         */\n        getSession(): any;\n        /**\n         * NOTE: Works only with client TLS sockets.\n         * Useful only for debugging, for session reuse provide session option to tls.connect().\n         * @returns TLS session ticket or undefined if none was negotiated.\n         */\n        getTLSTicket(): any;\n        /**\n         * Initiate TLS renegotiation process.\n         *\n         * NOTE: Can be used to request peer's certificate after the secure connection has been established.\n         * ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.\n         * @param options - The options may contain the following fields: rejectUnauthorized,\n         * requestCert (See tls.createServer() for details).\n         * @param callback - callback(err) will be executed with null as err, once the renegotiation\n         * is successfully completed.\n         */\n        renegotiate(options: { rejectUnauthorized?: boolean, requestCert?: boolean }, callback: (err: Error | null) => void): any;\n        /**\n         * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by\n         * the TLS layer until the entire fragment is received and its integrity is verified;\n         * large fragments can span multiple roundtrips, and their processing can be delayed due to packet\n         * loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,\n         * which may decrease overall server throughput.\n         * @param size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * @returns Returns true on success, false otherwise.\n         */\n        setMaxSendFragment(size: number): boolean;\n\n        /**\n         * events.EventEmitter\n         * 1. OCSPResponse\n         * 2. secureConnect\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        addListener(event: \"secureConnect\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"OCSPResponse\", response: Buffer): boolean;\n        emit(event: \"secureConnect\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        on(event: \"secureConnect\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        once(event: \"secureConnect\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependListener(event: \"secureConnect\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependOnceListener(event: \"secureConnect\", listener: () => void): this;\n    }\n\n    interface TlsOptions extends SecureContextOptions {\n        handshakeTimeout?: number;\n        requestCert?: boolean;\n        rejectUnauthorized?: boolean;\n        NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void;\n        sessionTimeout?: number;\n        ticketKeys?: Buffer;\n    }\n\n    interface ConnectionOptions extends SecureContextOptions {\n        host?: string;\n        port?: number;\n        path?: string; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.\n        socket?: net.Socket; // Establish secure connection on a given socket rather than creating a new socket\n        rejectUnauthorized?: boolean; // Defaults to true\n        NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        checkServerIdentity?: typeof checkServerIdentity;\n        servername?: string; // SNI TLS Extension\n        session?: Buffer;\n        minDHSize?: number;\n        secureContext?: SecureContext; // If not provided, the entire ConnectionOptions object will be passed to tls.createSecureContext()\n        lookup?: net.LookupFunction;\n    }\n\n    class Server extends net.Server {\n        addContext(hostName: string, credentials: {\n            key: string;\n            cert: string;\n            ca: string;\n        }): void;\n\n        /**\n         * events.EventEmitter\n         * 1. tlsClientError\n         * 2. newSession\n         * 3. OCSPRequest\n         * 4. resumeSession\n         * 5. secureConnection\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        addListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        addListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        addListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        addListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"tlsClientError\", err: Error, tlsSocket: TLSSocket): boolean;\n        emit(event: \"newSession\", sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void): boolean;\n        emit(event: \"OCSPRequest\", certificate: Buffer, issuer: Buffer, callback: Function): boolean;\n        emit(event: \"resumeSession\", sessionId: any, callback: (err: Error, sessionData: any) => void): boolean;\n        emit(event: \"secureConnection\", tlsSocket: TLSSocket): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        on(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        on(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        on(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        on(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        once(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        once(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        once(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        once(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        prependListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        prependListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependOnceListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        prependOnceListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        prependOnceListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n    }\n\n    interface SecurePair {\n        encrypted: any;\n        cleartext: any;\n    }\n\n    interface SecureContextOptions {\n        pfx?: string | Buffer | Array<string | Buffer | Object>;\n        key?: string | Buffer | Array<Buffer | Object>;\n        passphrase?: string;\n        cert?: string | Buffer | Array<string | Buffer>;\n        ca?: string | Buffer | Array<string | Buffer>;\n        ciphers?: string;\n        honorCipherOrder?: boolean;\n        ecdhCurve?: string;\n        clientCertEngine?: string;\n        crl?: string | Buffer | Array<string | Buffer>;\n        dhparam?: string | Buffer;\n        secureOptions?: number; // Value is a numeric bitmask of the `SSL_OP_*` options\n        secureProtocol?: string; // SSL Method, e.g. SSLv23_method\n        sessionIdContext?: string;\n    }\n\n    interface SecureContext {\n        context: any;\n    }\n\n    /*\n     * Verifies the certificate `cert` is issued to host `host`.\n     * @host The hostname to verify the certificate against\n     * @cert PeerCertificate representing the peer's certificate\n     *\n     * Returns Error object, populating it with the reason, host and cert on failure.  On success, returns undefined.\n     */\n    function checkServerIdentity(host: string, cert: PeerCertificate): Error | undefined;\n    function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;\n    function connect(options: ConnectionOptions, secureConnectionListener?: () => void): TLSSocket;\n    function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function createSecurePair(credentials?: crypto.Credentials, isServer?: boolean, requestCert?: boolean, rejectUnauthorized?: boolean): SecurePair;\n    function createSecureContext(details: SecureContextOptions): SecureContext;\n    function getCiphers(): string[];\n\n    const DEFAULT_ECDH_CURVE: string;\n}\n\ndeclare module \"crypto\" {\n    import * as stream from \"stream\";\n\n    interface Certificate {\n        exportChallenge(spkac: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        exportPublicKey(spkac: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        verifySpkac(spkac: Buffer | NodeJS.TypedArray | DataView): boolean;\n    }\n    const Certificate: {\n        new(): Certificate;\n        (): Certificate;\n    };\n\n    /** @deprecated since v10.0.0 */\n    const fips: boolean;\n\n    interface CredentialDetails {\n        pfx: string;\n        key: string;\n        passphrase: string;\n        cert: string;\n        ca: string | string[];\n        crl: string | string[];\n        ciphers: string;\n    }\n    interface Credentials { context?: any; }\n    function createCredentials(details: CredentialDetails): Credentials;\n    function createHash(algorithm: string, options?: stream.TransformOptions): Hash;\n    function createHmac(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Hmac;\n\n    type Utf8AsciiLatin1Encoding = \"utf8\" | \"ascii\" | \"latin1\";\n    type HexBase64Latin1Encoding = \"latin1\" | \"hex\" | \"base64\";\n    type Utf8AsciiBinaryEncoding = \"utf8\" | \"ascii\" | \"binary\";\n    type HexBase64BinaryEncoding = \"binary\" | \"base64\" | \"hex\";\n    type ECDHKeyFormat = \"compressed\" | \"uncompressed\" | \"hybrid\";\n\n    interface Hash extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Hash;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hash;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n    interface Hmac extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Hmac;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hmac;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n    type CipherCCMTypes = 'aes-128-ccm' | 'aes-192-ccm' | 'aes-256-ccm';\n    type CipherGCMTypes = 'aes-128-gcm' | 'aes-192-gcm' | 'aes-256-gcm';\n    interface CipherCCMOptions extends stream.TransformOptions {\n        authTagLength: number;\n    }\n    interface CipherGCMOptions extends stream.TransformOptions {\n        authTagLength?: number;\n    }\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherCCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): CipherCCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherGCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): CipherGCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: string, password: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Cipher;\n\n    function createCipheriv(algorithm: CipherCCMTypes, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): CipherCCM;\n    function createCipheriv(algorithm: CipherGCMTypes, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): CipherGCM;\n    function createCipheriv(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Cipher;\n\n    interface Cipher extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding): Buffer;\n        update(data: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64BinaryEncoding): string;\n        update(data: Buffer | NodeJS.TypedArray | DataView, input_encoding: any, output_encoding: HexBase64BinaryEncoding): string;\n        // second arg ignored\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding, output_encoding: HexBase64BinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // getAuthTag(): Buffer;\n        // setAAD(buffer: Buffer): this; // docs only say buffer\n    }\n    interface CipherCCM extends Cipher {\n        setAAD(buffer: Buffer, options: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    interface CipherGCM extends Cipher {\n        setAAD(buffer: Buffer, options?: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: CipherCCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): DecipherCCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: CipherGCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): DecipherGCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: string, password: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Decipher;\n\n    function createDecipheriv(\n        algorithm: CipherCCMTypes,\n        key: string | Buffer | NodeJS.TypedArray | DataView,\n        iv: string | Buffer | NodeJS.TypedArray | DataView,\n        options: CipherCCMOptions,\n    ): DecipherCCM;\n    function createDecipheriv(\n        algorithm: CipherGCMTypes,\n        key: string | Buffer | NodeJS.TypedArray | DataView,\n        iv: string | Buffer | NodeJS.TypedArray | DataView,\n        options?: CipherGCMOptions,\n    ): DecipherGCM;\n    function createDecipheriv(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Decipher;\n\n    interface Decipher extends NodeJS.ReadWriteStream {\n        update(data: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        update(data: string, input_encoding: HexBase64BinaryEncoding): Buffer;\n        update(data: Buffer | NodeJS.TypedArray | DataView, input_encoding: any, output_encoding: Utf8AsciiBinaryEncoding): string;\n        // second arg is ignored\n        update(data: string, input_encoding: HexBase64BinaryEncoding, output_encoding: Utf8AsciiBinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // setAuthTag(tag: Buffer | NodeJS.TypedArray | DataView): this;\n        // setAAD(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n    }\n    interface DecipherCCM extends Decipher {\n        setAuthTag(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n        setAAD(buffer: Buffer | NodeJS.TypedArray | DataView, options: { plaintextLength: number }): this;\n    }\n    interface DecipherGCM extends Decipher {\n        setAuthTag(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n        setAAD(buffer: Buffer | NodeJS.TypedArray | DataView, options?: { plaintextLength: number }): this;\n    }\n\n    function createSign(algorithm: string, options?: stream.WritableOptions): Signer;\n    interface Signer extends NodeJS.WritableStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Signer;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Signer;\n        sign(private_key: string | { key: string; passphrase: string, padding?: number, saltLength?: number }): Buffer;\n        sign(private_key: string | { key: string; passphrase: string, padding?: number, saltLength?: number }, output_format: HexBase64Latin1Encoding): string;\n    }\n    function createVerify(algorith: string, options?: stream.WritableOptions): Verify;\n    interface Verify extends NodeJS.WritableStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Verify;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Verify;\n        verify(object: string | Object, signature: Buffer | NodeJS.TypedArray | DataView): boolean;\n        verify(object: string | Object, signature: string, signature_format: HexBase64Latin1Encoding): boolean;\n        // https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format\n        // The signature field accepts a TypedArray type, but it is only available starting ES2017\n    }\n    function createDiffieHellman(prime_length: number, generator?: number | Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: number | Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: string, generator_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    interface DiffieHellman {\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrime(): Buffer;\n        getPrime(encoding: HexBase64Latin1Encoding): string;\n        getGenerator(): Buffer;\n        getGenerator(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        setPublicKey(public_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPublicKey(public_key: string, encoding: string): void;\n        setPrivateKey(private_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPrivateKey(private_key: string, encoding: string): void;\n        verifyError: number;\n    }\n    function getDiffieHellman(group_name: string): DiffieHellman;\n    function pbkdf2(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        iterations: number,\n        keylen: number,\n        digest: string,\n        callback: (err: Error | null, derivedKey: Buffer) => any,\n    ): void;\n    function pbkdf2Sync(password: string | Buffer | NodeJS.TypedArray | DataView, salt: string | Buffer | NodeJS.TypedArray | DataView, iterations: number, keylen: number, digest: string): Buffer;\n\n    function randomBytes(size: number): Buffer;\n    function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n    function pseudoRandomBytes(size: number): Buffer;\n    function pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n\n    function randomFillSync<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset?: number, size?: number): T;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset: number, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset: number, size: number, callback: (err: Error | null, buf: T) => void): void;\n\n    interface ScryptOptions {\n        N?: number;\n        r?: number;\n        p?: number;\n        maxmem?: number;\n    }\n    function scrypt(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        keylen: number, callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scrypt(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        keylen: number,\n        options: ScryptOptions,\n        callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scryptSync(password: string | Buffer | NodeJS.TypedArray | DataView, salt: string | Buffer | NodeJS.TypedArray | DataView, keylen: number, options?: ScryptOptions): Buffer;\n\n    interface RsaPublicKey {\n        key: string;\n        padding?: number;\n    }\n    interface RsaPrivateKey {\n        key: string;\n        passphrase?: string;\n        padding?: number;\n    }\n    function publicEncrypt(public_key: string | RsaPublicKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function privateDecrypt(private_key: string | RsaPrivateKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function privateEncrypt(private_key: string | RsaPrivateKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function publicDecrypt(public_key: string | RsaPublicKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function getCiphers(): string[];\n    function getCurves(): string[];\n    function getHashes(): string[];\n    class ECDH {\n        static convertKey(\n            key: string | Buffer | NodeJS.TypedArray | DataView,\n            curve: string,\n            inputEncoding?: HexBase64Latin1Encoding,\n            outputEncoding?: \"latin1\" | \"hex\" | \"base64\",\n            format?: \"uncompressed\" | \"compressed\" | \"hybrid\",\n        ): Buffer | string;\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        setPrivateKey(private_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPrivateKey(private_key: string, encoding: HexBase64Latin1Encoding): void;\n    }\n    function createECDH(curve_name: string): ECDH;\n    function timingSafeEqual(a: Buffer | NodeJS.TypedArray | DataView, b: Buffer | NodeJS.TypedArray | DataView): boolean;\n    /** @deprecated since v10.0.0 */\n    const DEFAULT_ENCODING: string;\n}\n\ndeclare module \"stream\" {\n    import * as events from \"events\";\n\n    class internal extends events.EventEmitter {\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\n    }\n\n    namespace internal {\n        class Stream extends internal { }\n\n        interface ReadableOptions {\n            highWaterMark?: number;\n            encoding?: string;\n            objectMode?: boolean;\n            read?(this: Readable, size: number): void;\n            destroy?(this: Readable, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        class Readable extends Stream implements NodeJS.ReadableStream {\n            readable: boolean;\n            readonly readableHighWaterMark: number;\n            readonly readableLength: number;\n            constructor(opts?: ReadableOptions);\n            _read(size: number): void;\n            read(size?: number): any;\n            setEncoding(encoding: string): this;\n            pause(): this;\n            resume(): this;\n            isPaused(): boolean;\n            unpipe(destination?: NodeJS.WritableStream): this;\n            unshift(chunk: any): void;\n            wrap(oldStream: NodeJS.ReadableStream): this;\n            push(chunk: any, encoding?: string): boolean;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. data\n             * 3. end\n             * 4. readable\n             * 5. error\n             */\n            addListener(event: \"close\", listener: () => void): this;\n            addListener(event: \"data\", listener: (chunk: any) => void): this;\n            addListener(event: \"end\", listener: () => void): this;\n            addListener(event: \"readable\", listener: () => void): this;\n            addListener(event: \"error\", listener: (err: Error) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: \"close\"): boolean;\n            emit(event: \"data\", chunk: any): boolean;\n            emit(event: \"end\"): boolean;\n            emit(event: \"readable\"): boolean;\n            emit(event: \"error\", err: Error): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: \"close\", listener: () => void): this;\n            on(event: \"data\", listener: (chunk: any) => void): this;\n            on(event: \"end\", listener: () => void): this;\n            on(event: \"readable\", listener: () => void): this;\n            on(event: \"error\", listener: (err: Error) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: \"close\", listener: () => void): this;\n            once(event: \"data\", listener: (chunk: any) => void): this;\n            once(event: \"end\", listener: () => void): this;\n            once(event: \"readable\", listener: () => void): this;\n            once(event: \"error\", listener: (err: Error) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: \"close\", listener: () => void): this;\n            prependListener(event: \"data\", listener: (chunk: any) => void): this;\n            prependListener(event: \"end\", listener: () => void): this;\n            prependListener(event: \"readable\", listener: () => void): this;\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: \"close\", listener: () => void): this;\n            prependOnceListener(event: \"data\", listener: (chunk: any) => void): this;\n            prependOnceListener(event: \"end\", listener: () => void): this;\n            prependOnceListener(event: \"readable\", listener: () => void): this;\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: \"close\", listener: () => void): this;\n            removeListener(event: \"data\", listener: (chunk: any) => void): this;\n            removeListener(event: \"end\", listener: () => void): this;\n            removeListener(event: \"readable\", listener: () => void): this;\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n        }\n\n        interface WritableOptions {\n            highWaterMark?: number;\n            decodeStrings?: boolean;\n            objectMode?: boolean;\n            write?(this: Writable, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Writable, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            destroy?(this: Writable, error: Error | null, callback: (error: Error | null) => void): void;\n            final?(this: Writable, callback: (error?: Error | null) => void): void;\n        }\n\n        class Writable extends Stream implements NodeJS.WritableStream {\n            writable: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            constructor(opts?: WritableOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. drain\n             * 3. error\n             * 4. finish\n             * 5. pipe\n             * 6. unpipe\n             */\n            addListener(event: \"close\", listener: () => void): this;\n            addListener(event: \"drain\", listener: () => void): this;\n            addListener(event: \"error\", listener: (err: Error) => void): this;\n            addListener(event: \"finish\", listener: () => void): this;\n            addListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            addListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: \"close\"): boolean;\n            emit(event: \"drain\"): boolean;\n            emit(event: \"error\", err: Error): boolean;\n            emit(event: \"finish\"): boolean;\n            emit(event: \"pipe\", src: Readable): boolean;\n            emit(event: \"unpipe\", src: Readable): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: \"close\", listener: () => void): this;\n            on(event: \"drain\", listener: () => void): this;\n            on(event: \"error\", listener: (err: Error) => void): this;\n            on(event: \"finish\", listener: () => void): this;\n            on(event: \"pipe\", listener: (src: Readable) => void): this;\n            on(event: \"unpipe\", listener: (src: Readable) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: \"close\", listener: () => void): this;\n            once(event: \"drain\", listener: () => void): this;\n            once(event: \"error\", listener: (err: Error) => void): this;\n            once(event: \"finish\", listener: () => void): this;\n            once(event: \"pipe\", listener: (src: Readable) => void): this;\n            once(event: \"unpipe\", listener: (src: Readable) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: \"close\", listener: () => void): this;\n            prependListener(event: \"drain\", listener: () => void): this;\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\n            prependListener(event: \"finish\", listener: () => void): this;\n            prependListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            prependListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: \"close\", listener: () => void): this;\n            prependOnceListener(event: \"drain\", listener: () => void): this;\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n            prependOnceListener(event: \"finish\", listener: () => void): this;\n            prependOnceListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            prependOnceListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: \"close\", listener: () => void): this;\n            removeListener(event: \"drain\", listener: () => void): this;\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\n            removeListener(event: \"finish\", listener: () => void): this;\n            removeListener(event: \"pipe\", listener: (src: Readable) => void): this;\n            removeListener(event: \"unpipe\", listener: (src: Readable) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        }\n\n        interface DuplexOptions extends ReadableOptions, WritableOptions {\n            allowHalfOpen?: boolean;\n            readableObjectMode?: boolean;\n            writableObjectMode?: boolean;\n            read?(this: Duplex, size: number): void;\n            write?(this: Duplex, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Duplex, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Duplex, callback: (error?: Error | null) => void): void;\n            destroy?(this: Duplex, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        // Note: Duplex extends both Readable and Writable.\n        class Duplex extends Readable implements Writable {\n            writable: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            constructor(opts?: DuplexOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n        }\n\n        type TransformCallback = (error?: Error, data?: any) => void;\n\n        interface TransformOptions extends DuplexOptions {\n            read?(this: Transform, size: number): void;\n            write?(this: Transform, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Transform, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Transform, callback: (error?: Error | null) => void): void;\n            destroy?(this: Transform, error: Error | null, callback: (error: Error | null) => void): void;\n            transform?(this: Transform, chunk: any, encoding: string, callback: TransformCallback): void;\n            flush?(this: Transform, callback: TransformCallback): void;\n        }\n\n        class Transform extends Duplex {\n            constructor(opts?: TransformOptions);\n            _transform(chunk: any, encoding: string, callback: TransformCallback): void;\n            _flush(callback: TransformCallback): void;\n        }\n\n        class PassThrough extends Transform { }\n\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, callback: (err?: NodeJS.ErrnoException) => void): () => void;\n        namespace finished {\n            function __promisify__(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream): Promise<void>;\n        }\n\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: T, callback?: (err: NodeJS.ErrnoException) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: T, callback?: (err: NodeJS.ErrnoException) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: T,\n            callback?: (err: NodeJS.ErrnoException) => void,\n        ): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: NodeJS.ReadWriteStream,\n            stream5: T,\n            callback?: (err: NodeJS.ErrnoException) => void,\n        ): T;\n        function pipeline(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>, callback?: (err: NodeJS.ErrnoException) => void): NodeJS.WritableStream;\n        function pipeline(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n            ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException) => void)>,\n        ): NodeJS.WritableStream;\n        namespace pipeline {\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.ReadWriteStream, stream4: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream,\n                stream3: NodeJS.ReadWriteStream,\n                stream4: NodeJS.ReadWriteStream,\n                stream5: NodeJS.WritableStream,\n            ): Promise<void>;\n            function __promisify__(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream>,\n            ): Promise<void>;\n        }\n    }\n\n    export = internal;\n}\n\ndeclare module \"util\" {\n    interface InspectOptions extends NodeJS.InspectOptions { }\n    function format(format: any, ...param: any[]): string;\n    function formatWithOptions(inspectOptions: InspectOptions, format: string, ...param: any[]): string;\n    /** @deprecated since v0.11.3 - use `console.error()` instead. */\n    function debug(string: string): void;\n    /** @deprecated since v0.11.3 - use `console.error()` instead. */\n    function error(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use `console.log()` instead. */\n    function puts(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use `console.log()` instead. */\n    function print(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use a third party module instead. */\n    function log(string: string): void;\n    const inspect: {\n        (object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\n        (object: any, options: InspectOptions): string;\n        colors: {\n            [color: string]: [number, number] | undefined\n        }\n        styles: {\n            [style: string]: string | undefined\n        }\n        defaultOptions: InspectOptions;\n        custom: symbol;\n    };\n    /** @deprecated since v4.0.0 - use `Array.isArray()` instead. */\n    function isArray(object: any): object is any[];\n    /** @deprecated since v4.0.0 - use `util.types.isRegExp()` instead. */\n    function isRegExp(object: any): object is RegExp;\n    /** @deprecated since v4.0.0 - use `util.types.isDate()` instead. */\n    function isDate(object: any): object is Date;\n    /** @deprecated since v4.0.0 - use `util.types.isNativeError()` instead. */\n    function isError(object: any): object is Error;\n    function inherits(constructor: any, superConstructor: any): void;\n    function debuglog(key: string): (msg: string, ...param: any[]) => void;\n    /** @deprecated since v4.0.0 - use `typeof value === 'boolean'` instead. */\n    function isBoolean(object: any): object is boolean;\n    /** @deprecated since v4.0.0 - use `Buffer.isBuffer()` instead. */\n    function isBuffer(object: any): object is Buffer;\n    /** @deprecated since v4.0.0 - use `typeof value === 'function'` instead. */\n    function isFunction(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `value === null` instead. */\n    function isNull(object: any): object is null;\n    /** @deprecated since v4.0.0 - use `value === null || value === undefined` instead. */\n    function isNullOrUndefined(object: any): object is null | undefined;\n    /** @deprecated since v4.0.0 - use `typeof value === 'number'` instead. */\n    function isNumber(object: any): object is number;\n    /** @deprecated since v4.0.0 - use `value !== null && typeof value === 'object'` instead. */\n    function isObject(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `(typeof value !== 'object' && typeof value !== 'function') || value === null` instead. */\n    function isPrimitive(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `typeof value === 'string'` instead. */\n    function isString(object: any): object is string;\n    /** @deprecated since v4.0.0 - use `typeof value === 'symbol'` instead. */\n    function isSymbol(object: any): object is symbol;\n    /** @deprecated since v4.0.0 - use `value === undefined` instead. */\n    function isUndefined(object: any): object is undefined;\n    function deprecate<T extends Function>(fn: T, message: string): T;\n    function isDeepStrictEqual(val1: any, val2: any): boolean;\n\n    interface CustomPromisify<TCustom extends Function> extends Function {\n        __promisify__: TCustom;\n    }\n\n    function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<TResult>(fn: () => Promise<TResult>): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1>(fn: (arg1: T1) => Promise<void>): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, TResult>(fn: (arg1: T1) => Promise<TResult>): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2>(fn: (arg1: T1, arg2: T2) => Promise<void>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2) => Promise<TResult>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n\n    function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;\n    function promisify<TResult>(fn: (callback: (err: Error | null, result: TResult) => void) => void): () => Promise<TResult>;\n    function promisify(fn: (callback: (err?: Error | null) => void) => void): () => Promise<void>;\n    function promisify<T1, TResult>(fn: (arg1: T1, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1) => Promise<TResult>;\n    function promisify<T1>(fn: (arg1: T1, callback: (err?: Error | null) => void) => void): (arg1: T1) => Promise<void>;\n    function promisify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1, arg2: T2) => Promise<TResult>;\n    function promisify<T1, T2>(fn: (arg1: T1, arg2: T2, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2) => Promise<void>;\n    function promisify<T1, T2, T3, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;\n    function promisify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;\n    function promisify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: Error | null, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;\n    function promisify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: Error | null, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: Error | null) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;\n    function promisify(fn: Function): Function;\n    namespace promisify {\n        const custom: symbol;\n    }\n\n    namespace types {\n        function isAnyArrayBuffer(object: any): boolean;\n        function isArgumentsObject(object: any): object is IArguments;\n        function isArrayBuffer(object: any): object is ArrayBuffer;\n        function isAsyncFunction(object: any): boolean;\n        function isBooleanObject(object: any): object is Boolean;\n        function isBoxedPrimitive(object: any): object is (Number | Boolean | String | Symbol /* BigInt */);\n        function isDataView(object: any): object is DataView;\n        function isDate(object: any): object is Date;\n        function isExternal(object: any): boolean;\n        function isFloat32Array(object: any): object is Float32Array;\n        function isFloat64Array(object: any): object is Float64Array;\n        function isGeneratorFunction(object: any): boolean;\n        function isGeneratorObject(object: any): boolean;\n        function isInt8Array(object: any): object is Int8Array;\n        function isInt16Array(object: any): object is Int16Array;\n        function isInt32Array(object: any): object is Int32Array;\n        function isMap(object: any): boolean;\n        function isMapIterator(object: any): boolean;\n        function isNativeError(object: any): object is Error;\n        function isNumberObject(object: any): object is Number;\n        function isPromise(object: any): boolean;\n        function isProxy(object: any): boolean;\n        function isRegExp(object: any): object is RegExp;\n        function isSet(object: any): boolean;\n        function isSetIterator(object: any): boolean;\n        function isSharedArrayBuffer(object: any): boolean;\n        function isStringObject(object: any): boolean;\n        function isSymbolObject(object: any): boolean;\n        function isTypedArray(object: any): object is NodeJS.TypedArray;\n        function isUint8Array(object: any): object is Uint8Array;\n        function isUint8ClampedArray(object: any): object is Uint8ClampedArray;\n        function isUint16Array(object: any): object is Uint16Array;\n        function isUint32Array(object: any): object is Uint32Array;\n        function isWeakMap(object: any): boolean;\n        function isWeakSet(object: any): boolean;\n        function isWebAssemblyCompiledModule(object: any): boolean;\n    }\n\n    class TextDecoder {\n        readonly encoding: string;\n        readonly fatal: boolean;\n        readonly ignoreBOM: boolean;\n        constructor(\n          encoding?: string,\n          options?: { fatal?: boolean; ignoreBOM?: boolean }\n        );\n        decode(\n          input?: NodeJS.TypedArray | DataView | ArrayBuffer | null,\n          options?: { stream?: boolean }\n        ): string;\n    }\n\n    class TextEncoder {\n        readonly encoding: string;\n        constructor();\n        encode(input?: string): Uint8Array;\n    }\n}\n\ndeclare module \"assert\" {\n    function internal(value: any, message?: string | Error): void;\n    namespace internal {\n        class AssertionError implements Error {\n            name: string;\n            message: string;\n            actual: any;\n            expected: any;\n            operator: string;\n            generatedMessage: boolean;\n            code: 'ERR_ASSERTION';\n\n            constructor(options?: {\n                message?: string; actual?: any; expected?: any;\n                operator?: string; stackStartFn?: Function\n            });\n        }\n\n        function fail(message?: string | Error): never;\n        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */\n        function fail(actual: any, expected: any, message?: string | Error, operator?: string, stackStartFn?: Function): never;\n        function ok(value: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use strictEqual() instead. */\n        function equal(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use notStrictEqual() instead. */\n        function notEqual(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use deepStrictEqual() instead. */\n        function deepEqual(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use notDeepStrictEqual() instead. */\n        function notDeepEqual(actual: any, expected: any, message?: string | Error): void;\n        function strictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function deepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notDeepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n\n        function throws(block: Function, message?: string | Error): void;\n        function throws(block: Function, error: RegExp | Function | Object | Error, message?: string | Error): void;\n        function doesNotThrow(block: Function, message?: string | Error): void;\n        function doesNotThrow(block: Function, error: RegExp | Function, message?: string | Error): void;\n\n        function ifError(value: any): void;\n\n        function rejects(block: Function | Promise<any>, message?: string | Error): Promise<void>;\n        function rejects(block: Function | Promise<any>, error: RegExp | Function | Object | Error, message?: string | Error): Promise<void>;\n        function doesNotReject(block: Function | Promise<any>, message?: string | Error): Promise<void>;\n        function doesNotReject(block: Function | Promise<any>, error: RegExp | Function, message?: string | Error): Promise<void>;\n\n        const strict: typeof internal;\n    }\n\n    export = internal;\n}\n\ndeclare module \"tty\" {\n    import * as net from \"net\";\n\n    function isatty(fd: number): boolean;\n    class ReadStream extends net.Socket {\n        isRaw: boolean;\n        setRawMode(mode: boolean): void;\n        isTTY: boolean;\n    }\n    class WriteStream extends net.Socket {\n        columns: number;\n        rows: number;\n        isTTY: boolean;\n    }\n}\n\ndeclare module \"domain\" {\n    import * as events from \"events\";\n\n    class Domain extends events.EventEmitter implements NodeJS.Domain {\n        run(fn: Function): void;\n        add(emitter: events.EventEmitter): void;\n        remove(emitter: events.EventEmitter): void;\n        bind(cb: (err: Error, data: any) => any): any;\n        intercept(cb: (data: any) => any): any;\n        members: any[];\n        enter(): void;\n        exit(): void;\n    }\n\n    function create(): Domain;\n}\n\ndeclare module \"constants\" {\n    const E2BIG: number;\n    const EACCES: number;\n    const EADDRINUSE: number;\n    const EADDRNOTAVAIL: number;\n    const EAFNOSUPPORT: number;\n    const EAGAIN: number;\n    const EALREADY: number;\n    const EBADF: number;\n    const EBADMSG: number;\n    const EBUSY: number;\n    const ECANCELED: number;\n    const ECHILD: number;\n    const ECONNABORTED: number;\n    const ECONNREFUSED: number;\n    const ECONNRESET: number;\n    const EDEADLK: number;\n    const EDESTADDRREQ: number;\n    const EDOM: number;\n    const EEXIST: number;\n    const EFAULT: number;\n    const EFBIG: number;\n    const EHOSTUNREACH: number;\n    const EIDRM: number;\n    const EILSEQ: number;\n    const EINPROGRESS: number;\n    const EINTR: number;\n    const EINVAL: number;\n    const EIO: number;\n    const EISCONN: number;\n    const EISDIR: number;\n    const ELOOP: number;\n    const EMFILE: number;\n    const EMLINK: number;\n    const EMSGSIZE: number;\n    const ENAMETOOLONG: number;\n    const ENETDOWN: number;\n    const ENETRESET: number;\n    const ENETUNREACH: number;\n    const ENFILE: number;\n    const ENOBUFS: number;\n    const ENODATA: number;\n    const ENODEV: number;\n    const ENOENT: number;\n    const ENOEXEC: number;\n    const ENOLCK: number;\n    const ENOLINK: number;\n    const ENOMEM: number;\n    const ENOMSG: number;\n    const ENOPROTOOPT: number;\n    const ENOSPC: number;\n    const ENOSR: number;\n    const ENOSTR: number;\n    const ENOSYS: number;\n    const ENOTCONN: number;\n    const ENOTDIR: number;\n    const ENOTEMPTY: number;\n    const ENOTSOCK: number;\n    const ENOTSUP: number;\n    const ENOTTY: number;\n    const ENXIO: number;\n    const EOPNOTSUPP: number;\n    const EOVERFLOW: number;\n    const EPERM: number;\n    const EPIPE: number;\n    const EPROTO: number;\n    const EPROTONOSUPPORT: number;\n    const EPROTOTYPE: number;\n    const ERANGE: number;\n    const EROFS: number;\n    const ESPIPE: number;\n    const ESRCH: number;\n    const ETIME: number;\n    const ETIMEDOUT: number;\n    const ETXTBSY: number;\n    const EWOULDBLOCK: number;\n    const EXDEV: number;\n    const WSAEINTR: number;\n    const WSAEBADF: number;\n    const WSAEACCES: number;\n    const WSAEFAULT: number;\n    const WSAEINVAL: number;\n    const WSAEMFILE: number;\n    const WSAEWOULDBLOCK: number;\n    const WSAEINPROGRESS: number;\n    const WSAEALREADY: number;\n    const WSAENOTSOCK: number;\n    const WSAEDESTADDRREQ: number;\n    const WSAEMSGSIZE: number;\n    const WSAEPROTOTYPE: number;\n    const WSAENOPROTOOPT: number;\n    const WSAEPROTONOSUPPORT: number;\n    const WSAESOCKTNOSUPPORT: number;\n    const WSAEOPNOTSUPP: number;\n    const WSAEPFNOSUPPORT: number;\n    const WSAEAFNOSUPPORT: number;\n    const WSAEADDRINUSE: number;\n    const WSAEADDRNOTAVAIL: number;\n    const WSAENETDOWN: number;\n    const WSAENETUNREACH: number;\n    const WSAENETRESET: number;\n    const WSAECONNABORTED: number;\n    const WSAECONNRESET: number;\n    const WSAENOBUFS: number;\n    const WSAEISCONN: number;\n    const WSAENOTCONN: number;\n    const WSAESHUTDOWN: number;\n    const WSAETOOMANYREFS: number;\n    const WSAETIMEDOUT: number;\n    const WSAECONNREFUSED: number;\n    const WSAELOOP: number;\n    const WSAENAMETOOLONG: number;\n    const WSAEHOSTDOWN: number;\n    const WSAEHOSTUNREACH: number;\n    const WSAENOTEMPTY: number;\n    const WSAEPROCLIM: number;\n    const WSAEUSERS: number;\n    const WSAEDQUOT: number;\n    const WSAESTALE: number;\n    const WSAEREMOTE: number;\n    const WSASYSNOTREADY: number;\n    const WSAVERNOTSUPPORTED: number;\n    const WSANOTINITIALISED: number;\n    const WSAEDISCON: number;\n    const WSAENOMORE: number;\n    const WSAECANCELLED: number;\n    const WSAEINVALIDPROCTABLE: number;\n    const WSAEINVALIDPROVIDER: number;\n    const WSAEPROVIDERFAILEDINIT: number;\n    const WSASYSCALLFAILURE: number;\n    const WSASERVICE_NOT_FOUND: number;\n    const WSATYPE_NOT_FOUND: number;\n    const WSA_E_NO_MORE: number;\n    const WSA_E_CANCELLED: number;\n    const WSAEREFUSED: number;\n    const SIGHUP: number;\n    const SIGINT: number;\n    const SIGILL: number;\n    const SIGABRT: number;\n    const SIGFPE: number;\n    const SIGKILL: number;\n    const SIGSEGV: number;\n    const SIGTERM: number;\n    const SIGBREAK: number;\n    const SIGWINCH: number;\n    const SSL_OP_ALL: number;\n    const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;\n    const SSL_OP_CIPHER_SERVER_PREFERENCE: number;\n    const SSL_OP_CISCO_ANYCONNECT: number;\n    const SSL_OP_COOKIE_EXCHANGE: number;\n    const SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;\n    const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;\n    const SSL_OP_EPHEMERAL_RSA: number;\n    const SSL_OP_LEGACY_SERVER_CONNECT: number;\n    const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;\n    const SSL_OP_MICROSOFT_SESS_ID_BUG: number;\n    const SSL_OP_MSIE_SSLV2_RSA_PADDING: number;\n    const SSL_OP_NETSCAPE_CA_DN_BUG: number;\n    const SSL_OP_NETSCAPE_CHALLENGE_BUG: number;\n    const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;\n    const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;\n    const SSL_OP_NO_COMPRESSION: number;\n    const SSL_OP_NO_QUERY_MTU: number;\n    const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;\n    const SSL_OP_NO_SSLv2: number;\n    const SSL_OP_NO_SSLv3: number;\n    const SSL_OP_NO_TICKET: number;\n    const SSL_OP_NO_TLSv1: number;\n    const SSL_OP_NO_TLSv1_1: number;\n    const SSL_OP_NO_TLSv1_2: number;\n    const SSL_OP_PKCS1_CHECK_1: number;\n    const SSL_OP_PKCS1_CHECK_2: number;\n    const SSL_OP_SINGLE_DH_USE: number;\n    const SSL_OP_SINGLE_ECDH_USE: number;\n    const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;\n    const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;\n    const SSL_OP_TLS_BLOCK_PADDING_BUG: number;\n    const SSL_OP_TLS_D5_BUG: number;\n    const SSL_OP_TLS_ROLLBACK_BUG: number;\n    const ENGINE_METHOD_DSA: number;\n    const ENGINE_METHOD_DH: number;\n    const ENGINE_METHOD_RAND: number;\n    const ENGINE_METHOD_ECDH: number;\n    const ENGINE_METHOD_ECDSA: number;\n    const ENGINE_METHOD_CIPHERS: number;\n    const ENGINE_METHOD_DIGESTS: number;\n    const ENGINE_METHOD_STORE: number;\n    const ENGINE_METHOD_PKEY_METHS: number;\n    const ENGINE_METHOD_PKEY_ASN1_METHS: number;\n    const ENGINE_METHOD_ALL: number;\n    const ENGINE_METHOD_NONE: number;\n    const DH_CHECK_P_NOT_SAFE_PRIME: number;\n    const DH_CHECK_P_NOT_PRIME: number;\n    const DH_UNABLE_TO_CHECK_GENERATOR: number;\n    const DH_NOT_SUITABLE_GENERATOR: number;\n    const NPN_ENABLED: number;\n    const RSA_PKCS1_PADDING: number;\n    const RSA_SSLV23_PADDING: number;\n    const RSA_NO_PADDING: number;\n    const RSA_PKCS1_OAEP_PADDING: number;\n    const RSA_X931_PADDING: number;\n    const RSA_PKCS1_PSS_PADDING: number;\n    const POINT_CONVERSION_COMPRESSED: number;\n    const POINT_CONVERSION_UNCOMPRESSED: number;\n    const POINT_CONVERSION_HYBRID: number;\n    const O_RDONLY: number;\n    const O_WRONLY: number;\n    const O_RDWR: number;\n    const S_IFMT: number;\n    const S_IFREG: number;\n    const S_IFDIR: number;\n    const S_IFCHR: number;\n    const S_IFBLK: number;\n    const S_IFIFO: number;\n    const S_IFSOCK: number;\n    const S_IRWXU: number;\n    const S_IRUSR: number;\n    const S_IWUSR: number;\n    const S_IXUSR: number;\n    const S_IRWXG: number;\n    const S_IRGRP: number;\n    const S_IWGRP: number;\n    const S_IXGRP: number;\n    const S_IRWXO: number;\n    const S_IROTH: number;\n    const S_IWOTH: number;\n    const S_IXOTH: number;\n    const S_IFLNK: number;\n    const O_CREAT: number;\n    const O_EXCL: number;\n    const O_NOCTTY: number;\n    const O_DIRECTORY: number;\n    const O_NOATIME: number;\n    const O_NOFOLLOW: number;\n    const O_SYNC: number;\n    const O_DSYNC: number;\n    const O_SYMLINK: number;\n    const O_DIRECT: number;\n    const O_NONBLOCK: number;\n    const O_TRUNC: number;\n    const O_APPEND: number;\n    const F_OK: number;\n    const R_OK: number;\n    const W_OK: number;\n    const X_OK: number;\n    const COPYFILE_EXCL: number;\n    const COPYFILE_FICLONE: number;\n    const COPYFILE_FICLONE_FORCE: number;\n    const UV_UDP_REUSEADDR: number;\n    const SIGQUIT: number;\n    const SIGTRAP: number;\n    const SIGIOT: number;\n    const SIGBUS: number;\n    const SIGUSR1: number;\n    const SIGUSR2: number;\n    const SIGPIPE: number;\n    const SIGALRM: number;\n    const SIGCHLD: number;\n    const SIGSTKFLT: number;\n    const SIGCONT: number;\n    const SIGSTOP: number;\n    const SIGTSTP: number;\n    const SIGTTIN: number;\n    const SIGTTOU: number;\n    const SIGURG: number;\n    const SIGXCPU: number;\n    const SIGXFSZ: number;\n    const SIGVTALRM: number;\n    const SIGPROF: number;\n    const SIGIO: number;\n    const SIGPOLL: number;\n    const SIGPWR: number;\n    const SIGSYS: number;\n    const SIGUNUSED: number;\n    const defaultCoreCipherList: string;\n    const defaultCipherList: string;\n    const ENGINE_METHOD_RSA: number;\n    const ALPN_ENABLED: number;\n}\n\ndeclare module \"module\" {\n    export = NodeJS.Module;\n}\n\ndeclare module \"process\" {\n    export = process;\n}\n\ndeclare module \"v8\" {\n    interface HeapSpaceInfo {\n        space_name: string;\n        space_size: number;\n        space_used_size: number;\n        space_available_size: number;\n        physical_space_size: number;\n    }\n\n    // ** Signifies if the --zap_code_space option is enabled or not.  1 == enabled, 0 == disabled. */\n    type DoesZapCodeSpaceFlag = 0 | 1;\n\n    interface HeapInfo {\n        total_heap_size: number;\n        total_heap_size_executable: number;\n        total_physical_size: number;\n        total_available_size: number;\n        used_heap_size: number;\n        heap_size_limit: number;\n        malloced_memory: number;\n        peak_malloced_memory: number;\n        does_zap_garbage: DoesZapCodeSpaceFlag;\n    }\n\n    function getHeapStatistics(): HeapInfo;\n    function getHeapSpaceStatistics(): HeapSpaceInfo[];\n    function setFlagsFromString(flags: string): void;\n}\n\ndeclare module \"timers\" {\n    function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    namespace setTimeout {\n        function __promisify__(ms: number): Promise<void>;\n        function __promisify__<T>(ms: number, value: T): Promise<T>;\n    }\n    function clearTimeout(timeoutId: NodeJS.Timeout): void;\n    function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    function clearInterval(intervalId: NodeJS.Timeout): void;\n    function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\n    namespace setImmediate {\n        function __promisify__(): Promise<void>;\n        function __promisify__<T>(value: T): Promise<T>;\n    }\n    function clearImmediate(immediateId: NodeJS.Immediate): void;\n}\n\ndeclare module \"console\" {\n    export = console;\n}\n\n/**\n * Async Hooks module: https://nodejs.org/api/async_hooks.html\n */\ndeclare module \"async_hooks\" {\n    /**\n     * Returns the asyncId of the current execution context.\n     */\n    function executionAsyncId(): number;\n\n    /**\n     * Returns the ID of the resource responsible for calling the callback that is currently being executed.\n     */\n    function triggerAsyncId(): number;\n\n    interface HookCallbacks {\n        /**\n         * Called when a class is constructed that has the possibility to emit an asynchronous event.\n         * @param asyncId a unique ID for the async resource\n         * @param type the type of the async resource\n         * @param triggerAsyncId the unique ID of the async resource in whose execution context this async resource was created\n         * @param resource reference to the resource representing the async operation, needs to be released during destroy\n         */\n        init?(asyncId: number, type: string, triggerAsyncId: number, resource: Object): void;\n\n        /**\n         * When an asynchronous operation is initiated or completes a callback is called to notify the user.\n         * The before callback is called just before said callback is executed.\n         * @param asyncId the unique identifier assigned to the resource about to execute the callback.\n         */\n        before?(asyncId: number): void;\n\n        /**\n         * Called immediately after the callback specified in before is completed.\n         * @param asyncId the unique identifier assigned to the resource which has executed the callback.\n         */\n        after?(asyncId: number): void;\n\n        /**\n         * Called when a promise has resolve() called. This may not be in the same execution id\n         * as the promise itself.\n         * @param asyncId the unique id for the promise that was resolve()d.\n         */\n        promiseResolve?(asyncId: number): void;\n\n        /**\n         * Called after the resource corresponding to asyncId is destroyed\n         * @param asyncId a unique ID for the async resource\n         */\n        destroy?(asyncId: number): void;\n    }\n\n    interface AsyncHook {\n        /**\n         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.\n         */\n        enable(): this;\n\n        /**\n         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.\n         */\n        disable(): this;\n    }\n\n    /**\n     * Registers functions to be called for different lifetime events of each async operation.\n     * @param options the callbacks to register\n     * @return an AsyncHooks instance used for disabling and enabling hooks\n     */\n    function createHook(options: HookCallbacks): AsyncHook;\n\n    interface AsyncResourceOptions {\n      /**\n       * The ID of the execution context that created this async event.\n       * Default: `executionAsyncId()`\n       */\n      triggerAsyncId?: number;\n\n      /**\n       * Disables automatic `emitDestroy` when the object is garbage collected.\n       * This usually does not need to be set (even if `emitDestroy` is called\n       * manually), unless the resource's `asyncId` is retrieved and the\n       * sensitive API's `emitDestroy` is called with it.\n       * Default: `false`\n       */\n      requireManualDestroy?: boolean;\n    }\n\n    /**\n     * The class AsyncResource was designed to be extended by the embedder's async resources.\n     * Using this users can easily trigger the lifetime events of their own resources.\n     */\n    class AsyncResource {\n        /**\n         * AsyncResource() is meant to be extended. Instantiating a\n         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n         * async_hook.executionAsyncId() is used.\n         * @param type The type of async event.\n         * @param triggerAsyncId The ID of the execution context that created\n         *   this async event (default: `executionAsyncId()`), or an\n         *   AsyncResourceOptions object (since 9.3)\n         */\n        constructor(type: string, triggerAsyncId?: number|AsyncResourceOptions);\n\n        /**\n         * Call AsyncHooks before callbacks.\n         * @deprecated since 9.6 - Use asyncResource.runInAsyncScope() instead.\n         */\n        emitBefore(): void;\n\n        /**\n         * Call AsyncHooks after callbacks.\n         * @deprecated since 9.6 - Use asyncResource.runInAsyncScope() instead.\n         */\n        emitAfter(): void;\n\n        /**\n         * Call the provided function with the provided arguments in the\n         * execution context of the async resource. This will establish the\n         * context, trigger the AsyncHooks before callbacks, call the function,\n         * trigger the AsyncHooks after callbacks, and then restore the original\n         * execution context.\n         * @param fn The function to call in the execution context of this\n         *   async resource.\n         * @param thisArg The receiver to be used for the function call.\n         * @param args Optional arguments to pass to the function.\n         */\n        runInAsyncScope<This, Result>(fn: (this: This, ...args: any[]) => Result, thisArg?: This, ...args: any[]): Result;\n\n        /**\n         * Call AsyncHooks destroy callbacks.\n         */\n        emitDestroy(): void;\n\n        /**\n         * @return the unique ID assigned to this AsyncResource instance.\n         */\n        asyncId(): number;\n\n        /**\n         * @return the trigger ID for this AsyncResource instance.\n         */\n        triggerAsyncId(): number;\n    }\n}\n\ndeclare module \"http2\" {\n    import * as events from \"events\";\n    import * as fs from \"fs\";\n    import * as net from \"net\";\n    import * as stream from \"stream\";\n    import * as tls from \"tls\";\n    import * as url from \"url\";\n\n    import { IncomingHttpHeaders as Http1IncomingHttpHeaders, OutgoingHttpHeaders } from \"http\";\n    export { OutgoingHttpHeaders } from \"http\";\n\n    export interface IncomingHttpStatusHeader {\n        \":status\"?: number;\n    }\n\n    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {\n        \":path\"?: string;\n        \":method\"?: string;\n        \":authority\"?: string;\n        \":scheme\"?: string;\n    }\n\n    // Http2Stream\n\n    export interface StreamPriorityOptions {\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        silent?: boolean;\n    }\n\n    export interface StreamState {\n        localWindowSize?: number;\n        state?: number;\n        streamLocalClose?: number;\n        streamRemoteClose?: number;\n        sumDependencyWeight?: number;\n        weight?: number;\n    }\n\n    export interface ServerStreamResponseOptions {\n        endStream?: boolean;\n        getTrailers?: (trailers: OutgoingHttpHeaders) => void;\n    }\n\n    export interface StatOptions {\n        offset: number;\n        length: number;\n    }\n\n    export interface ServerStreamFileResponseOptions {\n        statCheck?: (stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions) => void | boolean;\n        getTrailers?: (trailers: OutgoingHttpHeaders) => void;\n        offset?: number;\n        length?: number;\n    }\n\n    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {\n        onError?: (err: NodeJS.ErrnoException) => void;\n    }\n\n    export interface Http2Stream extends stream.Duplex {\n        readonly aborted: boolean;\n        readonly closed: boolean;\n        readonly destroyed: boolean;\n        readonly pending: boolean;\n        readonly rstCode: number;\n        readonly session: Http2Session;\n        readonly state: StreamState;\n        /**\n         * Set the true if the END_STREAM flag was set in the request or response HEADERS frame received,\n         * indicating that no additional data should be received and the readable side of the Http2Stream will be closed.\n         */\n        readonly endAfterHeaders: boolean;\n        close(code?: number, callback?: () => void): void;\n        priority(options: StreamPriorityOptions): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"aborted\", listener: () => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"aborted\"): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"data\", chunk: Buffer | string): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"finish\"): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number): boolean;\n        emit(event: \"pipe\", src: stream.Readable): boolean;\n        emit(event: \"unpipe\", src: stream.Readable): boolean;\n        emit(event: \"streamClosed\", code: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"trailers\", trailers: IncomingHttpHeaders, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"aborted\", listener: () => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"streamClosed\", listener: (code: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: () => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"streamClosed\", listener: (code: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: () => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: () => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n    }\n\n    export interface ClientHttp2Stream extends Http2Stream {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        addListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"headers\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: \"push\", headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"response\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        on(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        once(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"headers\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependOnceListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"response\", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n    }\n\n    export interface ServerHttp2Stream extends Http2Stream {\n        additionalHeaders(headers: OutgoingHttpHeaders): void;\n        readonly headersSent: boolean;\n        readonly pushAllowed: boolean;\n        pushStream(headers: OutgoingHttpHeaders, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        pushStream(headers: OutgoingHttpHeaders, options?: StreamPriorityOptions, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;\n        respondWithFD(fd: number, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptions): void;\n        respondWithFile(path: string, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptionsWithError): void;\n    }\n\n    // Http2Session\n\n    export interface Settings {\n        headerTableSize?: number;\n        enablePush?: boolean;\n        initialWindowSize?: number;\n        maxFrameSize?: number;\n        maxConcurrentStreams?: number;\n        maxHeaderListSize?: number;\n    }\n\n    export interface ClientSessionRequestOptions {\n        endStream?: boolean;\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        getTrailers?: (trailers: OutgoingHttpHeaders, flags: number) => void;\n    }\n\n    export interface SessionState {\n        effectiveLocalWindowSize?: number;\n        effectiveRecvDataLength?: number;\n        nextStreamID?: number;\n        localWindowSize?: number;\n        lastProcStreamID?: number;\n        remoteWindowSize?: number;\n        outboundQueueSize?: number;\n        deflateDynamicTableSize?: number;\n        inflateDynamicTableSize?: number;\n    }\n\n    export interface Http2Session extends events.EventEmitter {\n        readonly alpnProtocol?: string;\n        close(callback?: () => void): void;\n        readonly closed: boolean;\n        readonly connecting: boolean;\n        destroy(error?: Error, code?: number): void;\n        readonly destroyed: boolean;\n        readonly encrypted?: boolean;\n        goaway(code?: number, lastStreamID?: number, opaqueData?: Buffer | DataView | NodeJS.TypedArray): void;\n        readonly localSettings: Settings;\n        readonly originSet?: string[];\n        readonly pendingSettingsAck: boolean;\n        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ping(payload: Buffer | DataView | NodeJS.TypedArray , callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ref(): void;\n        readonly remoteSettings: Settings;\n        rstStream(stream: Http2Stream, code?: number): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        readonly socket: net.Socket | tls.TLSSocket;\n        readonly state: SessionState;\n        priority(stream: Http2Stream, options: StreamPriorityOptions): void;\n        settings(settings: Settings): void;\n        readonly type: number;\n        unref(): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        addListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        addListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number, streamID: number): boolean;\n        emit(event: \"goaway\", errorCode: number, lastStreamID: number, opaqueData: Buffer): boolean;\n        emit(event: \"localSettings\", settings: Settings): boolean;\n        emit(event: \"remoteSettings\", settings: Settings): boolean;\n        emit(event: \"timeout\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        on(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        on(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        once(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        once(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependOnceListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependOnceListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n\n    export interface ClientHttp2Session extends Http2Session {\n        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        addListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"altsvc\", alt: string, origin: string, stream: number): boolean;\n        emit(event: \"connect\", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: \"stream\", stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        on(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        once(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependOnceListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n    }\n\n    export interface AlternativeServiceOptions {\n        origin: number | string | url.URL;\n    }\n\n    export interface ServerHttp2Session extends Http2Session {\n        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;\n        readonly server: Http2Server | Http2SecureServer;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"connect\", session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n    }\n\n    // Http2Server\n\n    export interface SessionOptions {\n        maxDeflateDynamicTableSize?: number;\n        maxReservedRemoteStreams?: number;\n        maxSendHeaderBlockLength?: number;\n        paddingStrategy?: number;\n        peerMaxConcurrentStreams?: number;\n        selectPadding?: (frameLen: number, maxFrameLen: number) => number;\n        settings?: Settings;\n    }\n\n    export type ClientSessionOptions = SessionOptions;\n    export type ServerSessionOptions = SessionOptions;\n\n    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions { }\n    export interface SecureServerSessionOptions extends ServerSessionOptions, tls.TlsOptions { }\n\n    export interface ServerOptions extends ServerSessionOptions {\n        allowHTTP1?: boolean;\n    }\n\n    export interface SecureServerOptions extends SecureServerSessionOptions {\n        allowHTTP1?: boolean;\n    }\n\n    export interface Http2Server extends net.Server {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"checkContinue\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n\n    export interface Http2SecureServer extends tls.Server {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"checkContinue\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"unknownProtocol\", socket: tls.TLSSocket): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"checkContinue\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n    }\n\n    export class Http2ServerRequest extends stream.Readable {\n        private constructor();\n        headers: IncomingHttpHeaders;\n        httpVersion: string;\n        method: string;\n        rawHeaders: string[];\n        rawTrailers: string[];\n        setTimeout(msecs: number, callback?: () => void): void;\n        socket: net.Socket | tls.TLSSocket;\n        stream: ServerHttp2Stream;\n        trailers: IncomingHttpHeaders;\n        url: string;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n    }\n\n    export class Http2ServerResponse extends events.EventEmitter {\n        private constructor();\n        addTrailers(trailers: OutgoingHttpHeaders): void;\n        connection: net.Socket | tls.TLSSocket;\n        end(callback?: () => void): void;\n        end(data?: string | Buffer, callback?: () => void): void;\n        end(data?: string | Buffer, encoding?: string, callback?: () => void): void;\n        readonly finished: boolean;\n        getHeader(name: string): string;\n        getHeaderNames(): string[];\n        getHeaders(): OutgoingHttpHeaders;\n        hasHeader(name: string): boolean;\n        readonly headersSent: boolean;\n        removeHeader(name: string): void;\n        sendDate: boolean;\n        setHeader(name: string, value: number | string | string[]): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        socket: net.Socket | tls.TLSSocket;\n        statusCode: number;\n        statusMessage: '';\n        stream: ServerHttp2Stream;\n        write(chunk: string | Buffer, callback?: (err: Error) => void): boolean;\n        write(chunk: string | Buffer, encoding?: string, callback?: (err: Error) => void): boolean;\n        writeContinue(): void;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\n        writeHead(statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders): void;\n        createPushResponse(headers: OutgoingHttpHeaders, callback: (err: Error | null, res: Http2ServerResponse) => void): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"finish\"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n    }\n\n    // Public API\n\n    export namespace constants {\n        const NGHTTP2_SESSION_SERVER: number;\n        const NGHTTP2_SESSION_CLIENT: number;\n        const NGHTTP2_STREAM_STATE_IDLE: number;\n        const NGHTTP2_STREAM_STATE_OPEN: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_CLOSED: number;\n        const NGHTTP2_NO_ERROR: number;\n        const NGHTTP2_PROTOCOL_ERROR: number;\n        const NGHTTP2_INTERNAL_ERROR: number;\n        const NGHTTP2_FLOW_CONTROL_ERROR: number;\n        const NGHTTP2_SETTINGS_TIMEOUT: number;\n        const NGHTTP2_STREAM_CLOSED: number;\n        const NGHTTP2_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_REFUSED_STREAM: number;\n        const NGHTTP2_CANCEL: number;\n        const NGHTTP2_COMPRESSION_ERROR: number;\n        const NGHTTP2_CONNECT_ERROR: number;\n        const NGHTTP2_ENHANCE_YOUR_CALM: number;\n        const NGHTTP2_INADEQUATE_SECURITY: number;\n        const NGHTTP2_HTTP_1_1_REQUIRED: number;\n        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_FLAG_NONE: number;\n        const NGHTTP2_FLAG_END_STREAM: number;\n        const NGHTTP2_FLAG_END_HEADERS: number;\n        const NGHTTP2_FLAG_ACK: number;\n        const NGHTTP2_FLAG_PADDED: number;\n        const NGHTTP2_FLAG_PRIORITY: number;\n        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;\n        const DEFAULT_SETTINGS_ENABLE_PUSH: number;\n        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;\n        const MAX_MAX_FRAME_SIZE: number;\n        const MIN_MAX_FRAME_SIZE: number;\n        const MAX_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_DEFAULT_WEIGHT: number;\n        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;\n        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;\n        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;\n        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;\n        const PADDING_STRATEGY_NONE: number;\n        const PADDING_STRATEGY_MAX: number;\n        const PADDING_STRATEGY_CALLBACK: number;\n        const HTTP2_HEADER_STATUS: string;\n        const HTTP2_HEADER_METHOD: string;\n        const HTTP2_HEADER_AUTHORITY: string;\n        const HTTP2_HEADER_SCHEME: string;\n        const HTTP2_HEADER_PATH: string;\n        const HTTP2_HEADER_ACCEPT_CHARSET: string;\n        const HTTP2_HEADER_ACCEPT_ENCODING: string;\n        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;\n        const HTTP2_HEADER_ACCEPT_RANGES: string;\n        const HTTP2_HEADER_ACCEPT: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;\n        const HTTP2_HEADER_AGE: string;\n        const HTTP2_HEADER_ALLOW: string;\n        const HTTP2_HEADER_AUTHORIZATION: string;\n        const HTTP2_HEADER_CACHE_CONTROL: string;\n        const HTTP2_HEADER_CONNECTION: string;\n        const HTTP2_HEADER_CONTENT_DISPOSITION: string;\n        const HTTP2_HEADER_CONTENT_ENCODING: string;\n        const HTTP2_HEADER_CONTENT_LANGUAGE: string;\n        const HTTP2_HEADER_CONTENT_LENGTH: string;\n        const HTTP2_HEADER_CONTENT_LOCATION: string;\n        const HTTP2_HEADER_CONTENT_MD5: string;\n        const HTTP2_HEADER_CONTENT_RANGE: string;\n        const HTTP2_HEADER_CONTENT_TYPE: string;\n        const HTTP2_HEADER_COOKIE: string;\n        const HTTP2_HEADER_DATE: string;\n        const HTTP2_HEADER_ETAG: string;\n        const HTTP2_HEADER_EXPECT: string;\n        const HTTP2_HEADER_EXPIRES: string;\n        const HTTP2_HEADER_FROM: string;\n        const HTTP2_HEADER_HOST: string;\n        const HTTP2_HEADER_IF_MATCH: string;\n        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;\n        const HTTP2_HEADER_IF_NONE_MATCH: string;\n        const HTTP2_HEADER_IF_RANGE: string;\n        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;\n        const HTTP2_HEADER_LAST_MODIFIED: string;\n        const HTTP2_HEADER_LINK: string;\n        const HTTP2_HEADER_LOCATION: string;\n        const HTTP2_HEADER_MAX_FORWARDS: string;\n        const HTTP2_HEADER_PREFER: string;\n        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;\n        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;\n        const HTTP2_HEADER_RANGE: string;\n        const HTTP2_HEADER_REFERER: string;\n        const HTTP2_HEADER_REFRESH: string;\n        const HTTP2_HEADER_RETRY_AFTER: string;\n        const HTTP2_HEADER_SERVER: string;\n        const HTTP2_HEADER_SET_COOKIE: string;\n        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;\n        const HTTP2_HEADER_TRANSFER_ENCODING: string;\n        const HTTP2_HEADER_TE: string;\n        const HTTP2_HEADER_UPGRADE: string;\n        const HTTP2_HEADER_USER_AGENT: string;\n        const HTTP2_HEADER_VARY: string;\n        const HTTP2_HEADER_VIA: string;\n        const HTTP2_HEADER_WWW_AUTHENTICATE: string;\n        const HTTP2_HEADER_HTTP2_SETTINGS: string;\n        const HTTP2_HEADER_KEEP_ALIVE: string;\n        const HTTP2_HEADER_PROXY_CONNECTION: string;\n        const HTTP2_METHOD_ACL: string;\n        const HTTP2_METHOD_BASELINE_CONTROL: string;\n        const HTTP2_METHOD_BIND: string;\n        const HTTP2_METHOD_CHECKIN: string;\n        const HTTP2_METHOD_CHECKOUT: string;\n        const HTTP2_METHOD_CONNECT: string;\n        const HTTP2_METHOD_COPY: string;\n        const HTTP2_METHOD_DELETE: string;\n        const HTTP2_METHOD_GET: string;\n        const HTTP2_METHOD_HEAD: string;\n        const HTTP2_METHOD_LABEL: string;\n        const HTTP2_METHOD_LINK: string;\n        const HTTP2_METHOD_LOCK: string;\n        const HTTP2_METHOD_MERGE: string;\n        const HTTP2_METHOD_MKACTIVITY: string;\n        const HTTP2_METHOD_MKCALENDAR: string;\n        const HTTP2_METHOD_MKCOL: string;\n        const HTTP2_METHOD_MKREDIRECTREF: string;\n        const HTTP2_METHOD_MKWORKSPACE: string;\n        const HTTP2_METHOD_MOVE: string;\n        const HTTP2_METHOD_OPTIONS: string;\n        const HTTP2_METHOD_ORDERPATCH: string;\n        const HTTP2_METHOD_PATCH: string;\n        const HTTP2_METHOD_POST: string;\n        const HTTP2_METHOD_PRI: string;\n        const HTTP2_METHOD_PROPFIND: string;\n        const HTTP2_METHOD_PROPPATCH: string;\n        const HTTP2_METHOD_PUT: string;\n        const HTTP2_METHOD_REBIND: string;\n        const HTTP2_METHOD_REPORT: string;\n        const HTTP2_METHOD_SEARCH: string;\n        const HTTP2_METHOD_TRACE: string;\n        const HTTP2_METHOD_UNBIND: string;\n        const HTTP2_METHOD_UNCHECKOUT: string;\n        const HTTP2_METHOD_UNLINK: string;\n        const HTTP2_METHOD_UNLOCK: string;\n        const HTTP2_METHOD_UPDATE: string;\n        const HTTP2_METHOD_UPDATEREDIRECTREF: string;\n        const HTTP2_METHOD_VERSION_CONTROL: string;\n        const HTTP_STATUS_CONTINUE: number;\n        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;\n        const HTTP_STATUS_PROCESSING: number;\n        const HTTP_STATUS_OK: number;\n        const HTTP_STATUS_CREATED: number;\n        const HTTP_STATUS_ACCEPTED: number;\n        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;\n        const HTTP_STATUS_NO_CONTENT: number;\n        const HTTP_STATUS_RESET_CONTENT: number;\n        const HTTP_STATUS_PARTIAL_CONTENT: number;\n        const HTTP_STATUS_MULTI_STATUS: number;\n        const HTTP_STATUS_ALREADY_REPORTED: number;\n        const HTTP_STATUS_IM_USED: number;\n        const HTTP_STATUS_MULTIPLE_CHOICES: number;\n        const HTTP_STATUS_MOVED_PERMANENTLY: number;\n        const HTTP_STATUS_FOUND: number;\n        const HTTP_STATUS_SEE_OTHER: number;\n        const HTTP_STATUS_NOT_MODIFIED: number;\n        const HTTP_STATUS_USE_PROXY: number;\n        const HTTP_STATUS_TEMPORARY_REDIRECT: number;\n        const HTTP_STATUS_PERMANENT_REDIRECT: number;\n        const HTTP_STATUS_BAD_REQUEST: number;\n        const HTTP_STATUS_UNAUTHORIZED: number;\n        const HTTP_STATUS_PAYMENT_REQUIRED: number;\n        const HTTP_STATUS_FORBIDDEN: number;\n        const HTTP_STATUS_NOT_FOUND: number;\n        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;\n        const HTTP_STATUS_NOT_ACCEPTABLE: number;\n        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;\n        const HTTP_STATUS_REQUEST_TIMEOUT: number;\n        const HTTP_STATUS_CONFLICT: number;\n        const HTTP_STATUS_GONE: number;\n        const HTTP_STATUS_LENGTH_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_FAILED: number;\n        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;\n        const HTTP_STATUS_URI_TOO_LONG: number;\n        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;\n        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;\n        const HTTP_STATUS_EXPECTATION_FAILED: number;\n        const HTTP_STATUS_TEAPOT: number;\n        const HTTP_STATUS_MISDIRECTED_REQUEST: number;\n        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;\n        const HTTP_STATUS_LOCKED: number;\n        const HTTP_STATUS_FAILED_DEPENDENCY: number;\n        const HTTP_STATUS_UNORDERED_COLLECTION: number;\n        const HTTP_STATUS_UPGRADE_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_REQUIRED: number;\n        const HTTP_STATUS_TOO_MANY_REQUESTS: number;\n        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;\n        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;\n        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;\n        const HTTP_STATUS_NOT_IMPLEMENTED: number;\n        const HTTP_STATUS_BAD_GATEWAY: number;\n        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;\n        const HTTP_STATUS_GATEWAY_TIMEOUT: number;\n        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;\n        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;\n        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;\n        const HTTP_STATUS_LOOP_DETECTED: number;\n        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;\n        const HTTP_STATUS_NOT_EXTENDED: number;\n        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;\n    }\n\n    export function getDefaultSettings(): Settings;\n    export function getPackedSettings(settings: Settings): Settings;\n    export function getUnpackedSettings(buf: Buffer | Uint8Array): Settings;\n\n    export function createServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n    export function createServer(options: ServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n\n    export function createSecureServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n    export function createSecureServer(options: SecureServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n\n    export function connect(authority: string | url.URL, listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;\n    export function connect(\n        authority: string | url.URL,\n        options?: ClientSessionOptions | SecureClientSessionOptions,\n        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n    ): ClientHttp2Session;\n}\n\ndeclare module \"perf_hooks\" {\n    import { AsyncResource } from \"async_hooks\";\n\n    interface PerformanceEntry {\n        /**\n         * The total number of milliseconds elapsed for this entry.\n         * This value will not be meaningful for all Performance Entry types.\n         */\n        readonly duration: number;\n\n        /**\n         * The name of the performance entry.\n         */\n        readonly name: string;\n\n        /**\n         * The high resolution millisecond timestamp marking the starting time of the Performance Entry.\n         */\n        readonly startTime: number;\n\n        /**\n         * The type of the performance entry.\n         * Currently it may be one of: 'node', 'mark', 'measure', 'gc', or 'function'.\n         */\n        readonly entryType: string;\n\n        /**\n         * When performanceEntry.entryType is equal to 'gc', the performance.kind property identifies\n         * the type of garbage collection operation that occurred.\n         * The value may be one of perf_hooks.constants.\n         */\n        readonly kind?: number;\n    }\n\n    interface PerformanceNodeTiming extends PerformanceEntry {\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process completed bootstrap.\n         */\n        readonly bootstrapComplete: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing ended.\n         */\n        readonly clusterSetupEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing started.\n         */\n        readonly clusterSetupStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop exited.\n         */\n        readonly loopExit: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop started.\n         */\n        readonly loopStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load ended.\n         */\n        readonly moduleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load started.\n         */\n        readonly moduleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process was initialized.\n         */\n        readonly nodeStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load ended.\n         */\n        readonly preloadModuleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load started.\n         */\n        readonly preloadModuleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing ended.\n         */\n        readonly thirdPartyMainEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing started.\n         */\n        readonly thirdPartyMainStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the V8 platform was initialized.\n         */\n        readonly v8Start: number;\n    }\n\n    interface Performance {\n        /**\n         * If name is not provided, removes all PerformanceFunction objects from the Performance Timeline.\n         * If name is provided, removes entries with name.\n         * @param name\n         */\n        clearFunctions(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMark objects from the Performance Timeline.\n         * If name is provided, removes only the named mark.\n         * @param name\n         */\n        clearMarks(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMeasure objects from the Performance Timeline.\n         * If name is provided, removes only objects whose performanceEntry.name matches name.\n         */\n        clearMeasures(name?: string): void;\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         * @return list of all PerformanceEntry objects\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         * @param name\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByName(name: string, type?: string): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByType(type: string): PerformanceEntry[];\n\n        /**\n         * Creates a new PerformanceMark entry in the Performance Timeline.\n         * A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'mark',\n         * and whose performanceEntry.duration is always 0.\n         * Performance marks are used to mark specific significant moments in the Performance Timeline.\n         * @param name\n         */\n        mark(name?: string): void;\n\n        /**\n         * Creates a new PerformanceMeasure entry in the Performance Timeline.\n         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',\n         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.\n         *\n         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify\n         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,\n         * then startMark is set to timeOrigin by default.\n         *\n         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp\n         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.\n         * @param name\n         * @param startMark\n         * @param endMark\n         */\n        measure(name: string, startMark: string, endMark: string): void;\n\n        /**\n         * An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones.\n         */\n        readonly nodeTiming: PerformanceNodeTiming;\n\n        /**\n         * @return the current high resolution millisecond timestamp\n         */\n        now(): number;\n\n        /**\n         * The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured.\n         */\n        readonly timeOrigin: number;\n\n        /**\n         * Wraps a function within a new function that measures the running time of the wrapped function.\n         * A PerformanceObserver must be subscribed to the 'function' event type in order for the timing details to be accessed.\n         * @param fn\n         */\n        timerify<T extends (...optionalParams: any[]) => any>(fn: T): T;\n    }\n\n    interface PerformanceObserverEntryList {\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByName(name: string, type?: string): PerformanceEntry[];\n\n        /**\n         * @return Returns a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByType(type: string): PerformanceEntry[];\n    }\n\n    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;\n\n    class PerformanceObserver extends AsyncResource {\n        constructor(callback: PerformanceObserverCallback);\n\n        /**\n         * Disconnects the PerformanceObserver instance from all notifications.\n         */\n        disconnect(): void;\n\n        /**\n         * Subscribes the PerformanceObserver instance to notifications of new PerformanceEntry instances identified by options.entryTypes.\n         * When options.buffered is false, the callback will be invoked once for every PerformanceEntry instance.\n         * Property buffered defaults to false.\n         * @param options\n         */\n        observe(options: { entryTypes: string[], buffered?: boolean }): void;\n    }\n\n    namespace constants {\n        const NODE_PERFORMANCE_GC_MAJOR: number;\n        const NODE_PERFORMANCE_GC_MINOR: number;\n        const NODE_PERFORMANCE_GC_INCREMENTAL: number;\n        const NODE_PERFORMANCE_GC_WEAKCB: number;\n    }\n\n    const performance: Performance;\n}\n",
      "sourceFile": [
        "sourceFile",
        "01m4wmbdh7dp"
      ],
      "thing": "sourceFile",
      "kind": "SourceFile",
      "flags": [
        "ExportContext",
        "Ambient"
      ],
      "fileName": "/home/travis/build/mike-north/js-documentation-cases/node_modules/@types/node/index.d.ts",
      "isDeclarationFile": true,
      "amdDependencies": [],
      "referencedFiles": [
        {
          "name": "./inspector.d.ts",
          "pos": 2134,
          "end": 2150
        }
      ]
    }
  }
}